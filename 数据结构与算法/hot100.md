[分享｜不同层次的面试算法学习规划 - 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3142247/mian-shi-xiang-de-xue-xi-gui-hua-by-shaw-548u/)

### 前缀和总结

一、 核心思想

前缀和的本质是 **“空间换时间”**。它通过**预处理**，将一个数组从开头到每个位置的**累加和**存储在一个新的数组（前缀和数组）中。这样，当你需要查询任意一个区间的和时，就不再需要遍历该区间，而是可以通过简单的数学运算在 **O(1)** 时间内得出结果。

二、 如何构造与使用

1. 一维前缀和

   对于一个原始数组 nums，其前缀和数组 prefixSum 的构造和使用如下：

- **构造 (Construction)**

  - 我们通常创建一个比原数组长1的 `prefixSum` 数组，并将 `prefixSum[0]` 初始化为0。这个额外的0被称为**哨兵 (sentinel)**，可以极大简化边界处理。

  - 递推公式：`prefixSum[i] = prefixSum[i-1] + nums[i-1]`

    ```c++
    // nums: [1, 2, 3, 4]
    // prefixSum: [0, 1, 3, 6, 10]
    vector<int> prefixSum(nums.size() + 1, 0);
    for (int i = 0; i < nums.size(); ++i) {
        prefixSum[i+1] = prefixSum[i] + nums[i];
    }
    ```

- **使用 (Usage)**

  - 计算 `nums` 数组中**闭区间 `[i, j]`** 的和。
  - 查询公式：`sum(i, j) = prefixSum[j+1] - prefixSum[i]`

  ```c++
  // 查询 nums[1] 到 nums[3] 的和，即 [2, 3, 4]
  int i = 1, j = 3;
  int rangeSum = prefixSum[j+1] - prefixSum[i]; // prefixSum[4] - prefixSum[1] = 10 - 1 = 9
  ```

三、 典型应用场景

前缀和的应用远不止直接求区间和，它经常与其他数据结构（尤其是哈希表）结合，解决更复杂的问题。

场景一：频繁的静态区间和查询

这是最直接的应用。当需要对一个**不会改变**的数组进行多次区间和查询时，预处理出前缀和数组是最佳选择。

- **例题**: LeetCode 303. 区域和检索 - 数组不可变

场景二：寻找和为 k 的子数组 (前缀和 + 哈希表)

这是前缀和最高频的考点之一。问题通常是：寻找一个连续子数组，其和恰好等于 k。

- **核心思路**：我们知道 sum(i, j) = prefixSum[j+1] - prefixSum[i]。如果子数组 [i, j] 的和为 k，则 prefixSum[j+1] - prefixSum[i] = k。将公式变形得到：prefixSum[i] = prefixSum[j+1] - k。**解法**：我们从左到右遍历数组，计算当前的前缀和 currentSum (相当于 prefixSum[j+1])。然后，我们去查找是否存在一个历史前缀和 oldSum (相当于 prefixSum[i]) 满足 oldSum = currentSum - k。**工具**：使用一个**哈希表 (unordered_map)** 来存储**历史前缀和及其出现的次数**。在遍历过程中，一边计算新的前缀和，一边在哈希表中查找所需的目标历史和，同时将当前的前缀和存入哈希表。
- **例题**: LeetCode 560. 和为 K 的子数组

场景三：二维矩阵的区域和查询

前缀和可以扩展到二维。用于快速查询一个子矩阵的元素和。

- **构造**：`sum[i][j]` 表示从 (0,0) 到 (i-1,j-1) 的矩阵区域的和。递推公式（基于**容斥原理**）：
  `um[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + matrix[i-1][j-1]`
- **使用**：查询以 (r1, c1) 为左上角，(r2, c2) 为右下角的子矩阵和。查询公式：
  `rangeSum = sum[r2+1][c2+1] - sum[r1][c2+1] - sum[r2+1][c1] + sum[r1][c1]`
- **例题**: LeetCode 304. 二维区域和检索 - 矩阵不可变

场景四：437. 路径总和 III

四、 实现要点与技巧

1. **使用哨兵**：prefixSum 数组的长度设为 N+1，且 prefixSum[0] = 0。这可以避免在计算从索引0开始的区间和时进行特殊判断，使 sum(0, j) = prefixSum[j+1] - prefixSum[0] = prefixSum[j+1] 成立。
2. **注意索引**：prefixSum[i] 对应的是 nums 数组 0 到 i-1 的和。在构造和查询时要确保索引的正确转换。
3. **数据溢出**：当数组元素较大或较长时，前缀和可能会超出 int 的范围，应考虑使用 long long。

总结

| 问题类型                          | 核心技巧                 | 关键点                                   |
| --------------------------------- | ------------------------ | ---------------------------------------- |
| **静态数组，多次求区间和**        | **一维/二维前缀和**      | O(N)预处理，O(1)查询                     |
| **和为k的子数组个数/存在性**      | **前缀和 + 哈希表**      | 核心公式 map.count(currentSum - k)       |
| **涉及子数组/子矩阵和的复杂问题** | **前缀和作为预处理步骤** | 将问题中求和的部分优化掉，专注于其他逻辑 |

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap{};
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int expect = target - nums[i];
            const auto& e = umap.find(expect);
            if (e == umap.end()) {  // 没找到
                umap.insert(make_pair(nums[i], i));
            }else {                 // 找到
                res.push_back(i);
                res.push_back(e->second);
                return res;
            }
        }
        return res;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)???

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty())
            return vector<vector<int>>{};
        sort(intervals.begin(), intervals.end());	// 1. 先排序（最重要）
        vector<vector<int>> res{};
        vector<int> merge(intervals[0]);
        for (vector<int>& vec : intervals) {
            if (merge[1] >= vec[0])					// 2. 排序之后，只要左区间最大的比右区间最小的值大，就说明重叠
                merge[1] = max(merge[1], vec[1]);
            else {									// 3. 否则说明合并结束
                res.push_back(merge);
                merge = vec;
            }
        }
        res.push_back(merge);
        return res;
    }
};
```

#### 总结：sort函数的使用时机

- 处理区间问题 (Interval Problems)

  这是最常见的使用场景之一，也是你提到的 **“合并区间” (Merge Intervals, 笔记第140页)** 问题的核心解法。

  - **原因**: 对区间按起点排序后，我们就可以按顺序线性扫描，只需考虑当前区间与前一个合并后的区间的关系。如果不排序，我们就需要比较任意两个区间，逻辑会变得异常复杂。
  - **笔记中的例子**:
    - **56. 合并区间**: 按区间起点排序，然后依次合并。
    - **452. 用最少数量的箭引爆气球** (第136页): 按区间起点或终点排序，然后贪心地确定箭的位置。
    - **435. 无重叠区间** (第137页): 按区间终点排序，然后贪心地选择不重叠的区间。

- 启用“双指针”或“二分查找”技巧

  当需要在一个数组中寻找两个或多个满足特定和（sum）条件的元素时，排序是启用高效算法的前提。

  - **原因**: 在一个无序数组中寻找两数之和为target，通常需要O(n²)的暴力搜索或借助O(n)空间复杂度的哈希表。但如果数组有序，就可以使用双指针从两端向中间扫描，在O(n)的时间复杂度和O(1)的空间复杂度内解决问题。
  - **笔记中的例子**:
    - **15. 三数之和** (第31页): 笔记中明确提到“考虑到本题不需要返回数组下标，所以我们可以直接对这个数组进行排序，排序之后时间复杂度有效下降。” 排序后，固定一个数，再用双指针寻找另外两个数。
    - **18. 四数之和** (第32页): 与“三数之和”同理，排序是使用双指针解法的基础。

- 方便去重 (Handling Duplicates)

  在求解组合、子集、排列等问题时，如果输入数组含有重复元素，而输出要求不能有重复的组合，排序是最高效的去重前置步骤。

  - **原因**: 排序后，所有相同的元素会聚集在一起。这样在进行深度优先搜索（回溯）时，我们就可以通过一个简单的判断（例如 if (i > 0 && nums[i] == nums[i-1])）来跳过由重复元素产生的相同分支，从而避免结果重复。
  - **笔记中的例子**:
    - **40. 组合总和 II** (第109页): 笔记中提到这是“树层去重”，排序是实现这种去重逻辑的关键。
    - **90. 子集 II** (第115页): 同理，先排序，再通过判断来跳过重复的元素。
    - **47. 全排列 II** (第119页): 同样先排序，以方便在回溯过程中识别和跳过重复的排列。

- 运用贪心算法 (Greedy Algorithms)

  很多贪心算法的正确性依赖于一个前提：总是对当前“最好”或“最优”的元素做选择。排序可以帮助我们快速定位到这个“最优”元素。

  - **原因**: 通过排序，我们可以将问题转化为每次都从剩余元素中选择最大/最小，或者最先开始/结束的项。
  - **笔记中的例子**:
    - **455. 分发饼干** (第121页): 将孩子的胃口和饼干的尺寸都排序，然后用最小的饼干去满足胃口最小的孩子，这就是一个经典的贪心策略。
    - **406. 根据身高重建队列** (第135页): 笔记中提到“遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。” 这里通过先按身高降序、再按k值升序的排序规则，使得每次插入一个人时，都能保证其插入位置的正确性。

- 创建“范式”或“唯一标识”

  当需要对某些内容进行分类或分组，而这些内容有多种表现形式时（例如字母异位词），可以通过排序创造一个唯一的、标准化的“范式”（Canonical Form）作为它们的标识。

  - **笔记中的例子**:
    - **49. 字母异位词分组** (第23页): 笔记提到“可以通过sort排序将异位词变成一样的就好了”。例如，"eat", "tea", "ate" 排序后都变成了 "aet"，可以把 "aet" 作为键，将它们分到同一组。

- 总结

  总的来说，当你遇到以下情况时，可以优先考虑**先对数据进行排序**，这往往能极大地简化你的思考过程和代码逻辑：

  - **涉及区间操作**：几乎总是需要排序。
  - **寻找和为定值的多个数**：排序后可以使用双指针。
  - **结果要求去重，但输入可能重复**：排序是回溯算法去重的基础。
  - **问题看起来可以用贪心策略解决**：排序帮你找到每一步的“贪心选择”。
  - **需要对不同表现形式的同类项进行分组**：排序帮你找到它们的“统一身份证”。

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

解法一：使用额外数组。

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        if (nums.size() == k || nums.size() == 0 || k == 0)
            return;

        int start_k = nums.size() - k;
        vector<int> numk{nums.begin() + start_k, nums.end()};
        for (int i = start_k - 1; i >= 0; i--) {
            nums[i + k] = nums[i];
        }
        for (int i = 0; i < numk.size(); i++) {
            nums[i] = numk[i];
        }
    }
};
```

解法二：数组翻转（和链表翻转很像）

```c++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        }
    }

    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }
};
```

解法三：环状替换（不懂）



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)（vec的小坑）

方法一：笨方法（左侧乘积放一个数组，右侧乘积放一个数组，然后再搞个答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        vector<pair<int, int>> tmp(nums.size()); // pair<0-i的乘积, i-end的乘积>
        // 左侧乘积
        int product = 1;
        for (int i = 0; i < nums.size(); i++) {
            product *= nums[i];
            tmp[i].first = product;
        }
        // 右侧乘积
        product = 1;
        for (int i = nums.size() - 1; i >= 0; i--) {
            product *= nums[i];
            tmp[i].second = product;
        }

        // 这样初始化后，res中存在四个值为0的int，push时会往后移
        // vector<int> res(nums.size()); 
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int l = (i == 0) ? 1 : tmp[i - 1].first;
            int r = (i == nums.size() - 1) ? 1 : tmp[i + 1].second;
            res.push_back(l * r);
        }
        return res;
    }
};
```

方法二：合并左右乘积列表（左侧乘积放在答案数组中，然后从右往左将右侧乘积 × 答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        if (nums.size() == 1)
            return {1};
        vector<int> res(nums.size(), 1);
        // 左侧乘积
        for (int i = 1; i < nums.size(); i++) {
            // res[i]表示 0 -> i-1 的乘积
            res[i] = res[i - 1] * nums[i - 1];
        }

        // 使用product代替右侧乘积
        int product = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            product *= nums[i + 1];
            // 此时product表示 i+1 -> end 的乘积
            res[i] *= product;
        }
        return res;
    }
};
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

本题的思路很清奇：**使用负号来作为标记**；类似的思路在许多需要`O(1)`额外空间的题目中非常好用

```c++
class Solution {
public:

    void vecdebug(vector<int>& nums) {
        for (int& e : nums)
            cout << e << " ";
        cout << "\n";
    }

    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int& e : nums) {
            if (e <= 0)
                e = n + 1;
        }
        vecdebug(nums);

        // 打标记
        for (int i = 0; i < nums.size(); i++) {
            // // curr可能被被标记改为负值，但是我们只对其值感兴趣，所以需要标记
            int curr = abs(nums[i]);
            if (curr <= n && curr >= 1)
                // 使用负号作为标记，表示当前下表的值在数组中出现过
                // 需要注意防止重复标记，所以需要abs
                nums[curr - 1] = -1 * abs(nums[curr - 1]);
        }
        vecdebug(nums);

        // 检查标记
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0)
                return i + 1;
        }
        return n + 1;
    }
};
```

### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

使用`O(m+n)`的额外空间

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return;
        vector<int> row{};
        vector<int> column{};
        int m = matrix.size(); // m行
        int n = matrix[0].size(); // n列
        cout << n << endl;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row.push_back(i);
                    column.push_back(j);
                }
            }
        }

        // 行清空
        for (int& e : row) {
            auto tmp = vector(n, 0);
            matrix[e].swap(tmp);
        }
        // 列清空
        for (int& e : column) {
            for (int i = 0; i < m; i++) {
                matrix[i][e] = 0;
            }
        }
    }
};
```

使用`O(1)`的额外空间，这里和41题类似，**使用了0作为标记**

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return;
        int m = matrix.size();
        int n = matrix[0].size();
        bool row_zero = false;
        bool col_zero = false;

        // 第0行有0，则row_zero为true
        for (int& e : matrix[0]) {
            if (e == 0)
                row_zero = true;
        }
        // 第0列有0，则col_zero为true
        for (int j = 0; j < m; j++) {
            if (matrix[j][0] == 0)
                col_zero = true;
        }
        // 如果[i][j]的值为0，则将[i][0]和[0][j]都设置为0
        // 表示当前行和列需要设置为0
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // 从第一行第一列开始看起，根据第0行和第0列的值判断当前位置是否需要设置为0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            }
        }

        if (row_zero) {
            auto tmp = vector<int>(n, 0);
            matrix[0].swap(tmp);
        }
        if (col_zero) {
            for (int i = 0; i < m; i++)
                matrix[i][0] = 0;
        }
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

模拟题，

1. 以前的思路是使用一个数，比如left，right来表示边界，但这样很麻烦，因为我们是用的一个一维数来表示二维坐标，表达很不清晰，所以我们可以使用pair来表示边界，这样就很清楚了。
2. 遇到涉及区间的问题时，一定要坚持不变量（比如左闭右开）
3. 注意只有一行/只有一列时，存在重复输出的现象。

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return {};
        vector<int> res{};
        pair<int, int> ltop{0, 0}, rtop{0, matrix[0].size() - 1};
        pair<int, int> ldown{matrix.size() - 1, 0}, rdown{matrix.size() - 1, matrix[0].size() - 1};
        while ( (ltop <= rtop) && (ltop <= ldown) ) {
            // 输出左闭右闭top行，此时只有col变化
            for (int i = ltop.second; i <= rtop.second; i++) {
                res.push_back(matrix[ltop.first][i]);
            }
            // 输出上开下开right列，此时只有row变化
            for (int i = rtop.first + 1; i <= rdown.first - 1; i++) {
                res.push_back(matrix[i][rtop.second]);
            }

            do {
                // 如果只有一行，left列和right列没有数据，且down行和top行数据重复，不要输出
                if (ltop == ldown)
                    break;
                // 输出右闭左闭down行，此时只有col变化
                for (int i = rdown.second; i >= ldown.second; i--) {
                    res.push_back(matrix[rdown.first][i]);
                }

                // 如果只有一列，left列和right列数据重复，不要输出
                if (ltop == rtop)
                    break;
                // 输出下开上开left列，此时只有row变化
                for (int i = ldown.first - 1; i >= ltop.first + 1; i--) {
                    res.push_back(matrix[i][ldown.second]);
                }
            }while (0);

            ++ltop.first;
            ++ltop.second;

            ++rtop.first;
            --rtop.second;

            --rdown.first;
            --rdown.second;

            --ldown.first;
            ++ldown.second;
        }
        return res;
    }
};
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

顺时针90°：转置 + 水平镜像
逆时针90°：转置 + 垂直镜像
180°：水平镜像 + 垂直镜像

```c++
class Solution {
public:
    void traverse(vector<vector<int>>& matrix) {
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = i; j < matrix[0].size(); j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
    void horizon_mirror(vector<vector<int>>& matrix) {
        int n = matrix[0].size() - 1;
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size() / 2; j++) {
                swap(matrix[i][j], matrix[i][n - j]);
            }
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        traverse(matrix);
        horizon_mirror(matrix);
    }
};
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

想象成二叉搜索树

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty())
            return false;
        int row = 0, col = matrix[0].size() - 1;

        while (row < matrix.size() && col >= 0) {
            int curr = matrix[row][col];
            if (curr == target)
                return true;
            if (target > curr) {    // 找右儿子
                // 右儿子：行+1，列不变
                ++row;
            }
            else if (target < curr) {   // 找左儿子
                // 左儿子：行不变，列-1
                --col;
            }
        }
        return false;
    }
};
```

## 链表

### 链表总结

1. **虚拟头节点 (Dummy Head Node)**

   这是解决链表修改类问题的“银弹”。它是一个位于真实头节点head之前的哨兵节点。

   - **解决什么问题**：当链表的**头节点**本身可能会被修改（例如，删除头节点、在头节点前插入新节点）时，使用虚拟头节点可以极大地简化逻辑。

   - **为什么有效**：它能保证链表永远有一个固定的“头”（即dummy节点），从而让所有节点的处理逻辑（无论是头节点还是中间节点）都变得**统一**，无需为头节点写单独的if-else判断。

   - **笔记中的体现**：

     - **203. 移除链表元素 (第8页)**：删除的元素可能是头节点。
     - **24. 两两交换链表中的节点 (第14页)**：第一个节点会被交换，导致头节点变化。你的笔记里写道：“**所有涉及到更改节点的链表题都必须设置虚拟指针！！！！**” —— 这个总结非常到位！

   - **使用方法**：

     ```c++
     ListNode* dummyHead = new ListNode(0); // 创建虚拟头节点
     dummyHead->next = head;                 // 连接到真实头节点
     // ... 对链表进行操作，起点是 dummyHead
     return dummyHead->next;                 // 返回新的头节点
     ```

   ---

2. **双指针 (Two Pointers)**

   双指针是链表问题中最灵活、最强大的技巧，根据指针的移动方式，可以分为以下几种：

   一个指针每次走一步（slow），另一个指针每次走两步（fast）。

   - **解决什么问题**：
     1. **寻找链表中点**：当fast指针到达链表末尾时，slow指针正好在链表中点。
     2. **判断链表是否有环**：如果fast和slow指针能够相遇，则链表有环。
     3. **寻找环的入口**：在相遇后，将一个指针放回头节点，然后两个指针都每次走一步，再次相遇点即为环的入口。
     
   - **笔记中的体现**：
     - **142. 环形链表 II (第21页)**：笔记中详细总结了快慢指针的三种用法，是此模式的经典应用。
   
     通常用pre和curr两个指针，pre始终指向curr的前一个节点。为了更新，往往还需要第三个指针temp来保存curr的下一个节点。 
     
   - **解决什么问题**：
     1. **反转链表**：这是最经典的应用。
     2. **原地修改/删除**：需要知道前驱节点来进行pre->next = curr->next之类的操作。
     
   - **笔记中的体现**：
     
     - **206. 反转链表 (第10页)**：你的笔记里详细拆解了pre、curr、temp三者的配合，这正是该模式的核心。
       1. temp = curr->next; // 保存下一个节点，防止断链
       2. curr->next = pre; // 核心反转操作
       3. pre = curr; // pre后移
       4. curr = temp; // curr后移
   
   一个指针（fast）先走 n 步，然后两个指针（fast 和 slow）再一起走，直到fast到达链表末尾。
   
   - **解决什么问题**：
     1. **删除链表的倒数第 N 个节点**。
   - **笔记中的体现**：
     - **19. 删除链表的倒数第 N 个结点 (第16页)**：让fast先走n步，这样slow和fast之间就保持了n的距离。当fast走到末尾时，slow正好指向倒数第n个节点的前一个节点，方便执行删除操作。

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

先把两个链表长度对齐，然后同步遍历

```c++
class Solution {
public:
    ListNode* move_forward(ListNode* curr, int stride) {
        while (stride > 0 && curr) {
            curr = curr->next;
            --stride;
        }
        return curr;
    }

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB)
            return nullptr;

        int lenA = 0;
        int lenB = 0;

        // 获取长度
        ListNode* currA = headA;
        while (currA) {
            ++lenA;
            currA = currA->next;
        }
        ListNode* currB = headB;
        while (currB) {
            ++lenB;
            currB = currB->next;
        }

        // 对齐长度
        currA = headA;
        currB = headB;
        if (lenA > lenB)
            currA = move_forward(currA, lenA - lenB);
        else if (lenB > lenA)
            currB = move_forward(currB, lenB - lenA);

        // 等待相遇
        while (currA && currB) {
            if (currA == currB)
                return currA;
            currA = currA->next;
            currB = currB->next;
        }
        return nullptr;
    }
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

双指针+tmp

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* left = nullptr;
        ListNode* right = head;
        ListNode* tmp = nullptr;

        while (right) {
            tmp = right->next;
            right->next = left;
            left = right;
            right = tmp;
        }
        return left;
    }
};
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)？？？

根据下面的142，最好将本题代码实现为：fast走过的路程与slow走过的路程为倍数关系

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head)
            return false;
        if (!head->next)
            return true;

        // slow 最后停在链表前半部分的结尾
        // 这里可以做个简单的想象：链表只有两个节点和只有三个节点的情况
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* rightHead = slow->next;
        slow->next = nullptr;

        // 反转后半部分，不反转前半部分是因为后半部分可能比前半部分多1
        ListNode* left = nullptr;
        ListNode* right = rightHead;
        ListNode* tmp = nullptr;
        while (right) {
            tmp = right->next;
            right->next = left;
            left = right;
            right = tmp;
        }

        // 开始遍历
        ListNode* currLeft = head;
        ListNode* currRight = left;
        while (currLeft) {
            if (currLeft->val != currRight->val)
                return false;
            currLeft = currLeft->next;
            currRight = currRight->next;
        }
        return true;
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next)
            return false;
        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast->next && fast->next->next) {
            if (slow == fast)
                return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        return false;
    }
};
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

注意本题中的slow和fast被初始化为：

```c++
ListNode* slow = head;
ListNode* fast = head;
```

与之前的写法有所不同，是因为：

之前的写法中，我期望fast和slow的下标存在倍数关系（当slow下标不为0时）

而本题的数学关系是：**fast和slow走过的路程存在倍数关系，所以在开始时，fast和slow都需要初始为head**

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head || !head->next)
            return nullptr;

        // slow和fast相遇后，拿slow作为标兵
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
                break;
        }
        if (slow != fast)
            return nullptr;
        
        // 标兵和curr在入环节点相遇
        ListNode* curr = head;
        while (slow != curr) {
            slow = slow->next;
            curr = curr->next;
        }
        return curr;
    }
};
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

唯一需要注意的是，curr，curr1，curr2都需要往后移动

```c++
class Solution {
    public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1)
            return list2;
        if (!list2)
            return list1;

        ListNode* curr1 = list1;
        ListNode* curr2 = list2;
        ListNode* dummy = new ListNode{0};
        ListNode* curr = dummy;

        while (curr1 || curr2) {
            if (!curr1) {				// curr1为空
                curr->next = curr2;
                curr2 = curr2->next;
            }
            else if (!curr2) {			// curr2为空
                curr->next = curr1;
                curr1 = curr1->next;
            }
            else {						// curr1和curr2非空
                if (curr1->val < curr2->val) {	
                    curr->next = curr1;
                    curr1 = curr1->next;
                }
                else {
                    curr->next = curr2;
                    curr2 = curr2->next;
                }
            }
            curr = curr->next;
        }
        return dummy->next;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* curr1 = l1;
        ListNode* curr2 = l2;
        ListNode* dummy = new ListNode{0};
        ListNode* curr = dummy;

        int overten = 0;
        while (curr1 || curr2) {
            if (!curr1) {               // curr1为空
                int res = curr2->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr2 = curr2->next;
            }
            else if (!curr2) {          // curr2为空
                int res = curr1->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr1 = curr1->next;
            }
            else {                      // curr1和curr2非空
                int res = curr1->val + curr2->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr1 = curr1->next;
                curr2 = curr2->next;
            }
            curr = curr->next;
        }
        if (overten)
            curr->next = new ListNode{1};
        return dummy->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* left = head;              // 定位需要删除的节点
        ListNode* right = head;             // 用于终止left的移动
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;              // left的前一个节点
        pre->next = head;
        while (n > 0) {
            right = right->next;
            --n;
        }
        while (right) {
            pre = pre->next;
            left = left->next;
            right = right->next;
        }
        pre->next = left->next;
        return dummy->next;
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

本题需要注意的是，left和right每个循环要跳两步，所以处理和之前不同

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head)
            return nullptr;
        if (!head->next)
            return head;

        ListNode* left = head;
        ListNode* right = head->next;
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;
        pre->next = left;
        // 我们需要改变left->next，right->next和pre->next
        while (right) {
            // 反转left，right，更新pre
            left->next = right->next;
            right->next = left;
            pre->next = right;

            // 反转之后，left在右，right在左
            // 此时有两种情况：
            // 1. left是最后一个节点，此时 left->next == nullptr
            // 2. left是倒数第二个节点，此时 left->next != nullptr，但最后一个节点不反转
            // 本题需要注意的是，left和right每个循环要跳两步，所以处理和之前不同
            pre = left;
            left = left->next;
            if (left)
                right = left->next;
            else
                right = nullptr;
        }
        return dummy->next;
    }
};
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

重点是搞懂206题，其次reverse的设计可以将返回值设计成`pair<new_head, new_tail>`

```c++
class Solution {
public:
    // 将left指向pre
    ListNode* reverse(ListNode* start, ListNode* end) {
        ListNode* pre = nullptr;
        ListNode* left = start;
        ListNode* right = left->next;
        while (right != end->next) {
            left->next = pre;
            pre = left;
            left = right;
            right = right->next;
        }
        left->next = pre;
        return left;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;
        pre->next = head;

        ListNode* left = head;
        ListNode* right = head;
        ListNode* tmp = head;
        while (1) {
            int stride = k - 1;
            left = tmp;
            right = left;
            // 当元素足够，可以反转时，由stride==0触发，退出循环
            // 当元素不够，不可以反转时，由right==nullptr触发，退出循环
            while (right && stride > 0) {
                right = right->next;
                --stride;
            }
            if (!right) {
                pre->next = left;
                break;
            }
            tmp = right->next;

            // 经过以上步骤，需要反转的是 [left, right]
            pre->next = reverse(left, right);
            pre = left;
        }
        return dummy->next;
    }
};
```

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> umAddr{};   // <旧节点地址，新节点地址>
        Node* old_curr = head;
        // 注意赋值时需要给val和ramdom都赋值
        Node* dummy = new Node{0};
        dummy->random = nullptr;
        Node* new_curr = dummy;

        // 深拷贝val，random使用老节点的。
        while (old_curr) {
            // 注意赋值时需要给val和ramdom都赋值
            Node* new_node = new Node{old_curr->val};
            new_node->random = old_curr->random;
            
            umAddr.insert(make_pair(old_curr,new_node));

            old_curr = old_curr->next;
            new_curr->next = new_node;
            new_curr = new_curr->next;
        }

        // 更新新节点的random
        new_curr = dummy;
        while (new_curr) {
            auto it = umAddr.find(new_curr->random);
            if (it != umAddr.end()) {
                new_curr->random = it->second;
            }
            else {
                new_curr->random = nullptr;
            }
            new_curr = new_curr->next;
        }
        return dummy->next;
    }
};
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)？？？

归并排序

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)？？？

分治合并，优先队列

维护一个currs数组，其中存放着每个`lists[i]`的地址，我们可以从currs数组中找最小的那个val即可

当然这一过程也可以使用优先队列来优化

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        vector<ListNode*> currs(lists.size(), nullptr);
        for (int i = 0; i < lists.size(); i++) {
            currs[i] = lists[i];
        }
        ListNode* dummy = new ListNode{0};
        ListNode* curr_res = dummy;

        bool in_loop = true;
        int curr_null = 0;
        while (in_loop) {
            int min_val = INT32_MAX;
            ListNode* min_addr = nullptr;
            int min_idx = 0;
            // 每一个loop中，都要遍历currs数组中每一个元素，用于比较大小
            for (int i = 0; i < currs.size(); i++) {
                if (currs[i] == nullptr) {
                    // 视情况++
                    if (!us_curr_null_.count(i)) {
                        us_curr_null_.insert(i);
                        ++curr_null;
                        if (curr_null == lists.size()) {
                            in_loop = false;
                            break;
                        }
                    }
                    continue;
                }
                // 比较值
                if (currs[i]->val <= min_val) {
                    min_val = currs[i]->val;
                    min_addr = currs[i];
                    min_idx = i;
                }
            }
            // 更新res，更新currs
            // 当break出for循环时，min_addr为null
            if (min_addr) {
                curr_res->next = min_addr;
                curr_res = curr_res->next;
                currs[min_idx] = min_addr->next;
            }
        }
        return dummy->next;
    }
    unordered_set<int> us_curr_null_{};
};
```

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)？？？

哈希表+双链表，数据存在双链表中，双链表的头节点是刚刚使用过的，尾节点是很久没用的，哈希表`<key，链表地址>`

## 二叉树

### 二叉树总结

1. 核心思想：遍历方式决定一切

   解决任何二叉树问题的第一步，是**明确使用哪种遍历方式**。书中强调，这并非凭感觉，而是由问题本质决定的。

   1. **深度优先遍历 (DFS) - 递归实现**
      - **适用场景**：绝大多数二叉树问题。
      - **核心技巧：递归三部曲** (书中反复强调的方法论)
        1. **确定函数签名**：明确函数的参数和返回值。返回值可以是 void、bool、节点指针 TreeNode* 或计算结果 int。
        2. **确定终止条件**：通常是遇到空节点 (root == nullptr) 时返回。
        3. **确定单层递归逻辑**：根据**前序/中序/后序**的顺序，处理当前节点与左右子树的关系。
   2. **广度优先遍历 (BFS) - 队列实现**
      - **适用场景**：所有**逐层**处理的问题。
      - **核心技巧：层序遍历模板**
        - 使用 std::queue。
        - 外层 while (!q.empty()) 循环控制所有层的遍历。
        - 内层 for (int i = 0; i < q.size(); i++) 循环精确控制**当前层**的节点遍历。
      - **典型应用**：求最大/最小深度、找最左/右下角值、N叉树层序遍历等。

2. 题型分类与核心技巧

   书中将二叉树问题系统地分为以下几类，每类都有明确的解题范式：

   | 类别                         | 核心思路 & 推荐遍历方式          | 关键点 & 技巧                                                |
   | ---------------------------- | -------------------------------- | ------------------------------------------------------------ |
   | **1. 二叉树属性求解**        | **后序遍历 (左右中) + 分治思想** | **自底向上**传递信息。先处理左右子树，再根据左右子树的返回值计算当前节点的结果。适用于求**高度**、判断**平衡性/对称性**等。 |
   | **2. 二叉树修改与构造**      | **前序遍历 (中左右) + 分治思想** | **自顶向下**构建。先处理根节点，然后递归构建左右子树。适用于**翻转二叉树**、**从数组构造二叉树**等。 |
   | **3. 二叉搜索树 (BST) 操作** | **利用其有序性**                 | 1. **中序遍历**结果是一个**升序序列**，这是解决BST问题的“金钥匙”。<br>2. 操作时无需遍历整棵树，可像**二分查找**一样，根据当前节点值与目标值的比较结果，决定向左或向右递归。 |
   | **4. 路径问题**              | **前序遍历 (中左右) + 回溯**     | 寻找从根到叶子的路径时，在前序遍历的递归调用前后进行 path.push_back() 和 path.pop_back() 操作，实现路径的记录与撤销。 |
   | **5. 公共祖先 (LCA)**        | 根据树的类型选择不同策略         | 1. **普通二叉树**：使用**后序遍历**，通过左右子树的返回值判断。<br>2. **二叉搜索树**：利用有序性，从根节点开始判断目标节点 p 和 q 在当前节点的哪一侧。 |

3. 总结与建议

   - **递归 vs. 迭代**：书中强调，先用递归理清思路，因为它最符合树的结构。迭代（特别是统一风格的迭代法）是进阶技巧，用于加深理解和应对特定面试要求。
   - **画图**：理解递归和指针操作最有效的方式。
   - **回溯与递归的关系**：回溯是递归的一种体现。求路径问题时回溯的体现是显式的；求树的属性时，回溯体现在递归函数的返回过程中。
   - **不变量原则**：在处理需要切割数组来构造树的问题时，坚持**区间的定义**（如左闭右开或左闭右闭）能有效避免边界错误。

   **总而言之，解二叉树题目的王道就是：先判断题型，再根据题型选择最高效的遍历策略，并熟练运用递归三部曲或层序遍历模板。**

### 深度优先搜索DFS

要求使用递归/非递归的实现

#### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

非递归的前序遍历

注意这里涉及到一个处理顺序和访问顺序：

对于前序遍历，我们先访问的是中间节点，先处理的也是中间节点，所以我们可以用一个stack来同时表示二叉树的访问顺序和处理顺序

```c++
class Solution {
public:
    // 中-左-右
    vector<int> preorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        vector<int> res{};
        stack<TreeNode*> stack_node{};
        stack_node.push(root);

        while (!stack_node.empty()) {
            // 先处理中节点
            auto pnode = stack_node.top();
            stack_node.pop();
            res.push_back(pnode->val);
            // 先push右节点，再push左节点，因为pop的方向是反的
            // 注意空节点不要push进来
            if (pnode->right)
                stack_node.push(pnode->right);
            if (pnode->left)
                stack_node.push(pnode->left);
        }
        return res;
    }
};
```

#### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

非递归的后序遍历：

我们可以由非递归的前序遍历推导而来：

1. 首先前序遍历结果是：中-左-右；而后续遍历要求是左-右-中
2. 所以可以考虑先反转左右节点的入栈顺序
3. 然后再反转答案数组即可，这样我们在实际编码时，依然可以保证访问顺序和处理顺序的一致性

```c++
class Solution {
public:
    // 左-右-中
    vector<int> postorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        vector<int> res{};
        stack<TreeNode*> stack_node{};
        stack_node.push(root);

        while (!stack_node.empty()) {
            // 先处理中节点
            auto pnode = stack_node.top();
            stack_node.pop();
            res.push_back(pnode->val);
            // 先push左节点，再push右节点，这样pop的顺序是中-右-左
            // 注意空节点不要push进来
            if (pnode->left)
                stack_node.push(pnode->left);
            if (pnode->right)
                stack_node.push(pnode->right);
        }
        // 中-右-左，反转成 左-右-中
        return {res.rbegin(), res.rend()};
    }
};
```

#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

注意前序/后序遍历和中序遍历不一样，中序遍历需要一个curr指针来表示访问顺序，stack只负责处理顺序

```c++
class Solution {
public:
    // 前-中-右
    vector<int> inorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        TreeNode* curr = root;
        vector<int> res{};
        stack<TreeNode*> node_stack{};
        while (curr || !node_stack.empty()) {
            if (curr) {             // curr非空时放入左孩子
                node_stack.push(curr);
                curr = curr->left;          // 左
            }
            else {                  // curr为空时为树的最底层
                curr = node_stack.top();
                node_stack.pop();

                res.push_back(curr->val);  // 中
                curr = curr->right;         // 右
            }
        }
        return res;
    }
};
```

### 广度优先搜索BFS

[讲透二叉树的层序遍历 | 广度优先搜索 | LeetCode：102.二叉树的层序遍历_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1GY4y1u7b2?vd_source=62fe42e71e56edada3fb7d905bdcf92b&spm_id_from=333.788.videopod.sections)

#### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

本题应当使用队列来进行层序遍历，操作也很简单：

1. 初始时压入头节点
2. 循环时：
   1. 弹出队列首元素
   2. 将弹出元素的左右孩子压入队列
3. 需要一个 `len_curr_lv` 和 `len_next_lv` 来表示当前层的元素个数和下一层的元素个数

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root)
            return {};
        vector<vector<int>> res{};
        queue<TreeNode*> que_level{};

        que_level.push(root);
        int len_next_lv = 1;        // 当前我们在-1层，下一层是第0层，第0层有1个元素

        while (!que_level.empty()) {
            // 我们先处理第0层，站在第0层的视角：
            // 1. len_next_lv表示未更新前表示第-1层的下一层
            // 2. len_curr_lv表示当前层的元素个数
            // 3. len_next_lv更新后应当表示第一层的元素个数
            vector<int> vec_curr_lv{};
            int len_curr_lv = len_next_lv;
            len_next_lv = 0;

            while (len_curr_lv > 0) {
                // 先弹出当前层的元素
                TreeNode* node = que_level.front();
                que_level.pop();
                vec_curr_lv.push_back(node->val);
                --len_curr_lv;

                // 弹出一个元素，然后将它的左右孩子压入队列
                if (node->left) {
                    ++len_next_lv;
                    que_level.push(node->left);
                }
                if (node->right) {
                    ++len_next_lv;
                    que_level.push(node->right);
                }
            }
            res.push_back(vec_curr_lv);
        }
        return res;
    }
};

```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```c++
// 使用前序遍历
class Solution {
public:
    void traverse(TreeNode* node) {
        if (!node) {
            res_ = max(res_, depth_);
            ++depth_;   // 只要有访问，就需要加一个深度
            return;
        }
        // 中（需要注意中间节点也是某个节点的左/右孩子）
        ++depth_;
        // 左
        traverse(node->left);
        --depth_;   // 访问完左孩子之后，需要减去左孩子的深度
        // 右
        traverse(node->right);
        --depth_;   // 右孩子同上
    }

    int maxDepth(TreeNode* root) {
        traverse(root);
        return res_;
    }
    int depth_ = 0;
    int res_ = 0;
};
```

### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```c++
// 使用后序遍历：
// 先翻转左子树，再翻转右子树，最后翻转中节点的左右孩子
class Solution {
public:
    void invert(TreeNode* node) {
        if (!node)
            return;
        invert(node->left);
        invert(node->right);
        swap(node->left, node->right);
    }

    TreeNode* invertTree(TreeNode* root) {
        invert(root);
        return root;
    }
};
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

1. 递归法需要两个指针，一个指针（中->左->右）遍历根节点的左子树，一个指针（中->右->左）遍历根节点的右子树，两者同步进行
2. 迭代法使用层序遍历秒解

```c++
class Solution {
public:
    bool check_if_symmetric(const vector<int>& vec_curr_lv) {
        int left = 0;
        int right = vec_curr_lv.size() - 1;
        while (left < right) {
            if (vec_curr_lv[left] != vec_curr_lv[right])
                return false;
            ++left;
            --right;
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> queue_level{};
        queue_level.push(root);
        int len_next_lv = 1;

        while (!queue_level.empty()) {
            int len_curr_lv = len_next_lv;
            len_next_lv = 0;
            vector<int> vec_curr_lv{};

            while (len_curr_lv--) {
                TreeNode* node = queue_level.front();
                queue_level.pop();
                vec_curr_lv.push_back( (node ? node->val : -1) );

                if (node) {
                    queue_level.push(node->left);
                    queue_level.push(node->right);
                    len_next_lv += 2;
                }
            }
            if (!check_if_symmetric(vec_curr_lv)) {
                return false;
            }
        }
        return true;
    }
};
```

### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

```c++
// 后序遍历
// 两节点之间路径的 长度 由它们之间边数表示。
// 也就是说，一条路径的长度为该路径经过的节点数减一
// 求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。
class Solution {
public:
    int traverse(TreeNode* node) {
        if (!node) {
            return 0;
        }
        // 左（该值表示左子树的深度，也就是左子树最深有多少个节点）
        int left_depth = traverse(node->left);
        // 右
        int right_depth = traverse(node->right);
        // 中
        int diameter = (left_depth + right_depth + 1) - 1;
        res_ = max(diameter, res_);
        return max(left_depth, right_depth) + 1;
    }

    int diameterOfBinaryTree(TreeNode* root) {
        traverse(root);
        return res_;
    }
    //int diameter_ = 0;
    int res_;
};
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```c++
// 前序遍历
class Solution {
public:
    TreeNode* traverse(int left, int right) {
        if (left > right) {
            return nullptr;
        }
        // 中
        int mid = (left + right) / 2;
        TreeNode* node = new TreeNode{nums_[mid]};
        // 左
        node->left = traverse(left, mid - 1);
        // 右
        node->right = traverse(mid + 1, right);
        return node;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if (nums.empty())
            return nullptr;
        nums_ = nums;
        TreeNode* head = traverse(0, nums_.size() - 1);
        return head;
    }
    vector<int> nums_;
};
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

二叉搜索树在中序遍历时严格递增

```c++
// 中序遍历
class Solution {
public:
    void traverse(TreeNode* node) {
        if (!node) {
            return;
        }
        
        traverse(node->left);
        if (pre_ >= node->val) {
            res_ = false;
        }
        pre_ = node->val;
        traverse(node->right);
    }

    bool isValidBST(TreeNode* root) {
        traverse(root);
        return res_;
    }
    long long pre_ = INT64_MIN;
    bool res_ = true;
};
```

### [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

```c++
// 中序遍历
class Solution {
public:
    void traverse(TreeNode* node) {
        if (!node) {
            return;
        }
        traverse(node->left);
        ++currk_;
        if (currk_ == k_) {
            val_ = node->val;
            return;
        }
        traverse(node->right);
    }
    
    int kthSmallest(TreeNode* root, int k) {
        k_ = k;
        traverse(root);
        return val_;
    }
    int val_ = 0;
    int currk_ = 0;
    int k_ = 0;
};
```

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

1. `begin_end` 表示前序遍历当前节点的左/右子树时的第一个以及最后一个元素。

```c++
// 后序遍历
class Solution {
public:
    void traverse(TreeNode* node, pair<TreeNode*, TreeNode*>& begin_end) {
        if (!node) {
            begin_end = {nullptr, nullptr};
            return;
        }
        // 左
        pair<TreeNode*, TreeNode*> left_begin_end{};
        traverse(node->left, left_begin_end);
        // 右
        pair<TreeNode*, TreeNode*> right_begin_end{};
        traverse(node->right, right_begin_end);
        // 中
        // 1. 前序遍历的第一个节点肯定时自己
        begin_end.first = node;
        // 2. 如果右子树不为空，那么当前节点的树中
        // 最后一个访问到的时右子树的最右边的节点
        if (right_begin_end.second) {
            begin_end.second = right_begin_end.second;
        }
        else if (left_begin_end.second) {
            begin_end.second = left_begin_end.second;
        }
        else {
            begin_end.second = node;
        }

        // 3. 更新完begin_end，随后更新node
        // 我们做两步骤：
        //   1. 更新左子树的位置
        //   2. 更新右子树的位置
        node->left = nullptr;
        node->right = left_begin_end.first;
        if (node->right) {
            left_begin_end.second->right = right_begin_end.first;
        }
        else {
            node->right = right_begin_end.first;
        }
    }
    void flatten(TreeNode* root) {
        pair<TreeNode*, TreeNode*> begin_end;
        traverse(root, begin_end);
    }
};
```

方法二采用类前序遍历法，我们从上往下慢慢修改每个节点的左右子树

```c++
// 前序遍历
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* curr = root;
        while (curr) {
            if (curr->left) {
                auto l_begin = curr->left;
                auto r_tmp = curr->right;
                auto curr_tmp = l_begin;
                while (curr_tmp->right) {
                    curr_tmp = curr_tmp->right;
                }
                auto l_end = curr_tmp;
                curr->left = nullptr;
                curr->right = l_begin;
                l_end->right = r_tmp;
            }
            curr = curr->right;
        }
    }
};
```

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```c++
// 前序遍历
class Solution {
public:
    int find_root(int curr_root) {
        for (int i = 0; i < inorder_.size(); i++) {
            if (inorder_[i] == curr_root)
                return i;
        }
        return 0;
    }

    TreeNode* dfs(int left, int right, int root_idx) {
        // 此种情况表示当前树为空
        if (left > right) {
            return nullptr;
        }
        // 中
        int curr_root = preorder_[root_idx];
        TreeNode* node = new TreeNode{curr_root};
        int idx = find_root(curr_root);
        // 左子树的根节点位置（可能无效）
        int left_cnt = idx - left;
        int left_root = root_idx + 1;
		// 右子树的根节点位置（可能无效）
        int right_cnt = right - idx;
        int right_root = root_idx + left_cnt + 1;

        node->left = dfs(left, idx - 1, left_root);
        node->right = dfs(idx + 1, right, right_root);

        return node;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty())
            return nullptr;

        // left表示inorder中 当前树的最左边的元素
        // right表示inorder中 当前树的最右边的元素
        // root_idx表示preorder中，当前树的根节点下标
        int left = 0, right = inorder.size() - 1;
        int root_idx = 0;
        preorder_ = preorder;
        inorder_ = inorder;
        TreeNode* root = dfs(left, right, root_idx);
        return root;
    }
    vector<int> preorder_;
    vector<int> inorder_;
};
```

### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)？？？

前缀和

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)？？？

```c++
// 前序遍历
class Solution {
public:
    void dfs(TreeNode* node) {
        if (!node) {
            path_p_.push_back(nullptr);
            path_q_.push_back(nullptr);
            return;
        }
        if (!find_p_) {
            path_p_.push_back(node);
            if (node == p_) {
                find_p_ = true;
                cout << "find p" << node->val << endl;
            }
        }
        if (!find_q_) {
            path_q_.push_back(node);
            if (node == q_) {
                find_q_ = true;
                cout << "find q" << node->val << endl;
            }
                
        }
        
        dfs(node->left);
        if (!find_p_) {
            int new_size = path_p_.empty() ? 0 : path_p_.size() - 1;
            path_p_.resize(new_size);
        }
        if (!find_q_) {
            int new_size = path_q_.empty() ? 0 : path_q_.size() - 1;
            path_q_.resize(new_size);
        }
        
        dfs(node->right);
        if (!find_p_) {
            int new_size = path_p_.empty() ? 0 : path_p_.size() - 1;
            path_p_.resize(new_size);
        }
        if (!find_q_) {
            int new_size = path_q_.empty() ? 0 : path_q_.size() - 1;
            path_q_.resize(new_size);
        }
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        p_ = p;
        q_ = q;
        dfs(root);
        int pre = 0;
        cout << "p size " << path_p_.size() << " " << "q size " << path_q_.size() << endl;
        int size = min(path_p_.size(), path_q_.size());
        for (int i = 1; i < size; i++) {
            if (path_p_[i] != path_q_[i])
                break;
            ++pre;
        }
        return path_p_[pre];
    }
    vector<TreeNode*> path_p_{};
    bool find_p_ = false;
    TreeNode* p_;

    vector<TreeNode*> path_q_{};
    bool find_q_ = false;
    TreeNode* q_;
};
```

## 回溯

### 回溯总结

好的，结合你的刷题笔记和这份《代码随想录》关于回溯的总结，我为你提炼出关于**回溯算法**最核心、最精炼的解题思想与技巧。

一、 回溯的本质：有约束的穷举

回溯算法的本质就是一种**有组织的穷举（暴力搜索）**。它通过**深度优先遍历（DFS）** 的方式，系统地探索问题的所有可能解。

*   **核心思想**：像在一棵树（解空间树）上进行探索，从根节点出发，一个选择接一个选择地深入，当发现当前路径不满足条件或者已经走到了终点时，就**退回一步（回溯）**，尝试其他的选择。
*   **适用场景**：《代码随想录》中总结得非常经典：
    *   **组合问题**：`N`个数中按规则找`k`个数。
    *   **切割问题**：字符串按规则切割。
    *   **子集问题**：一个集合的所有符合条件的子集。
    *   **排列问题**：`N`个数的全排列。
    *   **棋盘问题**：N皇后、解数独等。

---

二、 回溯解题的核心模板 (回溯三部曲)

这是解决所有回溯问题的“金钥匙”，你的笔记和《代码随想录》都贯穿了这一思想。任何回溯问题都可以套用这个框架来思考和编码。

```cpp
void backtracking(参数) {
    // 1. 确定递归终止条件
    if (终止条件) {
        存放结果;
        return;
    }

    // 2. 遍历当前层的所有可能选择
    for (选择: 本层集合中的元素) {
        // 处理节点 (做出选择)
        path.push_back(当前选择);

        // 递归：进入下一层决策
        backtracking(路径, 下一层的选择列表);

        // 回溯：撤销处理结果 (撤销选择)
        path.pop_back();
    }
}
```

**三部曲详解**：

1.  **递归函数签名 (参数和返回值)**
    *   **返回值**：通常是 `void`，因为结果是通过全局变量或引用参数来收集的。
    *   **参数**：除了题目给定的数据外，最关键的是需要一个变量来记录**当前路径 (`path`)** 和一个变量来控制**搜索范围 (`startIndex`)**。

2.  **终止条件**
    *   这是递归的出口。通常是当路径的长度满足题目要求（如组合问题中 `path.size() == k`）或者搜索已经完成时。
    *   在终止时，记得将当前有效的 `path` 存入最终结果集。

3.  **单层搜索逻辑 (for循环)**
    *   这是回溯的核心。循环遍历当前层级所有**合法**的选择。
    *   **“处理节点”**：将当前选择加入 `path`。
    *   **“递归”**：带着更新后的 `path` 和新的搜索范围进入下一层。
    *   **“回溯”**：递归返回后，将刚刚加入 `path` 的选择**撤销**，以便`for`循环继续尝试其他选择。**`push_back` 和 `pop_back` 永远成对出现**。

---

三、 核心技巧与关键区别

1. 如何去重？—— “树层去重” 与 “树枝去重”

这是组合/子集/排列问题中输入包含重复元素时的关键。
*   **前提**：**先对输入数组排序**。
*   **树层去重** (常用)：保证在**同一层**中，不选择之前已经用过的相同数字。
    *   **代码**：`if (i > startIndex && nums[i] == nums[i-1]) continue;`
    *   **目的**：解决**组合问题**和**子集问题**的去重。
*   **树枝去重**：保证在**同一条路径**上，一个元素（或一个位置的元素）只使用一次。
    *   **工具**：使用一个 `used` 数组来标记。
    *   **目的**：解决**排列问题**的去重。

---

2. 组合、子集、排列的关键区别

| 问题类型                  | `for`循环起点   | 是否可重复 | 关键点                                                       |
| :------------------------ | :-------------- | :--------- | :----------------------------------------------------------- |
| **组合**                  | `startIndex`    | 否         | `startIndex` 保证元素不重复选取。                            |
| **子集**                  | `startIndex`    | 否         | 收集**所有节点**的结果，而组合只收集叶子节点。               |
| **排列**                  | `0`             | 否         | 每次都从头开始选，用`used`数组避免在同一路径上重复使用元素。 |
| **组合总和** (元素可重复) | `i` (而非`i+1`) | 是         | 递归时传入`i`而不是`i+1`，允许下一层继续选择当前元素。       |

---

3. 剪枝 (Pruning)

剪枝是回溯算法的优化手段，通过提前判断，砍掉不可能产生有效解的树枝，从而减少搜索空间。
*   **常见剪枝**：在求和问题中，如果当前 `sum` 已经大于 `target`，后续的搜索就没有意义了，可以直接 `return` 或在 `for` 循环中 `break`。

---

总结

回溯算法的解题过程高度**模板化**。当你识别出一个问题可以用回溯解决时，应该立刻在脑海中构建出那棵**抽象的树形结构**，然后遵循“回溯三部曲”的框架：

1.  **定义函数签名**：想清楚需要传递哪些状态（如 `path`, `startIndex`）。
2.  **设置终止条件**：明确在树的哪个位置（通常是叶子节点）收集结果。
3.  **书写单层逻辑**：用`for`循环进行横向遍历，用递归进行纵向深入，并牢记在递归调用之后进行**回溯**操作。

只要掌握了这个核心模板，并理解了组合、排列、子集在`startIndex`和去重逻辑上的细微差别，就能系统性地解决绝大部分回溯问题。

### [77. 组合[代码随想录]](https://leetcode.cn/problems/combinations/)

```c++
class Solution {
public:
    void backtracking(vector<int>& path,int startIdx, int deepth) {
        if (deepth > k_) {
            res_.push_back(path);
            return;
        }

        for (int i = startIdx; i <= n_; i++) {
            path.push_back(i);
            backtracking(path, i+1, deepth+1);
            path.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        n_ = n;
        k_ = k;
        vector<int> path;
        backtracking(path, 1, 1);
        return res_;
    }
    int n_;
    int k_;
    vector<vector<int>> res_{};
};
```

### [216. 组合总和 III[代码随想录]](https://leetcode.cn/problems/combination-sum-iii/)

```c++
class Solution {
public:
    void backtracking(vector<int>& path, int startIdx, int depth) {
        if (depth > k_) {
            if (sum_ == n_) {
                res_.push_back(path);
            }
            return;
        }
        if (sum_ >= n_)
            return;
        for (int i = startIdx; i <= 9; i++) {
            sum_ += i;
            path.push_back(i);

            backtracking(path, i + 1, depth + 1);

            sum_ -= i;
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        k_ = k;
        n_ = n;
        vector<int> path;
        backtracking(path, 1, 1);
        return res_;
    }
    vector<vector<int>> res_{};
    int n_;
    int k_;
    int sum_ = 0;
};
```

### [17. 电话号码的字母组合[代码随想录]](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```c++
class Solution {
public:
    void backtracking(string& path, int startIdx, int depth) {
        if (depth > targetDepth) {
            res_.push_back(path);
            return;
        }
        string& curr_lv_num = char_to_num.at(digits_[startIdx]);
        for (int i = 0; i < curr_lv_num.size(); i++) {
            path.push_back(curr_lv_num[i]);
            backtracking(path, startIdx + 1, depth + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.empty())
            return {};
        digits_ = digits;
        targetDepth = digits.size();
        string path{};
        backtracking(path, 0, 1);
        return res_;
    }
    int targetDepth;
    string digits_;
    vector<string> res_;
    map<char, string> char_to_num{
        {'2', "abc"},
        {'3', "def"},
        {'4', "ghi"},
        {'5', "jkl"},
        {'6', "mno"},
        {'7', "pqrs"},
        {'8', "tuv"},
        {'9', "wxyz"}
    };
};
```

### [46. 全排列](https://leetcode.cn/problems/permutations/)

```c++
class Solution {
public:
    void backtracking(vector<int>& path, int depth) {
        if (depth > targetDepth_) {
            res_.push_back(path);
            return;
        }

        for (auto& e : is_num_used_) {
            if (!e.second) {
                e.second = true;
                path.push_back(e.first);
                backtracking(path, depth + 1);
                e.second = false;
                path.pop_back();
            }
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        for (int& e : nums) {
            is_num_used_.insert(make_pair(e, false));
        }
        targetDepth_ = nums.size();
        vector<int> path{};
        backtracking(path, 1);
        return res_;
    }
    int targetDepth_;
    vector<vector<int>> res_{};
    unordered_map<int, bool> is_num_used_{};
};
```

### [78. 子集](https://leetcode.cn/problems/subsets/)

```c++
class Solution {
public:
    void backtracking(vector<int>& path, int startIdx, int depth) {
        if (depth > targetDepth_)
            return;

        for (int i = startIdx; i < nums_.size(); i++) {
            path.push_back(nums_[i]);
            res_.push_back(path);
            backtracking(path, i + 1, depth + 1);
            path.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        targetDepth_ = nums.size();
        nums_ = nums;
        vector<int> path{};
        res_.push_back({});
        backtracking(path, 0, 1);
        return res_;
    }
    int targetDepth_;
    vector<vector<int>> res_;
    vector<int> nums_;
};

```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```c++
class Solution {
public:
    void backtracking(string& path, int startIdx, int depth) {
        if (depth > targetDepth) {
            res_.push_back(path);
            return;
        }
        string& curr_lv_num = char_to_num.at(digits_[startIdx]);
        for (int i = 0; i < curr_lv_num.size(); i++) {
            path.push_back(curr_lv_num[i]);
            backtracking(path, startIdx + 1, depth + 1);
            path.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.empty())
            return {};
        digits_ = digits;
        targetDepth = digits.size();
        string path{};
        backtracking(path, 0, 1);
        return res_;
    }
    int targetDepth;
    string digits_;
    vector<string> res_;
    map<char, string> char_to_num{
        {'2', "abc"},
        {'3', "def"},
        {'4', "ghi"},
        {'5', "jkl"},
        {'6', "mno"},
        {'7', "pqrs"},
        {'8', "tuv"},
        {'9', "wxyz"}
    };
};
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

```c++
class Solution {
public:
    void backtracking(vector<int>& path, int startIdx) {
        if (currsum_ > target_)
            return;
        if (currsum_ == target_) {
            res_.push_back(path);
            return;
        }

        for (int i = startIdx; i < candidates_.size(); i++) {
            path.push_back(candidates_[i]);
            currsum_ += candidates_[i];
            backtracking(path, i);
            path.pop_back();
            currsum_ -= candidates_[i];
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        target_ = target;
        candidates_ = candidates;
        vector<int> path{};
        backtracking(path, 0);
        return res_;
    }
    vector<int> candidates_;
    int target_;
    vector<vector<int>> res_;
    int currsum_ = 0;
};
```

### [22. 括号生成？？？](https://leetcode.cn/problems/generate-parentheses/)

```c++
// 本题其实是一个二叉树，每个父节点的孩子要么是'('，要么是')'
class Solution {
public:
    void backtracking(string& path, int left_bracket, int right_bracket) {
        if (path.size() == 2 * n_) {
            res_.push_back(path);
            return;
        }

        if (left_bracket < n_) {
            path.push_back('(');
            backtracking(path, left_bracket + 1, right_bracket);
            path.pop_back();
        }
        if (right_bracket < left_bracket) {
            path.push_back(')');
            backtracking(path, left_bracket, right_bracket + 1);
            path.pop_back();
        }
    }

    vector<string> generateParenthesis(int n) {
        n_ = n;
        string path{};
        int left_bracket = 0;
        int right_bracket = 0;
        backtracking(path, left_bracket, right_bracket);
        return res_;
    }
    int n_;
    vector<string> res_{};
};
```

### [79. 单词搜索？？？](https://leetcode.cn/problems/word-search/)

```c++
class Solution {
public:
    void backtracking(string& path, int i, int j, int depth) {
        if (depth == targetDepth_) {
            path.push_back(board_[i][j]);
            hasIdx_[i * 10 + j] = true;
            if (path == word_)
                res_ = true;
            return;
        }
        path.push_back(board_[i][j]);
        hasIdx_[i * 10 + j] = true;
        if (1) {
            int sub_i = i - 1, sub_j = j;
            if (sub_i >= 0 && !hasIdx_[sub_i * 10 + sub_j]) {
                backtracking(path, sub_i, sub_j, depth + 1);
                path.pop_back();
                hasIdx_[sub_i * 10 + sub_j] = false;
            }
        }
        if (1) {
            int sub_i = i + 1, sub_j = j;
            if (sub_i < height_ && !hasIdx_[sub_i * 10 + sub_j]) {
                backtracking(path, sub_i, sub_j, depth + 1);
                path.pop_back();
                hasIdx_[sub_i * 10 + sub_j] = false;
            }
        }
        if (1) {
            int sub_i = i, sub_j = j - 1;
            if (sub_j >= 0 && !hasIdx_[sub_i * 10 + sub_j]) {
                backtracking(path, sub_i, sub_j, depth + 1);
                path.pop_back();
                hasIdx_[sub_i * 10 + sub_j] = false;
            }
        }
        if (1) {
            int sub_i = i, sub_j = j + 1;
            if (sub_j < width_ && !hasIdx_[sub_i * 10 + sub_j]) {
                backtracking(path, sub_i, sub_j, depth + 1);
                path.pop_back();
                hasIdx_[sub_i * 10 + sub_j] = false;
            }
        }
    }

    bool exist(vector<vector<char>>& board, string word) {
        if (board.empty() || word.empty())
            return true;
        board_ = board;
        word_ = word;
        targetDepth_ = word.size();
        width_ = board[0].size();
        height_ = board.size();

        char target = word_[0];
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                hasIdx_.insert(make_pair(i * 10 + j, false));
                if (board[i][j] == target) {
                    startIdx_.emplace_back(i, j);
                }
            }
        }

        for (int i = 0; i < startIdx_.size(); i++) {
            if (!res_) {
                string path{};
                backtracking(path, startIdx_[i].first, startIdx_[i].second,
                    1);
                hasIdx_[startIdx_[i].first * 10 + startIdx_[i].second] = false;
            }
        }
        return res_;
    }

    string word_;
    int targetDepth_;
    vector<vector<char>> board_;
    vector<pair<int, int>> startIdx_;   // i，j 坐标
    int width_;
    int height_;
    bool res_ = false;
    unordered_map<int, bool> hasIdx_{};
};
```

### [131. 分割回文串???](https://leetcode.cn/problems/palindrome-partitioning/)

[带你学透回溯算法-分割回文串（对应力扣题目：131.分割回文串）| 回溯法精讲！](https://www.bilibili.com/video/BV1c54y1e7k6/?share_source=copy_web&vd_source=54c100b5cef5d27f46b1b7de9dcaa4de)

```c++
class Solution {
public:
    // 判断是否是回文串
    bool isPalindrome(int left, int right) {
        while (left < right) {
            if (s_[left] != s_[right])
                return false;
            ++left;
            --right;
        }
        return true;
    }
    // 判断path是否满足push条件
    bool pathNotFull(vector<string>& path) {
        int sum = 0;
        for (int i = 0; i < path.size(); i++) {
            sum += path[i].size();
        }
        if (sum != s_.size())
            return true;
        return false;
    }
    // path表示一次遍历中s_中的所有回文串，startIdx表示当前层中开始下标
    void backtracking(vector<string>& path, int startIdx) {
        if (startIdx >= s_.size()) {
            if (path.empty() || pathNotFull(path)) {
                return;
            }
            res_.push_back(path);
            return;
        }
        for (int i = startIdx; i < s_.size(); i++) {
            bool tmp = isPalindrome(startIdx, i);
            if (tmp) {
                path.emplace_back(s_.begin() + startIdx, s_.begin() + i + 1);
            }
            backtracking(path, i + 1);
            if (tmp) {
                path.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        s_.swap(s);
        vector<string> path{};
        backtracking(path, 0);
        return res_;
    }
    string s_;
    vector<vector<string>> res_{};
};
```

## 二分查找

### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int idx = 0;
        while (left <= right) {
            idx = (left + right) / 2;
            if (nums[idx] == target)
                return idx;
            else if (nums[idx] < target) {
                left = idx + 1;
            }
            else if (nums[idx] > target) {
                right = idx - 1;
            }
        }
        if (nums[idx] > target)
            return idx;
        return idx + 1;
    }
};
```

### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。

代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty())
            return false;
        rowCnt_ = matrix.size();
        colCnt_ = matrix[0].size();
        int left = 0;
        int right = matrix.size() * matrix[0].size() - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            int row = mid / colCnt_;
            int col = mid % colCnt_;
            if (matrix[row][col] == target) {
                return true;
            }
            else if (matrix[row][col] < target) {
                left = mid + 1;
            }
            else if (matrix[row][col] > target) {
                right = mid - 1;
            }
        }
        return false;
    }
    int rowCnt_;
    int colCnt_;
};
```

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int idx = -1;
        while (left <= right) {
            int mid = (right - left) / 2 + left;
            if (nums[mid] == target) {
                idx = mid;
                break;
            }
            else if (nums[mid] > target) {
                right = mid - 1;
            }
            else if (nums[mid] < target) {
                left = mid + 1;
            }
        }
        if (idx == -1) {
            return {-1, -1};
        }
        left = idx;
        right = idx;
        int lres = idx, rres = idx;
        while ( 1 ) {
            --left;
            ++right;
            if ( left >= 0 && nums[left] == target)
                lres = left;
            if ( (right < nums.size()) && nums[right] == target)
                rres = right;

            if (left < 0 && right >= nums.size())
                break;
        }
        return {lres, rres};
    }
};
```

### [33. 搜索旋转排序数组！！！](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

定理一：**每次二分都会至少存在一个顺序区间**。

定理二：只有在顺序区间内才可以通过区间两端的数值判断target是否在其中。

定理三：判断顺序区间还是乱序区间，只需要对比 left 和 right 是否是顺序对即可，left <= right，顺序区间，否则乱序区间。

通过不断的用Mid二分，根据定理二，将整个数组划分成顺序区间和乱序区间，然后利用定理一判断target是否在顺序区间，如果在顺序区间，下次循环就直接取顺序区间，如果不在，那么下次循环就取乱序区间。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            // left -> mid 是顺序区间
            if (nums[left] <= nums[mid]) {
                // 只判断target在顺序区间内的情况，其余情况到时候再说。注意 <= 符号
                if (nums[left] <= target && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            // mid -> right 是顺序区间
            else {
                // 同上
                if (nums[mid] < target && target <= nums[right])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
};
```

### [153. 寻找旋转排序数组中的最小值！！！](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

同上一题，这一次，我们需要重点关注乱序区间

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        if (nums.size() == 1)
            return nums[0];
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            if (left == right)
                return nums[left];
            int mid = (left + right) / 2;			// mid是向下取整
            //cout << left << " " << mid << " " << right << endl;

            if (nums[mid] > nums[right]) {     		// #1
                left = mid + 1;
            }
            else if (nums[mid] <= nums[right]) {
                if (nums[left] > nums[mid]){		// #2
                    right = mid;
                }
                else if (nums[left] <= nums[mid]){	// #3
                    return nums[left];
                }
            }
        }
        return -10000;
    }
};
```

解释：

1. 对于 `#1` 而言：

   区间 `[mid, right]` 中的值一定**先递减后递增**

2. 对于 `#2` 而言：

   区间 `[mid, right]` 中的值一定**递增**

   区间 `[left, mid]` 可能**递减**，也可能**先递减后递增**（所以此时`right = mid`，因为可能`nums[mid]`是最小值）

3. 对于 `#3` 而言：

   区间 `[mid, right]` 中的值一定**递增**

   区间 `[left, mid]` 中的值一定**递增**，此时left就是最小值。

### [4. 寻找两个正序数组的中位数？？？](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

## 栈

### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk{};
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(' || s[i] == '{' || s[i] == '[')
                stk.push(s[i]);
            else if (s[i] == ')') {
                if (stk.empty())
                    return false;
                char c = stk.top();
                if (c == '(')
                    stk.pop();
                else
                    return false;
            }
            else if (s[i] == '}') {
                if (stk.empty())
                    return false;
                char c = stk.top();
                if (c == '{')
                    stk.pop();
                else
                    return false;
            }
            else if (s[i] == ']') {
                if (stk.empty())
                    return false;
                char c = stk.top();
                if (c == '[')
                    stk.pop();
                else
                    return false;
            }
        }
        if (stk.empty())
            return true;
        return false;
    }
};
```

### [155. 最小栈！！！](https://leetcode.cn/problems/min-stack/)

本题重点理清栈的性质：

如果stk的push的顺序是a，b，c；那么在b，c被pop出来之前，a一定存在。也就是**先进后出**

```c++
入栈 3 
|   |    |   |
|   |    |   |
|_3_|    |_3_|
stack  minStack

入栈 5 ， 5 大于 minStack 栈顶，不处理
|   |    |   |
| 5 |    |   |
|_3_|    |_3_|
stack  minStack

入栈 2 ，此时右边的 minStack 栈顶就保存了当前最小值 2 
| 2 |    |   |
| 5 |    | 2 |
|_3_|    |_3_|
stack  minStack

出栈 2，此时右边的 minStack 栈顶就保存了当前最小值 3
|   |    |   |
| 5 |    |   |
|_3_|    |_3_|
stack  minStack

出栈 5，右边 minStack 不处理
|   |    |   |
|   |    |   |
|_3_|    |_3_|
stack  minStack

出栈 3
|   |    |   |
|   |    |   |
|_ _|    |_ _|
stack  minStack

作者：windliang
链接：https://leetcode.cn/problems/min-stack/solutions/42521/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```c++
class MinStack {
public:
    MinStack() {
        min_stk_.push(INT_MAX);
    }

    void push(int val) {
        stk_.push(val);
        if (val <= min_stk_.top())
            min_stk_.push(val);
    }

    void pop() {
        int val = stk_.top();
        if (val == min_stk_.top())
            min_stk_.pop();
        stk_.pop();
    }

    int top() {
        return stk_.top();
    }

    int getMin() {
        return min_stk_.top();
    }
    stack<int> stk_{};
    stack<int> min_stk_{};
};
```

### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

https://leetcode.cn/problems/decode-string/solutions/6274/ti-jie-czhan-by-youlookdeliciousc

