[分享｜不同层次的面试算法学习规划 - 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3142247/mian-shi-xiang-de-xue-xi-gui-hua-by-shaw-548u/)

### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap{};
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int expect = target - nums[i];
            const auto& e = umap.find(expect);
            if (e == umap.end()) {  // 没找到
                umap.insert(make_pair(nums[i], i));
            }else {                 // 找到
                res.push_back(i);
                res.push_back(e->second);
                return res;
            }
        }
        return res;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)???

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty())
            return vector<vector<int>>{};
        sort(intervals.begin(), intervals.end());	// 1. 先排序（最重要）
        vector<vector<int>> res{};
        vector<int> merge(intervals[0]);
        for (vector<int>& vec : intervals) {
            if (merge[1] >= vec[0])					// 2. 排序之后，只要左区间最大的比右区间最小的值大，就说明重叠
                merge[1] = max(merge[1], vec[1]);
            else {									// 3. 否则说明合并结束
                res.push_back(merge);
                merge = vec;
            }
        }
        res.push_back(merge);
        return res;
    }
};
```

#### 总结：sort函数的使用时机

- 处理区间问题 (Interval Problems)

  这是最常见的使用场景之一，也是你提到的 **“合并区间” (Merge Intervals, 笔记第140页)** 问题的核心解法。

  - **原因**: 对区间按起点排序后，我们就可以按顺序线性扫描，只需考虑当前区间与前一个合并后的区间的关系。如果不排序，我们就需要比较任意两个区间，逻辑会变得异常复杂。
  - **笔记中的例子**:
    - **56. 合并区间**: 按区间起点排序，然后依次合并。
    - **452. 用最少数量的箭引爆气球** (第136页): 按区间起点或终点排序，然后贪心地确定箭的位置。
    - **435. 无重叠区间** (第137页): 按区间终点排序，然后贪心地选择不重叠的区间。

- 启用“双指针”或“二分查找”技巧

  当需要在一个数组中寻找两个或多个满足特定和（sum）条件的元素时，排序是启用高效算法的前提。

  - **原因**: 在一个无序数组中寻找两数之和为target，通常需要O(n²)的暴力搜索或借助O(n)空间复杂度的哈希表。但如果数组有序，就可以使用双指针从两端向中间扫描，在O(n)的时间复杂度和O(1)的空间复杂度内解决问题。
  - **笔记中的例子**:
    - **15. 三数之和** (第31页): 笔记中明确提到“考虑到本题不需要返回数组下标，所以我们可以直接对这个数组进行排序，排序之后时间复杂度有效下降。” 排序后，固定一个数，再用双指针寻找另外两个数。
    - **18. 四数之和** (第32页): 与“三数之和”同理，排序是使用双指针解法的基础。

- 方便去重 (Handling Duplicates)

  在求解组合、子集、排列等问题时，如果输入数组含有重复元素，而输出要求不能有重复的组合，排序是最高效的去重前置步骤。

  - **原因**: 排序后，所有相同的元素会聚集在一起。这样在进行深度优先搜索（回溯）时，我们就可以通过一个简单的判断（例如 if (i > 0 && nums[i] == nums[i-1])）来跳过由重复元素产生的相同分支，从而避免结果重复。
  - **笔记中的例子**:
    - **40. 组合总和 II** (第109页): 笔记中提到这是“树层去重”，排序是实现这种去重逻辑的关键。
    - **90. 子集 II** (第115页): 同理，先排序，再通过判断来跳过重复的元素。
    - **47. 全排列 II** (第119页): 同样先排序，以方便在回溯过程中识别和跳过重复的排列。

- 运用贪心算法 (Greedy Algorithms)

  很多贪心算法的正确性依赖于一个前提：总是对当前“最好”或“最优”的元素做选择。排序可以帮助我们快速定位到这个“最优”元素。

  - **原因**: 通过排序，我们可以将问题转化为每次都从剩余元素中选择最大/最小，或者最先开始/结束的项。
  - **笔记中的例子**:
    - **455. 分发饼干** (第121页): 将孩子的胃口和饼干的尺寸都排序，然后用最小的饼干去满足胃口最小的孩子，这就是一个经典的贪心策略。
    - **406. 根据身高重建队列** (第135页): 笔记中提到“遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。” 这里通过先按身高降序、再按k值升序的排序规则，使得每次插入一个人时，都能保证其插入位置的正确性。

- 创建“范式”或“唯一标识”

  当需要对某些内容进行分类或分组，而这些内容有多种表现形式时（例如字母异位词），可以通过排序创造一个唯一的、标准化的“范式”（Canonical Form）作为它们的标识。

  - **笔记中的例子**:
    - **49. 字母异位词分组** (第23页): 笔记提到“可以通过sort排序将异位词变成一样的就好了”。例如，"eat", "tea", "ate" 排序后都变成了 "aet"，可以把 "aet" 作为键，将它们分到同一组。

- 总结

  总的来说，当你遇到以下情况时，可以优先考虑**先对数据进行排序**，这往往能极大地简化你的思考过程和代码逻辑：

  - **涉及区间操作**：几乎总是需要排序。
  - **寻找和为定值的多个数**：排序后可以使用双指针。
  - **结果要求去重，但输入可能重复**：排序是回溯算法去重的基础。
  - **问题看起来可以用贪心策略解决**：排序帮你找到每一步的“贪心选择”。
  - **需要对不同表现形式的同类项进行分组**：排序帮你找到它们的“统一身份证”。

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

解法一：使用额外数组。

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        if (nums.size() == k || nums.size() == 0 || k == 0)
            return;

        int start_k = nums.size() - k;
        vector<int> numk{nums.begin() + start_k, nums.end()};
        for (int i = start_k - 1; i >= 0; i--) {
            nums[i + k] = nums[i];
        }
        for (int i = 0; i < numk.size(); i++) {
            nums[i] = numk[i];
        }
    }
};
```

解法二：数组翻转（和链表翻转很像）

```c++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        }
    }

    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }
};
```

解法三：环状替换（不懂）



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)（vec的小坑）

方法一：笨方法（左侧乘积放一个数组，右侧乘积放一个数组，然后再搞个答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        vector<pair<int, int>> tmp(nums.size()); // pair<0-i的乘积, i-end的乘积>
        // 左侧乘积
        int product = 1;
        for (int i = 0; i < nums.size(); i++) {
            product *= nums[i];
            tmp[i].first = product;
        }
        // 右侧乘积
        product = 1;
        for (int i = nums.size() - 1; i >= 0; i--) {
            product *= nums[i];
            tmp[i].second = product;
        }

        // 这样初始化后，res中存在四个值为0的int，push时会往后移
        // vector<int> res(nums.size()); 
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int l = (i == 0) ? 1 : tmp[i - 1].first;
            int r = (i == nums.size() - 1) ? 1 : tmp[i + 1].second;
            res.push_back(l * r);
        }
        return res;
    }
};
```

方法二：合并左右乘积列表（左侧乘积放在答案数组中，然后从右往左将右侧乘积 × 答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        if (nums.size() == 1)
            return {1};
        vector<int> res(nums.size(), 1);
        // 左侧乘积
        for (int i = 1; i < nums.size(); i++) {
            // res[i]表示 0 -> i-1 的乘积
            res[i] = res[i - 1] * nums[i - 1];
        }

        // 使用product代替右侧乘积
        int product = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            product *= nums[i + 1];
            // 此时product表示 i+1 -> end 的乘积
            res[i] *= product;
        }
        return res;
    }
};
```

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

本题的思路很清奇：**使用负号来作为标记**；类似的思路在许多需要`O(1)`额外空间的题目中非常好用

```c++
class Solution {
public:

    void vecdebug(vector<int>& nums) {
        for (int& e : nums)
            cout << e << " ";
        cout << "\n";
    }

    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int& e : nums) {
            if (e <= 0)
                e = n + 1;
        }
        vecdebug(nums);

        // 打标记
        for (int i = 0; i < nums.size(); i++) {
            // // curr可能被被标记改为负值，但是我们只对其值感兴趣，所以需要标记
            int curr = abs(nums[i]);
            if (curr <= n && curr >= 1)
                // 使用负号作为标记，表示当前下表的值在数组中出现过
                // 需要注意防止重复标记，所以需要abs
                nums[curr - 1] = -1 * abs(nums[curr - 1]);
        }
        vecdebug(nums);

        // 检查标记
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0)
                return i + 1;
        }
        return n + 1;
    }
};
```

### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

使用`O(m+n)`的额外空间

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return;
        vector<int> row{};
        vector<int> column{};
        int m = matrix.size(); // m行
        int n = matrix[0].size(); // n列
        cout << n << endl;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row.push_back(i);
                    column.push_back(j);
                }
            }
        }

        // 行清空
        for (int& e : row) {
            auto tmp = vector(n, 0);
            matrix[e].swap(tmp);
        }
        // 列清空
        for (int& e : column) {
            for (int i = 0; i < m; i++) {
                matrix[i][e] = 0;
            }
        }
    }
};
```

使用`O(1)`的额外空间，这里和41题类似，**使用了0作为标记**

```c++
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return;
        int m = matrix.size();
        int n = matrix[0].size();
        bool row_zero = false;
        bool col_zero = false;

        // 第0行有0，则row_zero为true
        for (int& e : matrix[0]) {
            if (e == 0)
                row_zero = true;
        }
        // 第0列有0，则col_zero为true
        for (int j = 0; j < m; j++) {
            if (matrix[j][0] == 0)
                col_zero = true;
        }
        // 如果[i][j]的值为0，则将[i][0]和[0][j]都设置为0
        // 表示当前行和列需要设置为0
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        // 从第一行第一列开始看起，根据第0行和第0列的值判断当前位置是否需要设置为0
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0)
                    matrix[i][j] = 0;
            }
        }

        if (row_zero) {
            auto tmp = vector<int>(n, 0);
            matrix[0].swap(tmp);
        }
        if (col_zero) {
            for (int i = 0; i < m; i++)
                matrix[i][0] = 0;
        }
    }
};
```

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

模拟题，

1. 以前的思路是使用一个数，比如left，right来表示边界，但这样很麻烦，因为我们是用的一个一维数来表示二维坐标，表达很不清晰，所以我们可以使用pair来表示边界，这样就很清楚了。
2. 遇到涉及区间的问题时，一定要坚持不变量（比如左闭右开）
3. 注意只有一行/只有一列时，存在重复输出的现象。

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.empty())
            return {};
        vector<int> res{};
        pair<int, int> ltop{0, 0}, rtop{0, matrix[0].size() - 1};
        pair<int, int> ldown{matrix.size() - 1, 0}, rdown{matrix.size() - 1, matrix[0].size() - 1};
        while ( (ltop <= rtop) && (ltop <= ldown) ) {
            // 输出左闭右闭top行，此时只有col变化
            for (int i = ltop.second; i <= rtop.second; i++) {
                res.push_back(matrix[ltop.first][i]);
            }
            // 输出上开下开right列，此时只有row变化
            for (int i = rtop.first + 1; i <= rdown.first - 1; i++) {
                res.push_back(matrix[i][rtop.second]);
            }

            do {
                // 如果只有一行，left列和right列没有数据，且down行和top行数据重复，不要输出
                if (ltop == ldown)
                    break;
                // 输出右闭左闭down行，此时只有col变化
                for (int i = rdown.second; i >= ldown.second; i--) {
                    res.push_back(matrix[rdown.first][i]);
                }

                // 如果只有一列，left列和right列数据重复，不要输出
                if (ltop == rtop)
                    break;
                // 输出下开上开left列，此时只有row变化
                for (int i = ldown.first - 1; i >= ltop.first + 1; i--) {
                    res.push_back(matrix[i][ldown.second]);
                }
            }while (0);

            ++ltop.first;
            ++ltop.second;

            ++rtop.first;
            --rtop.second;

            --rdown.first;
            --rdown.second;

            --ldown.first;
            ++ldown.second;
        }
        return res;
    }
};
```

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

顺时针90°：转置 + 水平镜像
逆时针90°：转置 + 垂直镜像
180°：水平镜像 + 垂直镜像

```c++
class Solution {
public:
    void traverse(vector<vector<int>>& matrix) {
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = i; j < matrix[0].size(); j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
    void horizon_mirror(vector<vector<int>>& matrix) {
        int n = matrix[0].size() - 1;
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size() / 2; j++) {
                swap(matrix[i][j], matrix[i][n - j]);
            }
        }
    }

    void rotate(vector<vector<int>>& matrix) {
        traverse(matrix);
        horizon_mirror(matrix);
    }
};
```

### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

想象成二叉搜索树

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty())
            return false;
        int row = 0, col = matrix[0].size() - 1;

        while (row < matrix.size() && col >= 0) {
            int curr = matrix[row][col];
            if (curr == target)
                return true;
            if (target > curr) {    // 找右儿子
                // 右儿子：行+1，列不变
                ++row;
            }
            else if (target < curr) {   // 找左儿子
                // 左儿子：行不变，列-1
                --col;
            }
        }
        return false;
    }
};
```

## 链表

### 链表总结

1. **虚拟头节点 (Dummy Head Node)**

   这是解决链表修改类问题的“银弹”。它是一个位于真实头节点head之前的哨兵节点。

   - **解决什么问题**：当链表的**头节点**本身可能会被修改（例如，删除头节点、在头节点前插入新节点）时，使用虚拟头节点可以极大地简化逻辑。

   - **为什么有效**：它能保证链表永远有一个固定的“头”（即dummy节点），从而让所有节点的处理逻辑（无论是头节点还是中间节点）都变得**统一**，无需为头节点写单独的if-else判断。

   - **笔记中的体现**：

     - **203. 移除链表元素 (第8页)**：删除的元素可能是头节点。
     - **24. 两两交换链表中的节点 (第14页)**：第一个节点会被交换，导致头节点变化。你的笔记里写道：“**所有涉及到更改节点的链表题都必须设置虚拟指针！！！！**” —— 这个总结非常到位！

   - **使用方法**：

     ```c++
     ListNode* dummyHead = new ListNode(0); // 创建虚拟头节点
     dummyHead->next = head;                 // 连接到真实头节点
     // ... 对链表进行操作，起点是 dummyHead
     return dummyHead->next;                 // 返回新的头节点
     ```

   ---

2. **双指针 (Two Pointers)**

   双指针是链表问题中最灵活、最强大的技巧，根据指针的移动方式，可以分为以下几种：

   一个指针每次走一步（slow），另一个指针每次走两步（fast）。

   - **解决什么问题**：
     1. **寻找链表中点**：当fast指针到达链表末尾时，slow指针正好在链表中点。
     2. **判断链表是否有环**：如果fast和slow指针能够相遇，则链表有环。
     3. **寻找环的入口**：在相遇后，将一个指针放回头节点，然后两个指针都每次走一步，再次相遇点即为环的入口。
     
   - **笔记中的体现**：
     - **142. 环形链表 II (第21页)**：笔记中详细总结了快慢指针的三种用法，是此模式的经典应用。
   
     通常用pre和curr两个指针，pre始终指向curr的前一个节点。为了更新，往往还需要第三个指针temp来保存curr的下一个节点。 
     
   - **解决什么问题**：
     1. **反转链表**：这是最经典的应用。
     2. **原地修改/删除**：需要知道前驱节点来进行pre->next = curr->next之类的操作。
     
   - **笔记中的体现**：
     
     - **206. 反转链表 (第10页)**：你的笔记里详细拆解了pre、curr、temp三者的配合，这正是该模式的核心。
       1. temp = curr->next; // 保存下一个节点，防止断链
       2. curr->next = pre; // 核心反转操作
       3. pre = curr; // pre后移
       4. curr = temp; // curr后移
   
   一个指针（fast）先走 n 步，然后两个指针（fast 和 slow）再一起走，直到fast到达链表末尾。
   
   - **解决什么问题**：
     1. **删除链表的倒数第 N 个节点**。
   - **笔记中的体现**：
     - **19. 删除链表的倒数第 N 个结点 (第16页)**：让fast先走n步，这样slow和fast之间就保持了n的距离。当fast走到末尾时，slow正好指向倒数第n个节点的前一个节点，方便执行删除操作。

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

先把两个链表长度对齐，然后同步遍历

```c++
class Solution {
public:
    ListNode* move_forward(ListNode* curr, int stride) {
        while (stride > 0 && curr) {
            curr = curr->next;
            --stride;
        }
        return curr;
    }

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB)
            return nullptr;

        int lenA = 0;
        int lenB = 0;

        // 获取长度
        ListNode* currA = headA;
        while (currA) {
            ++lenA;
            currA = currA->next;
        }
        ListNode* currB = headB;
        while (currB) {
            ++lenB;
            currB = currB->next;
        }

        // 对齐长度
        currA = headA;
        currB = headB;
        if (lenA > lenB)
            currA = move_forward(currA, lenA - lenB);
        else if (lenB > lenA)
            currB = move_forward(currB, lenB - lenA);

        // 等待相遇
        while (currA && currB) {
            if (currA == currB)
                return currA;
            currA = currA->next;
            currB = currB->next;
        }
        return nullptr;
    }
};
```

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

双指针+tmp

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* left = nullptr;
        ListNode* right = head;
        ListNode* tmp = nullptr;

        while (right) {
            tmp = right->next;
            right->next = left;
            left = right;
            right = tmp;
        }
        return left;
    }
};
```

### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)？？？

根据下面的142，最好将本题代码实现为：fast走过的路程与slow走过的路程为倍数关系

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head)
            return false;
        if (!head->next)
            return true;

        // slow 最后停在链表前半部分的结尾
        // 这里可以做个简单的想象：链表只有两个节点和只有三个节点的情况
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* rightHead = slow->next;
        slow->next = nullptr;

        // 反转后半部分，不反转前半部分是因为后半部分可能比前半部分多1
        ListNode* left = nullptr;
        ListNode* right = rightHead;
        ListNode* tmp = nullptr;
        while (right) {
            tmp = right->next;
            right->next = left;
            left = right;
            right = tmp;
        }

        // 开始遍历
        ListNode* currLeft = head;
        ListNode* currRight = left;
        while (currLeft) {
            if (currLeft->val != currRight->val)
                return false;
            currLeft = currLeft->next;
            currRight = currRight->next;
        }
        return true;
    }
};
```

### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head || !head->next)
            return false;
        ListNode* slow = head;
        ListNode* fast = head->next;

        while (fast->next && fast->next->next) {
            if (slow == fast)
                return true;
            slow = slow->next;
            fast = fast->next->next;
        }
        return false;
    }
};
```

### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

注意本题中的slow和fast被初始化为：

```c++
ListNode* slow = head;
ListNode* fast = head;
```

与之前的写法有所不同，是因为：

之前的写法中，我期望fast和slow的下标存在倍数关系（当slow下标不为0时）

而本题的数学关系是：**fast和slow走过的路程存在倍数关系，所以在开始时，fast和slow都需要初始为head**

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (!head || !head->next)
            return nullptr;

        // slow和fast相遇后，拿slow作为标兵
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast)
                break;
        }
        if (slow != fast)
            return nullptr;
        
        // 标兵和curr在入环节点相遇
        ListNode* curr = head;
        while (slow != curr) {
            slow = slow->next;
            curr = curr->next;
        }
        return curr;
    }
};
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

唯一需要注意的是，curr，curr1，curr2都需要往后移动

```c++
class Solution {
    public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if (!list1)
            return list2;
        if (!list2)
            return list1;

        ListNode* curr1 = list1;
        ListNode* curr2 = list2;
        ListNode* dummy = new ListNode{0};
        ListNode* curr = dummy;

        while (curr1 || curr2) {
            if (!curr1) {				// curr1为空
                curr->next = curr2;
                curr2 = curr2->next;
            }
            else if (!curr2) {			// curr2为空
                curr->next = curr1;
                curr1 = curr1->next;
            }
            else {						// curr1和curr2非空
                if (curr1->val < curr2->val) {	
                    curr->next = curr1;
                    curr1 = curr1->next;
                }
                else {
                    curr->next = curr2;
                    curr2 = curr2->next;
                }
            }
            curr = curr->next;
        }
        return dummy->next;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* curr1 = l1;
        ListNode* curr2 = l2;
        ListNode* dummy = new ListNode{0};
        ListNode* curr = dummy;

        int overten = 0;
        while (curr1 || curr2) {
            if (!curr1) {               // curr1为空
                int res = curr2->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr2 = curr2->next;
            }
            else if (!curr2) {          // curr2为空
                int res = curr1->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr1 = curr1->next;
            }
            else {                      // curr1和curr2非空
                int res = curr1->val + curr2->val + overten;
                overten = res / 10;
                res = res % 10;

                curr->next = new ListNode{res};
                curr1 = curr1->next;
                curr2 = curr2->next;
            }
            curr = curr->next;
        }
        if (overten)
            curr->next = new ListNode{1};
        return dummy->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* left = head;              // 定位需要删除的节点
        ListNode* right = head;             // 用于终止left的移动
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;              // left的前一个节点
        pre->next = head;
        while (n > 0) {
            right = right->next;
            --n;
        }
        while (right) {
            pre = pre->next;
            left = left->next;
            right = right->next;
        }
        pre->next = left->next;
        return dummy->next;
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

本题需要注意的是，left和right每个循环要跳两步，所以处理和之前不同

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (!head)
            return nullptr;
        if (!head->next)
            return head;

        ListNode* left = head;
        ListNode* right = head->next;
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;
        pre->next = left;
        // 我们需要改变left->next，right->next和pre->next
        while (right) {
            // 反转left，right，更新pre
            left->next = right->next;
            right->next = left;
            pre->next = right;

            // 反转之后，left在右，right在左
            // 此时有两种情况：
            // 1. left是最后一个节点，此时 left->next == nullptr
            // 2. left是倒数第二个节点，此时 left->next != nullptr，但最后一个节点不反转
            // 本题需要注意的是，left和right每个循环要跳两步，所以处理和之前不同
            pre = left;
            left = left->next;
            if (left)
                right = left->next;
            else
                right = nullptr;
        }
        return dummy->next;
    }
};
```

### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

重点是搞懂206题，其次reverse的设计可以将返回值设计成`pair<new_head, new_tail>`

```c++
class Solution {
public:
    // 将left指向pre
    ListNode* reverse(ListNode* start, ListNode* end) {
        ListNode* pre = nullptr;
        ListNode* left = start;
        ListNode* right = left->next;
        while (right != end->next) {
            left->next = pre;
            pre = left;
            left = right;
            right = right->next;
        }
        left->next = pre;
        return left;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode{0};
        ListNode* pre = dummy;
        pre->next = head;

        ListNode* left = head;
        ListNode* right = head;
        ListNode* tmp = head;
        while (1) {
            int stride = k - 1;
            left = tmp;
            right = left;
            // 当元素足够，可以反转时，由stride==0触发，退出循环
            // 当元素不够，不可以反转时，由right==nullptr触发，退出循环
            while (right && stride > 0) {
                right = right->next;
                --stride;
            }
            if (!right) {
                pre->next = left;
                break;
            }
            tmp = right->next;

            // 经过以上步骤，需要反转的是 [left, right]
            pre->next = reverse(left, right);
            pre = left;
        }
        return dummy->next;
    }
};
```

### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> umAddr{};   // <旧节点地址，新节点地址>
        Node* old_curr = head;
        // 注意赋值时需要给val和ramdom都赋值
        Node* dummy = new Node{0};
        dummy->random = nullptr;
        Node* new_curr = dummy;

        // 深拷贝val，random使用老节点的。
        while (old_curr) {
            // 注意赋值时需要给val和ramdom都赋值
            Node* new_node = new Node{old_curr->val};
            new_node->random = old_curr->random;
            
            umAddr.insert(make_pair(old_curr,new_node));

            old_curr = old_curr->next;
            new_curr->next = new_node;
            new_curr = new_curr->next;
        }

        // 更新新节点的random
        new_curr = dummy;
        while (new_curr) {
            auto it = umAddr.find(new_curr->random);
            if (it != umAddr.end()) {
                new_curr->random = it->second;
            }
            else {
                new_curr->random = nullptr;
            }
            new_curr = new_curr->next;
        }
        return dummy->next;
    }
};
```

### [148. 排序链表](https://leetcode.cn/problems/sort-list/)？？？

归并排序

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)？？？

分治合并，优先队列

维护一个currs数组，其中存放着每个`lists[i]`的地址，我们可以从currs数组中找最小的那个val即可

当然这一过程也可以使用优先队列来优化

```c++
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if (lists.empty())
            return nullptr;
        vector<ListNode*> currs(lists.size(), nullptr);
        for (int i = 0; i < lists.size(); i++) {
            currs[i] = lists[i];
        }
        ListNode* dummy = new ListNode{0};
        ListNode* curr_res = dummy;

        bool in_loop = true;
        int curr_null = 0;
        while (in_loop) {
            int min_val = INT32_MAX;
            ListNode* min_addr = nullptr;
            int min_idx = 0;
            // 每一个loop中，都要遍历currs数组中每一个元素，用于比较大小
            for (int i = 0; i < currs.size(); i++) {
                if (currs[i] == nullptr) {
                    // 视情况++
                    if (!us_curr_null_.count(i)) {
                        us_curr_null_.insert(i);
                        ++curr_null;
                        if (curr_null == lists.size()) {
                            in_loop = false;
                            break;
                        }
                    }
                    continue;
                }
                // 比较值
                if (currs[i]->val <= min_val) {
                    min_val = currs[i]->val;
                    min_addr = currs[i];
                    min_idx = i;
                }
            }
            // 更新res，更新currs
            // 当break出for循环时，min_addr为null
            if (min_addr) {
                curr_res->next = min_addr;
                curr_res = curr_res->next;
                currs[min_idx] = min_addr->next;
            }
        }
        return dummy->next;
    }
    unordered_set<int> us_curr_null_{};
};
```

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)？？？

哈希表+双链表，数据存在双链表中，双链表的头节点是刚刚使用过的，尾节点是很久没用的，哈希表`<key，链表地址>`

## 二叉树

### 二叉树总结

1. 核心思想：遍历方式决定一切

   解决任何二叉树问题的第一步，是**明确使用哪种遍历方式**。书中强调，这并非凭感觉，而是由问题本质决定的。

   1. **深度优先遍历 (DFS) - 递归实现**
      - **适用场景**：绝大多数二叉树问题。
      - **核心技巧：递归三部曲** (书中反复强调的方法论)
        1. **确定函数签名**：明确函数的参数和返回值。返回值可以是 void、bool、节点指针 TreeNode* 或计算结果 int。
        2. **确定终止条件**：通常是遇到空节点 (root == nullptr) 时返回。
        3. **确定单层递归逻辑**：根据**前序/中序/后序**的顺序，处理当前节点与左右子树的关系。
   2. **广度优先遍历 (BFS) - 队列实现**
      - **适用场景**：所有**逐层**处理的问题。
      - **核心技巧：层序遍历模板**
        - 使用 std::queue。
        - 外层 while (!q.empty()) 循环控制所有层的遍历。
        - 内层 for (int i = 0; i < q.size(); i++) 循环精确控制**当前层**的节点遍历。
      - **典型应用**：求最大/最小深度、找最左/右下角值、N叉树层序遍历等。

2. 题型分类与核心技巧

   书中将二叉树问题系统地分为以下几类，每类都有明确的解题范式：

   | 类别                         | 核心思路 & 推荐遍历方式          | 关键点 & 技巧                                                |
   | ---------------------------- | -------------------------------- | ------------------------------------------------------------ |
   | **1. 二叉树属性求解**        | **后序遍历 (左右中) + 分治思想** | **自底向上**传递信息。先处理左右子树，再根据左右子树的返回值计算当前节点的结果。适用于求**高度**、判断**平衡性/对称性**等。 |
   | **2. 二叉树修改与构造**      | **前序遍历 (中左右) + 分治思想** | **自顶向下**构建。先处理根节点，然后递归构建左右子树。适用于**翻转二叉树**、**从数组构造二叉树**等。 |
   | **3. 二叉搜索树 (BST) 操作** | **利用其有序性**                 | 1. **中序遍历**结果是一个**升序序列**，这是解决BST问题的“金钥匙”。<br>2. 操作时无需遍历整棵树，可像**二分查找**一样，根据当前节点值与目标值的比较结果，决定向左或向右递归。 |
   | **4. 路径问题**              | **前序遍历 (中左右) + 回溯**     | 寻找从根到叶子的路径时，在前序遍历的递归调用前后进行 path.push_back() 和 path.pop_back() 操作，实现路径的记录与撤销。 |
   | **5. 公共祖先 (LCA)**        | 根据树的类型选择不同策略         | 1. **普通二叉树**：使用**后序遍历**，通过左右子树的返回值判断。<br>2. **二叉搜索树**：利用有序性，从根节点开始判断目标节点 p 和 q 在当前节点的哪一侧。 |

3. 总结与建议

   - **递归 vs. 迭代**：书中强调，先用递归理清思路，因为它最符合树的结构。迭代（特别是统一风格的迭代法）是进阶技巧，用于加深理解和应对特定面试要求。
   - **画图**：理解递归和指针操作最有效的方式。
   - **回溯与递归的关系**：回溯是递归的一种体现。求路径问题时回溯的体现是显式的；求树的属性时，回溯体现在递归函数的返回过程中。
   - **不变量原则**：在处理需要切割数组来构造树的问题时，坚持**区间的定义**（如左闭右开或左闭右闭）能有效避免边界错误。

   **总而言之，解二叉树题目的王道就是：先判断题型，再根据题型选择最高效的遍历策略，并熟练运用递归三部曲或层序遍历模板。**

### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

非递归的前序遍历

注意这里涉及到一个处理顺序和访问顺序：

对于前序遍历，我们先访问的是中间节点，先处理的也是中间节点，所以我们可以用一个stack来同时表示二叉树的访问顺序和处理顺序

```c++
class Solution {
public:
    // 中-左-右
    vector<int> preorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        vector<int> res{};
        stack<TreeNode*> stack_node{};
        stack_node.push(root);

        while (!stack_node.empty()) {
            // 先处理中节点
            auto pnode = stack_node.top();
            stack_node.pop();
            res.push_back(pnode->val);
            // 先push右节点，再push左节点，因为pop的方向是反的
            // 注意空节点不要push进来
            if (pnode->right)
                stack_node.push(pnode->right);
            if (pnode->left)
                stack_node.push(pnode->left);
        }
        return res;
    }
};
```

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

非递归的后序遍历：

我们可以由非递归的前序遍历推导而来：

1. 首先前序遍历结果是：中-左-右；而后续遍历要求是左-右-中
2. 所以可以考虑先反转左右节点的入栈顺序
3. 然后再反转答案数组即可，这样我们在实际编码时，依然可以保证访问顺序和处理顺序的一致性

```c++
class Solution {
public:
    // 左-右-中
    vector<int> postorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        vector<int> res{};
        stack<TreeNode*> stack_node{};
        stack_node.push(root);

        while (!stack_node.empty()) {
            // 先处理中节点
            auto pnode = stack_node.top();
            stack_node.pop();
            res.push_back(pnode->val);
            // 先push左节点，再push右节点，这样pop的顺序是中-右-左
            // 注意空节点不要push进来
            if (pnode->left)
                stack_node.push(pnode->left);
            if (pnode->right)
                stack_node.push(pnode->right);
        }
        // 中-右-左，反转成 左-右-中
        return {res.rbegin(), res.rend()};
    }
};
```

### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

注意前序/后序遍历和中序遍历不一样，中序遍历需要一个curr指针来表示访问顺序，stack只负责处理顺序

```c++
class Solution {
public:
    // 前-中-右
    vector<int> inorderTraversal(TreeNode* root) {
        if (!root)
            return {};
        TreeNode* curr = root;
        vector<int> res{};
        stack<TreeNode*> node_stack{};
        while (curr || !node_stack.empty()) {
            if (curr) {             // curr非空时放入左孩子
                node_stack.push(curr);
                curr = curr->left;          // 左
            }
            else {                  // curr为空时为树的最底层
                curr = node_stack.top();
                node_stack.pop();

                res.push_back(curr->val);  // 中
                curr = curr->right;         // 右
            }
        }
        return res;
    }
};
```

