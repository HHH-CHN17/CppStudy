### [1. 两数之和](https://leetcode.cn/problems/two-sum/)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> umap{};
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int expect = target - nums[i];
            const auto& e = umap.find(expect);
            if (e == umap.end()) {  // 没找到
                umap.insert(make_pair(nums[i], i));
            }else {                 // 找到
                res.push_back(i);
                res.push_back(e->second);
                return res;
            }
        }
        return res;
    }
};
```

### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)???

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty())
            return vector<vector<int>>{};
        sort(intervals.begin(), intervals.end());	// 1. 先排序（最重要）
        vector<vector<int>> res{};
        vector<int> merge(intervals[0]);
        for (vector<int>& vec : intervals) {
            if (merge[1] >= vec[0])					// 2. 排序之后，只要左区间最大的比右区间最小的值大，就说明重叠
                merge[1] = max(merge[1], vec[1]);
            else {									// 3. 否则说明合并结束
                res.push_back(merge);
                merge = vec;
            }
        }
        res.push_back(merge);
        return res;
    }
};
```

#### 总结：sort函数的使用时机

- 处理区间问题 (Interval Problems)

  这是最常见的使用场景之一，也是你提到的 **“合并区间” (Merge Intervals, 笔记第140页)** 问题的核心解法。

  - **原因**: 对区间按起点排序后，我们就可以按顺序线性扫描，只需考虑当前区间与前一个合并后的区间的关系。如果不排序，我们就需要比较任意两个区间，逻辑会变得异常复杂。
  - **笔记中的例子**:
    - **56. 合并区间**: 按区间起点排序，然后依次合并。
    - **452. 用最少数量的箭引爆气球** (第136页): 按区间起点或终点排序，然后贪心地确定箭的位置。
    - **435. 无重叠区间** (第137页): 按区间终点排序，然后贪心地选择不重叠的区间。

- 启用“双指针”或“二分查找”技巧

  当需要在一个数组中寻找两个或多个满足特定和（sum）条件的元素时，排序是启用高效算法的前提。

  - **原因**: 在一个无序数组中寻找两数之和为target，通常需要O(n²)的暴力搜索或借助O(n)空间复杂度的哈希表。但如果数组有序，就可以使用双指针从两端向中间扫描，在O(n)的时间复杂度和O(1)的空间复杂度内解决问题。
  - **笔记中的例子**:
    - **15. 三数之和** (第31页): 笔记中明确提到“考虑到本题不需要返回数组下标，所以我们可以直接对这个数组进行排序，排序之后时间复杂度有效下降。” 排序后，固定一个数，再用双指针寻找另外两个数。
    - **18. 四数之和** (第32页): 与“三数之和”同理，排序是使用双指针解法的基础。

- 方便去重 (Handling Duplicates)

  在求解组合、子集、排列等问题时，如果输入数组含有重复元素，而输出要求不能有重复的组合，排序是最高效的去重前置步骤。

  - **原因**: 排序后，所有相同的元素会聚集在一起。这样在进行深度优先搜索（回溯）时，我们就可以通过一个简单的判断（例如 if (i > 0 && nums[i] == nums[i-1])）来跳过由重复元素产生的相同分支，从而避免结果重复。
  - **笔记中的例子**:
    - **40. 组合总和 II** (第109页): 笔记中提到这是“树层去重”，排序是实现这种去重逻辑的关键。
    - **90. 子集 II** (第115页): 同理，先排序，再通过判断来跳过重复的元素。
    - **47. 全排列 II** (第119页): 同样先排序，以方便在回溯过程中识别和跳过重复的排列。

- 运用贪心算法 (Greedy Algorithms)

  很多贪心算法的正确性依赖于一个前提：总是对当前“最好”或“最优”的元素做选择。排序可以帮助我们快速定位到这个“最优”元素。

  - **原因**: 通过排序，我们可以将问题转化为每次都从剩余元素中选择最大/最小，或者最先开始/结束的项。
  - **笔记中的例子**:
    - **455. 分发饼干** (第121页): 将孩子的胃口和饼干的尺寸都排序，然后用最小的饼干去满足胃口最小的孩子，这就是一个经典的贪心策略。
    - **406. 根据身高重建队列** (第135页): 笔记中提到“遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。” 这里通过先按身高降序、再按k值升序的排序规则，使得每次插入一个人时，都能保证其插入位置的正确性。

- 创建“范式”或“唯一标识”

  当需要对某些内容进行分类或分组，而这些内容有多种表现形式时（例如字母异位词），可以通过排序创造一个唯一的、标准化的“范式”（Canonical Form）作为它们的标识。

  - **笔记中的例子**:
    - **49. 字母异位词分组** (第23页): 笔记提到“可以通过sort排序将异位词变成一样的就好了”。例如，"eat", "tea", "ate" 排序后都变成了 "aet"，可以把 "aet" 作为键，将它们分到同一组。

- 总结

  总的来说，当你遇到以下情况时，可以优先考虑**先对数据进行排序**，这往往能极大地简化你的思考过程和代码逻辑：

  - **涉及区间操作**：几乎总是需要排序。
  - **寻找和为定值的多个数**：排序后可以使用双指针。
  - **结果要求去重，但输入可能重复**：排序是回溯算法去重的基础。
  - **问题看起来可以用贪心策略解决**：排序帮你找到每一步的“贪心选择”。
  - **需要对不同表现形式的同类项进行分组**：排序帮你找到它们的“统一身份证”。

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

解法一：使用额外数组。

```c++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        if (nums.size() == k || nums.size() == 0 || k == 0)
            return;

        int start_k = nums.size() - k;
        vector<int> numk{nums.begin() + start_k, nums.end()};
        for (int i = start_k - 1; i >= 0; i--) {
            nums[i + k] = nums[i];
        }
        for (int i = 0; i < numk.size(); i++) {
            nums[i] = numk[i];
        }
    }
};
```

解法二：数组翻转（和链表翻转很像）

```c++
class Solution {
public:
    void reverse(vector<int>& nums, int start, int end) {
        while (start < end) {
            swap(nums[start], nums[end]);
            start += 1;
            end -= 1;
        }
    }

    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }
};
```

解法三：环状替换（不懂）



### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)（vec的小坑）

方法一：笨方法（左侧乘积放一个数组，右侧乘积放一个数组，然后再搞个答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        vector<pair<int, int>> tmp(nums.size()); // pair<0-i的乘积, i-end的乘积>
        // 左侧乘积
        int product = 1;
        for (int i = 0; i < nums.size(); i++) {
            product *= nums[i];
            tmp[i].first = product;
        }
        // 右侧乘积
        product = 1;
        for (int i = nums.size() - 1; i >= 0; i--) {
            product *= nums[i];
            tmp[i].second = product;
        }

        // 这样初始化后，res中存在四个值为0的int，push时会往后移
        // vector<int> res(nums.size()); 
        vector<int> res{};
        for (int i = 0; i < nums.size(); i++) {
            int l = (i == 0) ? 1 : tmp[i - 1].first;
            int r = (i == nums.size() - 1) ? 1 : tmp[i + 1].second;
            res.push_back(l * r);
        }
        return res;
    }
};
```

方法二：合并左右乘积列表（左侧乘积放在答案数组中，然后从右往左将右侧乘积 × 答案数组）

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if (nums.empty())
            return {};
        if (nums.size() == 1)
            return {1};
        vector<int> res(nums.size(), 1);
        // 左侧乘积
        for (int i = 1; i < nums.size(); i++) {
            // res[i]表示 0 -> i-1 的乘积
            res[i] = res[i - 1] * nums[i - 1];
        }

        // 使用product代替右侧乘积
        int product = 1;
        for (int i = nums.size() - 2; i >= 0; i--) {
            product *= nums[i + 1];
            // 此时product表示 i+1 -> end 的乘积
            res[i] *= product;
        }
        return res;
    }
};
```

