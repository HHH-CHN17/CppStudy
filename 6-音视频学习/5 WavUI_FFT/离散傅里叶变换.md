### **DFT 分析算法中的振幅缩放 P153**

#### **1. 上下文背景 (Context)**

当我们使用 **实数 DFT (Real DFT)** 的分析方程（Correlation Algorithm）计算频域数据时，核心操作是将**输入信号**与**基函数（正弦/余弦探针）**进行点乘并求和。

分析公式：

$$ReX[k] = \sum_{i=0}^{N-1} x[i] \cdot \cos\left(\frac{2\pi k i}{N}\right)$$

核心问题：

算出来的 $ReX[k]$ 数值往往非常大。为了得到信号真实的物理振幅（如电压/音量），我们需要理解这个累加值的放大倍数，并在逆变换或频谱显示时进行归一化（Normalization）。

------

#### **2. 物理机制：为什么是 $N/2$？**

对于绝大多数频率，放大倍数是 $N/2$。这是因为交流信号的**平均功率**特性。

- **共振原理**：当输入信号与探针频率一致时，相乘结果本质上是 $\cos^2(\theta)$。
- **能量贡献**：$\cos^2(\theta)$ 的波形在 $0$ 到 $1$ 之间震荡，其**平均高度是 0.5**。
- **结论**：虽然累加了 $N$ 个点，但有效贡献只有 $50\%$。

------

#### **3. 详细对照表 (The Table)**

| **频率成分 (k)**             | **物理场景描述**                                | **采样点与探针的相互作用**                                   | **数学本质 (∑Product)** | **DFT求和结果**            | **代码中的归一化** |
| ---------------------------- | ----------------------------------------------- | ------------------------------------------------------------ | ----------------------- | -------------------------- | ------------------ |
| **直流分量** ($k=0$)         | **DC Offset** 信号是一条水平直线。              | 信号是常数，探针也是常数 $1$。 每个点都实打实地贡献了数值。  | $\sum (1 \times 1) = N$ | **$N \times A$**           | `ReX[0] / N`       |
| **奈奎斯特频率** ($k=N/2$)   | **Nyquist Freq** 最高频震荡 ($+1, -1, \dots$)。 | 正好采在波峰和波谷。 没有“过零点”来拉低平均值。 负负得正，每个点都贡献最大值。 | $\sum (1 \times 1) = N$ | **$N \times A$**           | `ReX[N/2] / N`     |
| **常规频率** ($0 < k < N/2$) | **Normal Freq** 绝大多数有效频率。              | 采样点覆盖波峰、波谷和**过零点**。 波峰处贡献 1，过零点处贡献 0。 平均贡献被拉低到一半。 | $\sum \cos^2 = 0.5 N$   | **$\frac{N}{2} \times A$** | `ReX[k] / (N/2)`   |

> **注**：$A$ 代表信号在时域的真实振幅。

------

#### **4. C++ 音视频开发实战启示**

在实际工程（使用 FFTW 或 FFmpeg）中，这通常对应于**频谱图绘制**或**音频合成**的逻辑。

场景一：绘制频谱图 (Audio Visualization)

你需要展示真实的音量大小，因此必须除以缩放因子。

```c++
// 假设 fft_out 是 FFT 库计算出的复数结果
// N 是采样点数 (frame_size)

for (int k = 0; k <= N/2; ++k) {
    // 1. 计算模长 (Magnitude)
    float raw_mag = sqrt(fft_out[k].re * fft_out[k].re + fft_out[k].im * fft_out[k].im);
    
    // 2. 归一化 (根据表格规则)
    float true_amplitude;
    if (k == 0 || k == N/2) {
        true_amplitude = raw_mag / N;      // 特例：除以 N
    } else {
        true_amplitude = raw_mag / (N/2);  // 常规：除以 N/2
    }
    
    // 3. 转换为分贝 (dB) 用于渲染
    float db_value = 20 * log10(true_amplitude);
    render_bar(k, db_value);
}
```

场景二：逆变换合成 (IDFT)

如果你手写 IDFT，公式通常自带一个 $1/N$ 的系数，但这只能还原“数学上的值”。要完全还原原始波形，必须严格遵守上述规则，或者确保你的 FFT 库文档中说明了它内部的 Scaling 策略（注：FFTW 默认是不做归一化的，逆变换后结果会放大 $N$ 倍，需要手动除以 $N$）。