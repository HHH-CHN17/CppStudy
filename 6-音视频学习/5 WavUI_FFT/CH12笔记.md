## DFT 的标准公式



## 复数记法与 FFT 的基本策略 P228

- 先看翻译：

  在复数记法（Complex Notation）中，时域和频域各包含**一个**由 $N$ 个复数点组成的信号。这些复数点中的每一个都由两个数值组成：**实部**和**虚部**。

  【注解】：每个信号都有N个点组成。在时域图中，N个采样点构成了一个信号的波形图；在频谱图中，该信号对应的频点会被累加N次

  例如，当我们谈论复数采样 $X[42]$ 时，它指的就是 $ReX[42]$ 和 $ImX[42]$ 的组合。换句话说，每一个复数变量都持有两个数值。当两个复数变量相乘时，这四个单独的分量（两个实部、两个虚部）必须进行组合，才能形成乘积结果的那两个分量（实部和虚部），正如公式 9-1 所示。

  接下来关于“FFT 如何工作”的讨论，都将使用这种复数记法的行话。也就是说，诸如**信号 (Signal)**、**点 (Point)**、**采样 (Sample)** 和 **数值 (Value)** 这些单数术语，指的全部都是**实部和虚部的组合**。

  FFT 的运作通过以下三个步骤完成：

  1. **分解 (Decomposing)**：将一个 $N$ 点的时域信号，分解成 $N$ 个时域信号，其中每个信号只由**一个点**组成。
  2. **计算 (Calculating)**：计算这 $N$ 个单点时域信号所对应的 $N$ 个频谱。
  3. **合成 (Synthesizing)**：最后，将这 $N$ 个频谱合成（拼凑）成一个单一的频谱。

- 解析：

  这段话是 **FFT（快速傅里叶变换）算法** 的总纲。它主要讲了两件事：**“数据结构的定义”** 和 **“算法的宏观策略”**。

  1. 数据结构的定义：复数记法 (Complex Notation)

     - 在 FFT 算法的上下文中，术语发生了变化，所有操作对象默认为**复数**。
       - **“一个点/采样” (Point/Sample)**：不再是单纯的实数，而是指代一个**复数对** (Real + Imaginary)。
         - 即 $X[k]$ 包含 $ReX[k]$ 和 $ImX[k]$。
         - *C++ 对应*：`std::complex<double>` 或 `struct { double r; double i; }`。
       - **“信号” (Signal)**：指代由 $N$ 个复数点组成的序列。
       - **运算代价**：复数运算比实数运算昂贵。
         - 一次复数乘法 $(a+jb)(c+jd)$ 涉及 **4 次实数乘法** 和 **2 次实数加法**。

  2. 算法核心策略：分治法 (Divide and Conquer)

     FFT 之所以快，是因为它放弃了 $O(N^2)$ 的直接硬算，而是采用了**“拆解-求解-合成”**的递归/分治策略：

     1. **分解 (Decompose) —— 向下钻**
        - 将 $N$ 点的大信号，层层拆解，直到变成 $N$ 个**只有 1 个点**的小信号。
        - *注*：这一步对应后续的“位反转排序 (Bit Reversal Sorting)”。
     2. **求解 (Calculate) —— 基准情况**
        - 计算这 $N$ 个单点信号的频谱。
        - *原理*：对于只有 1 个点的信号，其频谱就是它自身（无需计算）。这是递归的终点（Base Case）。
     3. **合成 (Synthesize) —— 向上浮**
        - 将这些微小的频谱，两两结合，计算出 $N/2$ 点的频谱，再继续结合...
        - 最终还原成一个完整的 $N$ 点频谱。
        - *注*：这一步对应后续的“蝴蝶运算 (Butterfly Operation)”。