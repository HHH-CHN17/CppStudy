## DFT 的标准公式

### 核心工具：欧拉公式 

连接极坐标系（旋转/角度）与直角坐标系（坐标/投影）的“上帝公式”：
$$
e^{-j\theta} = \cos(\theta) - j\sin(\theta)
$$

- **左边 ($e^{-j\theta}$)**：**极坐标指令**。表示在单位圆上，从实轴 $+1$ 处开始，**顺时针**旋转 $\theta$ 角度。
- **右边 ($\cos - j\sin$)**：**直角坐标结果**。表示旋转停下后，该点在实轴 (Re) 和虚轴 (Im) 上的坐标投影。

推导过程：

1. 前置知识：三个基础展开式 (Maclaurin Series)

   根据微积分原理，这三个函数可以在 $x=0$ 处展开为无穷级数：

   1. 指数函数 (全项)：

      $$e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots$$

   2. 余弦函数 (偶次项，符号交替)：

      $$\cos(x) = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + \dots$$

   3. 正弦函数 (奇次项，符号交替)：

      $$\sin(x) = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} + \dots$$

------

2. 推导核心：虚数单位 $j$ 的循环

   将 $e^x$ 中的变量 $x$ 替换为纯虚数 **$j\theta$**。在此之前，先复习 $j$ 的幂运算规律（4次一循环）：

   - $j^1 = j$
   - $j^2 = -1$
   - $j^3 = -j$
   - $j^4 = 1$
   - $j^5 = j$ ...

------

3. 推导步骤 (Step-by-Step)

   - **Step A: 代入替换**

     在 $e^x$ 展开式中，令 $x = j\theta$：
     $$
     e^{j\theta} = 1 + \frac{(j\theta)}{1!} + \frac{(j\theta)^2}{2!} + \frac{(j\theta)^3}{3!} + \frac{(j\theta)^4}{4!} + \frac{(j\theta)^5}{5!} + \dots
     $$

   - **Step B: 展开各项并化简 $j$**
     $$
     e^{j\theta} = 1 + j\theta - \frac{\theta^2}{2!} - j\frac{\theta^3}{3!} + \frac{\theta^4}{4!} + j\frac{\theta^5}{5!} - \dots
     $$

   - **Step C: 分组 (实部与虚部)**

     将**不带 $j$ 的项**（实部）和**带 $j$ 的项**（虚部）分开归类：

     - 实部组：
       $$
       \left( 1 - \frac{\theta^2}{2!} + \frac{\theta^4}{4!} - \dots \right)
       $$
       $\Rightarrow$ 这正是 $\cos(\theta)$ 的展开式！

     - 虚部组 (提取公因子 $j$)：
       $$
       + j \cdot \left( \theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \dots \right)
       $$
       $\Rightarrow$ 这正是 $\sin(\theta)$ 的展开式！

------

4. 结论与 DFT 变体

   - **最终公式**
     $$
     e^{j\theta} = \cos(\theta) + j\sin(\theta)
     $$

   - **DFT 专用版 (负角度)**

     在 DFT 公式中，指数通常是负的。利用三角函数的奇偶性（$\cos$ 是偶函数，$\sin$ 是奇函数）：

     - $\cos(-\theta) = \cos(\theta)$
     - $\sin(-\theta) = -\sin(\theta)$

     代入 $-\theta$ 可得：
     $$
     e^{-j\theta} = \cos(\theta) - j\sin(\theta)
     $$
     这就是为什么 DFT 公式可以写成 $e^{-j\frac{2\pi}{N}kn}$ 的数学铁证。

### DFT公式推导

### 2. 推导过程 (Step-by-Step)

- **Step A: 我们熟悉的“笨办法”公式 (Chapter 8)**

  在学习 DFT 物理意义时，我们把信号分别投影到余弦波（实部）和正弦波（虚部）上：
  $$
  X[k] = \sum_{n=0}^{N-1} x[n] \cdot \left[ \underbrace{\cos\left(\frac{2\pi}{N}kn\right)}_{\text{实部相关性}} - j \cdot \underbrace{\sin\left(\frac{2\pi}{N}kn\right)}_{\text{虚部相关性}} \right]
  $$

- **Step B: 识别公共相位 $\theta$**

  观察中括号内的部分，发现相位角是完全一致的。令：
  $$
  \theta = \frac{2\pi}{N}kn
  $$
  原公式变为：
  $$
  X[k] = \sum_{n=0}^{N-1} x[n] \cdot [\cos(\theta) - j\sin(\theta)]
  $$

- **Step C: 代入欧拉公式**

  根据 $e^{-j\theta} = \cos(\theta) - j\sin(\theta)$，直接替换中括号内容：
  $$
  X[k] = \sum_{n=0}^{N-1} x[n] \cdot e^{-j\theta}
  $$

- **Step D: 最终的“紧凑版”公式 (Chapter 31 / FFT Standard)**

  把 $\theta$ 还原回去，得到教科书和 FFT 论文通用的标准形式：
  $$
  X[k] = \sum_{n=0}^{N-1} x[n] \cdot e^{-j\frac{2\pi}{N}kn}
  $$
  通过观察，k/N是归一化频率f，所以也能写成 $2\pi{f}{n}$

## 复数记法与 FFT 的基本策略 P228

- 先看翻译：

  在复数记法（Complex Notation）中，时域和频域各包含**一个**由 $N$ 个复数点组成的信号。这些复数点中的每一个都由两个数值组成：**实部**和**虚部**。

  【注解】：每个信号都有N个点组成。在时域图中，N个采样点构成了一个信号的波形图；在频谱图中，该信号对应的频点会被累加N次

  例如，当我们谈论复数采样 $X[42]$ 时，它指的就是 $ReX[42]$ 和 $ImX[42]$ 的组合。换句话说，每一个复数变量都持有两个数值。当两个复数变量相乘时，这四个单独的分量（两个实部、两个虚部）必须进行组合，才能形成乘积结果的那两个分量（实部和虚部），正如公式 9-1 所示。

  接下来关于“FFT 如何工作”的讨论，都将使用这种复数记法的行话。也就是说，诸如**信号 (Signal)**、**点 (Point)**、**采样 (Sample)** 和 **数值 (Value)** 这些单数术语，指的全部都是**实部和虚部的组合**。

  FFT 的运作通过以下三个步骤完成：

  1. **分解 (Decomposing)**：将一个 $N$ 点的时域信号，分解成 $N$ 个时域信号，其中每个信号只由**一个点**组成。
  2. **计算 (Calculating)**：计算这 $N$ 个单点时域信号所对应的 $N$ 个频谱。
  3. **合成 (Synthesizing)**：最后，将这 $N$ 个频谱合成（拼凑）成一个单一的频谱。

- 解析：

  这段话是 **FFT（快速傅里叶变换）算法** 的总纲。它主要讲了两件事：**“数据结构的定义”** 和 **“算法的宏观策略”**。

  1. 数据结构的定义：复数记法 (Complex Notation)

     - 在 FFT 算法的上下文中，术语发生了变化，所有操作对象默认为**复数**。
       - **“一个点/采样” (Point/Sample)**：不再是单纯的实数，而是指代一个**复数对** (Real + Imaginary)。
         - 即 $X[k]$ 包含 $ReX[k]$ 和 $ImX[k]$。
         - *C++ 对应*：`std::complex<double>` 或 `struct { double r; double i; }`。
       - **“信号” (Signal)**：指代由 $N$ 个复数点组成的序列。
       - **运算代价**：复数运算比实数运算昂贵。
         - 一次复数乘法 $(a+jb)(c+jd)$ 涉及 **4 次实数乘法** 和 **2 次实数加法**。

  2. 算法核心策略：分治法 (Divide and Conquer)

     FFT 之所以快，是因为它放弃了 $O(N^2)$ 的直接硬算，而是采用了**“拆解-求解-合成”**的递归/分治策略：

     1. **分解 (Decompose) —— 向下钻**
        - 将 $N$ 点的大信号，层层拆解，直到变成 $N$ 个**只有 1 个点**的小信号。
        - *注*：这一步对应后续的“位反转排序 (Bit Reversal Sorting)”。
     2. **求解 (Calculate) —— 基准情况**
        - 计算这 $N$ 个单点信号的频谱。
        - *原理*：对于只有 1 个点的信号，其频谱就是它自身（无需计算）。这是递归的终点（Base Case）。
     3. **合成 (Synthesize) —— 向上浮**
        - 将这些微小的频谱，两两结合，计算出 $N/2$ 点的频谱，再继续结合...
        - 最终还原成一个完整的 $N$ 点频谱。
        - *注*：这一步对应后续的“蝴蝶运算 (Butterfly Operation)”。