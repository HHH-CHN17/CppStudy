[ç°ä»£C++å¹¶å‘ç¼–ç¨‹æ•™ç¨‹ | ç°ä»£C++å¹¶å‘ç¼–ç¨‹æ•™ç¨‹](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/)

# åŸºæœ¬æ¦‚å¿µ

## å‰è¨€

- å¹¶å‘ï¼Œå¹¶è¡Œï¼Œçº¿ç¨‹ï¼Œè¿›ç¨‹

  - çº¿ç¨‹æ˜¯è½»é‡çº§è¿›ç¨‹ï¼Œæœ¬è¯¾ç¨‹ä»…è®¨è®ºçº¿ç¨‹çŸ¥è¯†
  - å¹¶å‘ï¼šæŒ‡ä¸€ä¸ªå¤„ç†å™¨åŒæ—¶å¤„ç†å¤šä¸ªä»»åŠ¡ã€‚
    å¹¶è¡Œï¼šæŒ‡å¤šä¸ªå¤„ç†å™¨æˆ–è€…æ˜¯å¤šæ ¸çš„å¤„ç†å™¨åŒæ—¶å¤„ç†å¤šä¸ªä¸åŒçš„ä»»åŠ¡ã€‚
    å¹¶å‘æ˜¯é€»è¾‘ä¸Šçš„åŒæ—¶å‘ç”Ÿï¼ˆsimultaneousï¼‰ï¼Œè€Œå¹¶è¡Œæ˜¯ç‰©ç†ä¸Šçš„åŒæ—¶å‘ç”Ÿã€‚

    æ‰€ä»¥è¯´å¯¹äºè¿›ç¨‹æ¥è¯´ï¼Œå¯ä»¥å¹¶å‘ï¼Œä¹Ÿå¯ä»¥å¹¶è¡Œï¼›å¯¹äºçº¿ç¨‹æ¥è¯´ï¼Œä¹Ÿä¸€æ ·éƒ½å¯ä»¥ï¼Œä»å†™ä»£ç çš„è§’åº¦æ¥è¯´ï¼Œå¹¶å‘å’Œå¹¶è¡Œæ²¡å•¥åŒºåˆ«ï¼Œå¯ä»¥å½“æˆä¸€ä¸ªä¸œè¥¿

# ä½¿ç”¨çº¿ç¨‹

## Hello World

```c++
#include <iostream>
#include <thread>  // å¼•å…¥çº¿ç¨‹æ”¯æŒå¤´æ–‡ä»¶

void hello(){     // å®šä¹‰ä¸€ä¸ªå‡½æ•°ç”¨ä½œæ‰“å°ä»»åŠ¡
    std::cout << "Hello World" << std::endl;
}

int main(){
    std::thread t{ hello };		    // åˆ›å»ºçº¿ç¨‹å¯¹è±¡ï¼Œå¹¶å°†è¯¥å¯¹è±¡å…³è”åˆ°ä¸€ä¸ªçº¿ç¨‹èµ„æºä¸Š
    cout << t.joinable() << endl;	// trueï¼Œè¡¨ç¤ºå½“å‰å¯¹è±¡tå…³è”äº†ä¸€ä¸ªæ´»è·ƒçº¿ç¨‹
    t.join();		// é˜»å¡ï¼Œå¹¶ç­‰å¾…tå¯¹åº”çš„çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œæ‰§è¡Œå®Œæ¯•åä¼šå°†joinable()ä¸­çš„å€¼è®¾ä¸ºfalse
    cout << t.joinable() << endl;	// flaseï¼Œè¡¨ç¤ºå½“å‰å¯¹è±¡tæ²¡æœ‰å…³è”ä¸€ä¸ªæ´»è·ƒçº¿ç¨‹
  
    std::thread t1{ };		// é»˜è®¤æ„é€ åˆ›å»ºçº¿ç¨‹å¯¹è±¡ï¼Œä½†æ˜¯ä¸ä¼šå…³è”åˆ°å…·ä½“çš„çº¿ç¨‹èµ„æºä¸Š
    cout << t1.joinable() << endl;	// false
}
```

è§£æï¼š

- `std::thread t{ hello };` åˆ›å»ºäº†ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡ `t`ï¼Œå°† `hello` ä½œä¸ºå®ƒçš„[å¯è°ƒç”¨(Callable)]([https://blog.csdn.net/qq_43145072/article/details/103749956)å¯¹è±¡**ï¼ˆæ­¤å¤„æˆ‘ç†è§£ä¸ºå‡½æ•°æŒ‡é’ˆå’Œ[é—­åŒ…ç±»çš„å¯¹è±¡](https://blog.csdn.net/skdkjzz/article/details/43968449)ï¼‰**åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œã€‚**çº¿ç¨‹å¯¹è±¡å…³è”äº†ä¸€ä¸ªçº¿ç¨‹èµ„æº**ï¼Œåœ¨çº¿ç¨‹å¯¹è±¡æ„é€ æˆåŠŸåï¼Œå°±è‡ªåŠ¨åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œå‡½æ•° `hello`ã€‚
- ï¼ˆçœ‹ã€ŠC++å¹¶å‘ç¼–ç¨‹ã€‹p24ï¼‰å¯åŠ¨äº†çº¿ç¨‹ï¼Œä½ éœ€è¦æ˜ç¡®æ˜¯è¦ç­‰å¾…çº¿ç¨‹ç»“æŸï¼ˆåŠ å…¥å¼ï¼‰ï¼Œè¿˜æ˜¯è®©å…¶è‡ªä¸»è¿è¡Œï¼ˆåˆ†ç¦»å¼ï¼‰ã€‚å¦‚æœ `std::thread` å¯¹è±¡é”€æ¯ä¹‹å‰è¿˜æ²¡æœ‰åšå‡ºå†³å®šï¼Œç¨‹åºå°±ä¼šç»ˆæ­¢ï¼ˆ `std::thread` çš„ææ„å‡½æ•°ä¼šè°ƒç”¨ `std::terminate()` ï¼‰ã€‚
- `t.join();` ç­‰å¾…çº¿ç¨‹å¯¹è±¡ `t` å…³è”çš„çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œå¦åˆ™å°†ä¸€ç›´é˜»å¡ã€‚è¿™é‡Œçš„è°ƒç”¨æ˜¯å¿…é¡»çš„ï¼Œ**å› ä¸ºç¨‹åºç»“æŸæ—¶ï¼Œç›¸å…³è”çš„å­çº¿ç¨‹èµ„æºå¿…é¡»é‡Šæ”¾**ï¼Œå¦‚æœä¸è°ƒç”¨ï¼Œ`std::thread` çš„ææ„å‡½æ•°å°†è°ƒç”¨ [`std::terminate()`](https://zh.cppreference.com/w/cpp/error/terminate) æ— æ³•æ­£ç¡®ææ„ã€‚
- è¿™æ˜¯å› ä¸ºæˆ‘ä»¬åˆ›å»ºçº¿ç¨‹å¯¹è±¡ `t` çš„æ—¶å€™å°±å…³è”äº†ä¸€ä¸ªæ´»è·ƒçš„çº¿ç¨‹ï¼Œè°ƒç”¨ `join()` å°±æ˜¯ç¡®ä¿çº¿ç¨‹å¯¹è±¡å…³è”çš„çº¿ç¨‹å·²ç»æ‰§è¡Œå®Œæ¯•ï¼Œç„¶åä¼šä¿®æ”¹å¯¹è±¡çš„çŠ¶æ€ï¼Œè®© [`std::thread::joinable()`](https://zh.cppreference.com/w/cpp/thread/thread/joinable) è¿”å› `false`ï¼Œè¡¨ç¤ºçº¿ç¨‹å¯¹è±¡ç›®å‰æ²¡æœ‰å…³è”æ´»è·ƒçº¿ç¨‹ã€‚`std::thread` çš„ææ„å‡½æ•°ï¼Œæ­£æ˜¯é€šè¿‡ `joinable()` åˆ¤æ–­çº¿ç¨‹å¯¹è±¡ç›®å‰æ˜¯å¦æœ‰å…³è”æ´»è·ƒçº¿ç¨‹ï¼Œå¦‚æœä¸º `true`ï¼Œé‚£ä¹ˆå°±å½“åšæœ‰å…³è”æ´»è·ƒçº¿ç¨‹ã€‚**æ˜¾ç„¶åœ¨threadç±»å¯¹è±¡ææ„æ—¶ï¼Œå…¶å¯¹åº”çš„çº¿ç¨‹ä¾ç„¶æ´»è·ƒæ˜¯ä¸æ­£å¸¸çš„**ï¼Œæ‰€ä»¥ä¼šè°ƒç”¨ `std::terminate()`**ï¼ˆåœ¨noexceptä¿®é¥°çš„å‡½æ•°ä¸­æŠ›å‡ºå¼‚å¸¸æ—¶ä¹Ÿä¼šè°ƒç”¨è¯¥å‡½æ•°ï¼‰**ã€‚

## å½“å‰ç¯å¢ƒæ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°

[çœ‹è¿™é‡Œï¼šå½“å‰ç¯å¢ƒæ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02ä½¿ç”¨çº¿ç¨‹.html#å½“å‰ç¯å¢ƒæ”¯æŒå¹¶å‘çº¿ç¨‹æ•°)

ä½¿ç”¨ [`hardware_concurrency`](https://zh.cppreference.com/w/cpp/thread/thread/hardware_concurrency) å‡½æ•°å¯ä»¥è·å¾—æˆ‘ä»¬å½“å‰ç¡¬ä»¶æ”¯æŒçš„å¹¶å‘çº¿ç¨‹æ•°é‡ï¼Œå®ƒæ˜¯ `std::thread` çš„é™æ€æˆå‘˜å‡½æ•°ã€‚

é’ˆå¯¹å¹¶è¡Œæ±‚å’Œçš„å‡½æ•°ï¼Œåªéœ€è¦æ³¨æ„ä¸€ä¸ªç‚¹ï¼š

```c++
for (std::size_t i = 0; i < num_threads; ++i) {
            auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0));
            threads.emplace_back([start, end, &results, i] {
                results[i] = std::accumulate(start, end, value_type{});
            });
```

å…¶ä¸­ï¼Œåœ¨ç¬¬ä¸‰è¡Œçš„åœ°æ–¹åˆ›å»ºå¹¶å¯åŠ¨äº†çº¿ç¨‹ï¼Œä¸”è¯¥çº¿ç¨‹çš„å¯è°ƒç”¨å¯¹è±¡æ˜¯ä¸€ä¸ªlambdaå‡½æ•°ã€‚

emplace_backæ˜¯ä¸€ä¸ªå‡½æ•°æ¨¡æ¿ï¼Œå‚æ•°æ˜¯å½¢å‚åŒ…ï¼Œå°†å‚æ•°å…¨éƒ¨å®Œç¾è½¬å‘åˆ°å†…éƒ¨ï¼Œç„¶åä½¿ç”¨placement newï¼ˆ`new(&threads[index]) thread(lambda)`ï¼‰åœ¨threadsçš„å°¾éƒ¨è°ƒç”¨threadçš„æœ‰å‚æ„é€ å‡½æ•°åŸåœ°æ„é€ çº¿ç¨‹å¯¹è±¡å¹¶å¯åŠ¨çº¿ç¨‹

## çº¿ç¨‹ç®¡ç†

åœ¨ C++ æ ‡å‡†åº“ä¸­ï¼Œæ²¡æœ‰ç›´æ¥ç®¡ç†çº¿ç¨‹çš„æœºåˆ¶ï¼Œåªèƒ½é€šè¿‡å¯¹è±¡å…³è”çº¿ç¨‹åï¼Œ**é€šè¿‡è¯¥å¯¹è±¡æ¥ç®¡ç†çº¿ç¨‹**ã€‚ç±» `std::thread` çš„å¯¹è±¡å°±æ˜¯æŒ‡ä»£çº¿ç¨‹çš„å¯¹è±¡ï¼Œè€Œæˆ‘ä»¬æœ¬èŠ‚è¯´çš„â€œçº¿ç¨‹ç®¡ç†â€ï¼Œå…¶å®ä¹Ÿå°±æ˜¯æŒ‡ç®¡ç† `std::thread` å¯¹è±¡ã€‚ï¼ˆè¿™å¥è¯å¾ˆå…³é”®ï¼Œå¥½å¥½ç†è§£ï¼‰

### å¯åŠ¨æ–°çº¿ç¨‹

[å…·ä½“ç»†èŠ‚çœ‹è¿™é‡Œ](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02ä½¿ç”¨çº¿ç¨‹.html#å¯åŠ¨æ–°çº¿ç¨‹)

#### é»˜è®¤æ„é€ 

```c++
std::thread t; //  æ„é€ ä¸è¡¨ç¤ºçº¿ç¨‹çš„æ–° std::thread å¯¹è±¡
```

**é»˜è®¤æ„é€ **ï¼Œ`std::thread` çº¿ç¨‹å¯¹è±¡æ²¡æœ‰å…³è”çº¿ç¨‹ï¼Œä¹Ÿä¸ä¼šå¯åŠ¨çº¿ç¨‹æ‰§è¡Œä»»åŠ¡callableï¼Œåç»­ä¼šè®²åˆ°ï¼Œç°åœ¨æ²¡å•¥ç”¨

#### æœ‰å‚æ„é€ 

æƒ³è¦æ„é€ çš„å¯¹è±¡èƒ½å¯åŠ¨çº¿ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ„é€ æ—¶ä¼ é€’ä¸€ä¸ª `å¯è°ƒç”¨ï¼ˆcallableï¼‰å¯¹è±¡`ã€‚åœ¨ä¹‹å‰ï¼Œæˆ‘ä»¬ä¼ é€’çš„å‚æ•°æœ‰ `å‡½æ•°åï¼ˆå°±æ˜¯å‡½æ•°æŒ‡é’ˆï¼‰`ï¼Œ[#lambdaè¡¨è¾¾å¼](../2-æ·±å…¥ç†è§£C++11/æ·±å…¥ç†è§£C++11.md#lambdaå‡½æ•°)ï¼Œå½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä¼ é€’ `å‡½æ•°å¯¹è±¡`ï¼š

```c++
class Task{
public:
	void operator()()const {
		std::cout << "operator()()const\n";
	}
};

int main() {
	thread t(Task());	// è¯­ä¹‰åˆ†æä¸­ï¼Œè¯¥è¯­å¥è¢«è®¤ä¸ºæ˜¯å‡½æ•°ç”³æ˜
	t.join();
}
```

Oopsï¼ç¼–è¯‘å¤±è´¥äº†ï¼Œç¼–è¯‘å™¨ä¼šå°†ç¬¬9è¡Œè§£æä¸ºå‡½æ•°å£°æ˜ï¼Œè€Œä¸æ˜¯ç±»å‹å¯¹è±¡çš„å®šä¹‰

- åŸå› ï¼š

  - å…ˆçœ‹çœ‹æˆ‘ä»¬æœ€ç†Ÿæ‚‰çš„å‡½æ•°ç”³æ˜ï¼š

    ```c++
    int test(int);
    ```

    å…¶ä¸­å‚æ•°åˆ—è¡¨ä¸­ï¼Œåªæœ‰å½¢å‚ç±»å‹ï¼Œæ²¡æœ‰å½¢å‚åç§°ï¼Œæ˜¯ä¸€ä¸ªå ä½å‚æ•°ï¼Œå¾ˆå¥½ç†è§£
  - å†æ¥çœ‹çœ‹ç¬¬ä¹è¡Œï¼š

    ```c++
    thread t(Task());
    ```

    `thread`ï¼šå‡½æ•°è¿”å›ç±»å‹

    `t`ï¼šå‡½æ•°åç§°

    `Task()`ï¼šå‡½æ•°å½¢å‚ç±»å‹ï¼Œæ˜¯ä¸ªå ä½å‚æ•°ï¼Œåˆ†æå¦‚ä¸‹ï¼š

    - `int a`ï¼š`a`ä¸º `int`ç±»å‹ï¼Œå…¶ä¸­ `int`è¡¨ç¤ºç±»å‹åï¼Œ`a`è¡¨ç¤ºå£°æ˜çš„å…·ä½“å˜é‡
    - `Task (*p)()`ï¼š`p`ä¸ºå‡½æ•°æŒ‡é’ˆç±»å‹ï¼Œå…¶ä¸­ `Task(*)()`è¡¨ç¤ºç±»å‹åï¼Œ`p`è¡¨ç¤ºå£°æ˜çš„å…·ä½“å˜é‡
    - `Task p()`ï¼šå‡½æ•°ç±»å‹å£°æ˜ï¼Œ`p`ä¸ºå‡½æ•°ç±»å‹ï¼Œå…¶ä¸­ `Task()`è¡¨ç¤ºç±»å‹åï¼Œ`p`è¡¨ç¤ºå£°æ˜çš„å…·ä½“å˜é‡

    æ‰€ä»¥ä½ å‘ç°äº†ï¼Œ`thread t(Task())`ç›¸å½“äº `thread t(Task p())`ã€‚ä½†è¿™å¹¶ä¸å‡†ç¡®ï¼Œå®é™…ä¸Šæ˜¯ç›¸å½“äº `thread t(Task (*p)())`ï¼Œè¿™æ˜¯å› ä¸ºï¼š

    > åœ¨ç¡®å®šæ¯ä¸ªå½¢å‚çš„ç±»å‹åï¼Œç±»å‹æ˜¯ â€œT çš„æ•°ç»„â€æˆ–æŸä¸ª**å‡½æ•°ç±»å‹ T çš„å½¢å‚ä¼šè°ƒæ•´ä¸ºå…·æœ‰ç±»å‹â€œæŒ‡å‘ T çš„æŒ‡é’ˆâ€**ã€‚[æ–‡æ¡£](https://zh.cppreference.com/w/cpp/language/function#.E5.BD.A2.E5.8F.82.E7.B1.BB.E5.9E.8B.E5.88.97.E8.A1.A8)ã€‚
    >
    > ```c++
    > void test(int a[]) {
    > 	cout << sizeof(a) << endl;	// 8ï¼Œaä»int[]è¢«è°ƒæ•´ä¸ºäº†int*
    > }
    > 
    > void test1(int (&a)[4]){
    >     cout << sizeof(a) << endl;	// 16ï¼Œä½¿ç”¨å¼•ç”¨å¯ä»¥é¿å…ç±»å‹è°ƒæ•´ï¼Œä¸è¿‡å‡½æ•°å½¢å‚ç±»å‹ä¸èƒ½å†™æˆint (&a)[]ï¼Œå› ä¸ºå®å‚ç±»å‹ä¸ºint[4]ï¼Œå¯¹äºç¼–è¯‘å™¨æ¥è¯´ï¼Œint[4]å’Œint[]æ˜¯ä¸åŒç±»å‹ã€‚
    > }
    > 
    > int main() {
    > 	int a[] = {1,2,3,4};
    > 	cout << sizeof(a) << endl;	// 16
    > 	test(a);
    > 	test1(a);
    > }
    > ```
    >
    > æ‹“å±•çŸ¥è¯†ï¼š[#ç±»å‹é€€åŒ–](#decayç±»å‹é€€åŒ–)
    
    æ˜¾ç„¶ `Task()`æ˜¯ä¸ªå‡½æ•°ç±»å‹ï¼Œå®ƒè¢«è°ƒæ•´ä¸ºäº†æŒ‡å‘è¿™ä¸ªå‡½æ•°ç±»å‹çš„æŒ‡é’ˆç±»å‹ï¼š`Task(*)()`ã€‚
  - æ€»ç»“ï¼š
  
    é€šè¿‡ä¸Šé¢åˆ†æï¼Œä½ ä¼šå‘ç° `int test(int)`å’Œ `thread t(Task())`éƒ½æ˜¯åªæœ‰ä¸€ä¸ªå ä½å‚æ•°çš„å‡½æ•°å£°æ˜ï¼Œå¾ˆå¥½ç†è§£ã€‚
- è§£å†³åŠæ³•ï¼š

  - threadåˆå§‹åŒ–æ—¶ä½¿ç”¨[#åˆ—è¡¨åˆå§‹åŒ–](../2-æ·±å…¥ç†è§£C++11/æ·±å…¥ç†è§£C++11.md#C++11åˆ—è¡¨åˆå§‹åŒ–)ï¼š

    ```c++
    thread t{Task()};
    ```

    ä½†æ³¨æ„ï¼Œæˆ‘ä»¬å¹³æ—¶ä½¿ç”¨åˆ—è¡¨åˆå§‹åŒ–æ—¶ï¼Œå¦‚æœç±»ä¸­æœ‰å®šä¹‰ `å‚æ•°ä¸ºinitializer_listçš„æ„é€ å‡½æ•°`ï¼Œåˆ™ä¼šä¼˜å…ˆè°ƒç”¨æ­¤æ„é€ ï¼Œè€Œéå¤šå‚æ„é€ å‡½æ•°ã€‚
  - ä½¿ç”¨æ‹¬å·è¡¨è¾¾å¼ï¼š

    ```c++
    thread t((Task()));
    ```

#### çº¿ç¨‹çš„æ‰§è¡Œç­–ç•¥

å¯åŠ¨çº¿ç¨‹åï¼ˆä¹Ÿå°±æ˜¯æ„é€  `std::thread` å¯¹è±¡ï¼‰æˆ‘ä»¬å¿…é¡»åœ¨çº¿ç¨‹å¯¹è±¡çš„ç”Ÿå­˜æœŸç»“æŸä¹‹å‰ï¼Œå³ [`std::thread::~thread`](https://zh.cppreference.com/w/cpp/thread/thread/~thread) è°ƒç”¨ä¹‹å‰ï¼Œå†³å®šå®ƒçš„æ‰§è¡Œç­–ç•¥ï¼Œæ˜¯ [`join()`](https://zh.cppreference.com/w/cpp/thread/thread/join)ï¼ˆåŠ å…¥ï¼Œå¯ä»¥ç†è§£æˆå°†å­çº¿ç¨‹åŠ å…¥/åˆå¹¶è¿›å½“å‰çº¿ç¨‹ï¼Œä½¿å¾—å½“å‰çº¿ç¨‹çš„ç»“æŸæ—¶é—´ç”±ä¸¤è€…ä¸­æœ€æ™šç»“æŸçš„é‚£ä¸ªçº¿ç¨‹å†³å®šï¼‰è¿˜æ˜¯ [`detach()`](https://zh.cppreference.com/w/cpp/thread/thread/detach)ï¼ˆåˆ†ç¦»ï¼Œå³å½“å‰çº¿ç¨‹å’Œå­çº¿ç¨‹åˆ†ç¦»ï¼‰ã€‚

æˆ‘ä»¬å…ˆå‰ä½¿ç”¨çš„å°±æ˜¯ `join()`ï¼Œæˆ‘ä»¬èŠä¸€ä¸‹ `detach()`ï¼Œå½“ `std::thread` çº¿ç¨‹å¯¹è±¡è°ƒç”¨äº† `detach()`ï¼Œé‚£ä¹ˆå°±æ˜¯**çº¿ç¨‹å¯¹è±¡æ”¾å¼ƒäº†å¯¹çº¿ç¨‹èµ„æºçš„æ‰€æœ‰æƒï¼Œä¸å†ç®¡ç†æ­¤çº¿ç¨‹ï¼Œå…è®¸æ­¤çº¿ç¨‹ç‹¬ç«‹çš„è¿è¡Œï¼Œåœ¨çº¿ç¨‹é€€å‡ºæ—¶é‡Šæ”¾æ‰€æœ‰åˆ†é…çš„èµ„æº**ã€‚ï¼ˆå¾ˆé‡è¦çš„ä¸€å¥è¯ï¼Œå¥½å¥½ç†è§£ï¼‰

æ”¾å¼ƒäº†å¯¹çº¿ç¨‹èµ„æºçš„æ‰€æœ‰æƒï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹å¯¹è±¡æ²¡æœ‰å…³è”æ´»è·ƒçº¿ç¨‹äº†ï¼Œæ­¤æ—¶ joinable ä¸º **`false`**ã€‚

åœ¨å•çº¿ç¨‹çš„ä»£ç ä¸­ï¼Œå¯¹è±¡é”€æ¯ä¹‹åå†å»è®¿é—®ï¼Œä¼šäº§ç”Ÿ[æœªå®šä¹‰è¡Œä¸º](https://zh.cppreference.com/w/cpp/language/ub)ï¼Œå¤šçº¿ç¨‹å¢åŠ äº†è¿™ä¸ªé—®é¢˜å‘ç”Ÿçš„å‡ ç‡ã€‚

æ¯”å¦‚å‡½æ•°ç»“æŸï¼Œé‚£ä¹ˆå‡½æ•°å±€éƒ¨å¯¹è±¡çš„ç”Ÿå­˜æœŸéƒ½å·²ç»ç»“æŸäº†ï¼Œéƒ½è¢«é”€æ¯äº†ï¼Œæ­¤æ—¶çº¿ç¨‹å‡½æ•°è¿˜æŒæœ‰å‡½æ•°å±€éƒ¨å¯¹è±¡çš„æŒ‡é’ˆæˆ–å¼•ç”¨ã€‚

```c++
int main() {
	int a = 100;
	thread t([&]() {
		this_thread::sleep_for(2s);
		cout << a << endl;
	});
	t.detach();						// ä¸ä¼šé˜»å¡ï¼Œå¯èƒ½äº§ç”Ÿæ½œåœ¨çš„æœªå®šä¹‰è¡Œä¸º
	cout << t.joinable() << endl;	// æ˜¾ç„¶ï¼Œåˆ†ç¦»åï¼Œå½“å‰çº¿ç¨‹å¯¹è±¡ä¸åœ¨ç®¡ç†åŸæ¥çš„å­çº¿ç¨‹ï¼Œè¾“å‡ºæ˜¾ç„¶ä¸ºfalse
}
// detachä¸ä¼šé˜»å¡ï¼Œå°±æ˜¯çº¿ç¨‹åˆ†ç¦»äº†
// åˆ†ç¦»åå­çº¿ç¨‹å¯èƒ½è¿˜åœ¨æ‰§è¡Œçš„æ—¶å€™ï¼Œä¸»çº¿ç¨‹å·²ç»é”€æ¯é‡Šæ”¾èµ„æºäº†
// å¦‚æœå­çº¿ç¨‹åœ¨ä¸»çº¿ç¨‹ç»“æŸåä¾ç„¶è®¿é—®ä¸»çº¿ç¨‹ä¸­çš„å¯¹è±¡ï¼Œé‚£ä¹ˆå°±æ˜¯æœªå®šä¹‰è¡Œä¸º
// æœ¬ä¾‹ä¸­ï¼Œä½¿ç”¨coutï¼ˆä½äºä¸»çº¿ç¨‹çš„stdä¸­ï¼‰ï¼Œè®¿é—®aï¼ˆä½äºä¸»çº¿ç¨‹çš„mainå‡½æ•°é‡Œï¼‰éƒ½æ˜¯æœªå®šä¹‰è¡Œä¸ºã€‚
```

è¿™é‡Œéœ€è¦ç‚¹åæ‰¹è¯„å‡ ç§è ¢å¾—æ­»è¡Œä¸ºï¼š

- `join()`ååˆ `detach()`

  äººå®¶ `join()`æœ¬æ¥å°±æ˜¯ç­‰å¾…çº¿ç¨‹æ‰§è¡Œç»“æŸçš„ï¼Œçº¿ç¨‹éƒ½æ‰§è¡Œç»“æŸäº†ï¼Œå°±æ²¡å¿…è¦ `detach()`äº†
- `detach()`ååˆ `join()`

  `detach()`åå­çº¿ç¨‹å’Œä¸»çº¿ç¨‹ä¸­çš„çº¿ç¨‹å¯¹è±¡éƒ½åˆ†ç¦»äº†ï¼Œå†æ¥ `join()`æœ‰ä»€ä¹ˆæ„ä¹‰å—

#### å¼‚å¸¸

```c++
struct Task; // å¤ç”¨ä¹‹å‰
void f(){
	int n = 0;
	thread t{ Task{} };
	try{
		throw exception();	// æŠ›å‡ºå¼‚å¸¸
	}
	catch (exception& e){
		t.join(); // 1
		throw e;			// catchä½å¼‚å¸¸åè¦å†æ¬¡æŠ›å‡º
	}
	t.join();    // 2
}

int main() {
	try {
		f();
	}
	catch (...) {
		cout << "å¼‚å¸¸" << endl;
	}
}
```

è§£é‡Šï¼š

- ä¸èƒ½é€šè¿‡ä¸»çº¿ç¨‹æ¥å¤„ç†å­çº¿ç¨‹çš„å¼‚å¸¸ï¼Œå¼‚å¸¸å¤„ç†æ˜¯çº¿ç¨‹è‡ªå·±çš„äº‹

  ```c++
  void f(){
  	int n = 0;
  	try{
  		thread t{ Task{} };		// ç¼–è¯‘é”™è¯¯
  	}
  	catch (exception& e){
  		t.join(); // 1
  		throw e;			// catchä½å¼‚å¸¸åè¦å†æ¬¡æŠ›å‡º
  	}
  	t.join();    // 2
  }
  ```

- ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ä¸ª`t.join()`ï¼Œä¸ºä»€ä¹ˆcatchä½å¼‚å¸¸åéœ€è¦å†æ¬¡æŠ›å‡º

  ç¬¬ä¸€ä¸ª`t.join()`ç”¨äºç¡®ä¿åœ¨**catchä½å¼‚å¸¸å**ï¼Œå­çº¿ç¨‹æ­£å¸¸æ‰§è¡Œå®Œæˆï¼Œçº¿ç¨‹å¯¹è±¡æ­£å¸¸ææ„

  ç¬¬äºŒä¸ª`t.join()`ç”¨äºç¡®ä¿åœ¨**ä¸å‘ç”Ÿå¼‚å¸¸æ—¶**ï¼Œå­çº¿ç¨‹æ­£å¸¸æ‰§è¡Œå®Œæˆï¼Œçº¿ç¨‹å¯¹è±¡æ­£å¸¸ææ„

  `throw e`ç”¨äºä¿è¯åœ¨æ‰§è¡Œå®Œç¬¬ä¸€ä¸ª`t.join()`åï¼Œä¸ä¼šæ‰§è¡Œåˆ°ç¬¬äºŒä¸ª`t.join()`

- å½“ç„¶ä¹Ÿå¯ä»¥æ”¹æˆè¿™æ ·ï¼š

  ```c++
  void f(){
  	int n = 0;
  	thread t{ Task{} };
  	try{
  		throw exception();		// æŠ›å‡ºå¼‚å¸¸
  	}
  	catch (exception& e){
  		t.join(); // 1
  		cout << "å¼‚å¸¸" << endl;	// åœ¨å½“å‰å‡½æ•°å°±å¤„ç†äº†å¼‚å¸¸
  	}
  	
  	if (t.joinable()) {		// å…ˆåˆ¤æ–­ä¸€ä¸‹èƒ½ä¸èƒ½join()
  		t.join();    // 2
  	}
  }
  
  ```

### RAII

â€œ[èµ„æºè·å–å³åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/raii)â€(RAIIï¼ŒResource Acquisition Is Initialization)ã€‚

ç®€å•çš„è¯´æ˜¯ï¼š***æ„é€ å‡½æ•°ç”³è¯·èµ„æºï¼Œææ„å‡½æ•°é‡Šæ”¾èµ„æºï¼Œè®©å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå’Œèµ„æºç»‘å®š***ã€‚å½“å¼‚å¸¸æŠ›å‡ºæ—¶ï¼ŒC++ ä¼šè‡ªåŠ¨è°ƒç”¨å¯¹è±¡çš„ææ„å‡½æ•°ã€‚

```c++
class thread_guard{
private:
	std::thread m_Thr;
public:
	template<typename Callable_Ty, typename... Args>
	explicit thread_guard(Callable_Ty&& obj, Args&&... args)
			: m_Thr(std::forward<Callable_Ty>(obj), std::forward<Args>(args)...)
	{}

	~thread_guard(){
		if (m_Thr.joinable()) { // çº¿ç¨‹å¯¹è±¡å½“å‰å…³è”äº†æ´»è·ƒçº¿ç¨‹
			m_Thr.join();
		}
	}
	thread_guard(const thread_guard&) = delete;
	thread_guard& operator=(const thread_guard&) = delete;
};
```

è§£é‡Šï¼š

- å“ˆå“ˆè¿™æ˜¯æˆ‘è‡ªå·±å†™çš„ï¼Œå¼å§
- æ„é€ å‡½æ•°ä½¿ç”¨[#å®Œç¾è½¬å‘](../2-æ·±å…¥ç†è§£C++11/æ·±å…¥ç†è§£C++11.md#å®Œç¾è½¬å‘ï¼Ÿï¼Ÿï¼Ÿ)æ¥åˆ›é€ çº¿ç¨‹å¯¹è±¡ï¼Œä¿è¯æ—¶é—´æ¶ˆè€—å°‘ï¼Œ
- ææ„å‡½æ•°ç”¨äºåˆ¤æ–­è¯¥å‡½æ•°æ˜¯å¦èƒ½`join()`ï¼Œå¹¶åœ¨`ææ„å‡½æ•°`ä¸­ç­‰å¾…ç›‘æ§çš„å­çº¿ç¨‹`m_Thr`æ‰§è¡Œå®Œæ¯•
- å¤åˆ¶èµ‹å€¼å’Œå¤åˆ¶æ„é€ å®šä¹‰ä¸º `=delete` ï¼Œæ˜¾ç„¶å¦‚æœ`thread_guard`èƒ½è¢«å¤åˆ¶ï¼Œåˆ™`thread`ä¹Ÿä¼šè¢«è·Ÿç€å¤åˆ¶ï¼Œè¿™æ˜¯è‚¯å®šä¸è¡Œçš„ï¼Œ**ä¸€ä¸ª`çº¿ç¨‹èµ„æº`åªèƒ½è¢«ä¸€ä¸ª`çº¿ç¨‹ç±»å¯¹è±¡`ç®¡ç†ç›‘è§†ï¼Œä¸€ä¸ª`çº¿ç¨‹ç±»å¯¹è±¡`ä¹Ÿåªèƒ½ç®¡ç†ä¸€ä¸ª`çº¿ç¨‹èµ„æº`**ã€‚
- é€šè¿‡ä½¿ç”¨RAIIï¼Œæˆ‘ä»¬å°±ä¸ç”¨åƒä¸Šä¸€èŠ‚é‚£æ ·å†™å¤šä¸ª`join()`äº†

ä½¿ç”¨ï¼š

```c++
void f(){
    int n = 0;
    thread_guard tg{ func{n}, 10 };
    throw exception();
}

int main() {
    try {
       f();
    }
    catch (exception e) {
       cout << "å¼‚å¸¸" << endl;
    }
    //f();	
}
```

æ³¨æ„åªæœ‰åœ¨æŠ›å‡ºçš„å¼‚å¸¸è¢«æ•è·æ—¶ï¼Œthread_guardçš„ææ„å‡½æ•°æ‰ä¼šè¢«è°ƒç”¨

### decayç±»å‹é€€åŒ–

[std::decay - cppreference.com](https://zh.cppreference.com/w/cpp/types/decay)

- å®šä¹‰

  - å¤´æ–‡ä»¶ `<type_traits>`

    ```c++
    template< class T >
    struct decay; // (since C++11)
    ```

  - è¾…åŠ©ç±»å‹
    ```c++
    template< class T >
    using decay_t = typename decay<T>::type; // (since C++14)
    ```

- ä½œç”¨

  è¿›è¡Œç­‰ä»·äº**æŒ‰å€¼ä¼ é€’å‡½æ•°å®å‚**æ—¶è¿›è¡Œçš„ç±»å‹è½¬æ¢ã€‚æ­£å¼è€Œè¨€ï¼š

  - å¦‚æœ `T` æ˜¯â€œ`U` çš„æ•°ç»„â€æˆ–åˆ°å®ƒçš„å¼•ç”¨ï¼Œé‚£ä¹ˆæˆå‘˜ `typedef type` æ˜¯ `U*`ã€‚

  - å¦åˆ™ï¼Œå¦‚æœ `T` æ˜¯å‡½æ•°ç±»å‹ `F` æˆ–åˆ°å®ƒçš„å¼•ç”¨ï¼Œé‚£ä¹ˆæˆå‘˜ `typedef type` æ˜¯ `std::add_pointer<F>::type`ã€‚

  - å¦åˆ™ï¼Œæˆå‘˜ `typedef type` æ˜¯ `std::remove_cv<std::remove_reference<T>::type>::type`ã€‚

  å¦‚æœç¨‹åºæ·»åŠ äº† `std::decay` çš„ç‰¹åŒ–ï¼Œé‚£ä¹ˆè¡Œä¸ºæœªå®šä¹‰ã€‚

- å®ç°ï¼ˆè¦å…ˆçœ‹æ‡‚ä½œç”¨ï¼Œå†å¸¦ç€å¯¹ä½œç”¨çš„ç†è§£çœ‹å®ç°ï¼‰

  ```c++
  // cppreference
  template<class T>
  struct decay
  {
  private:
      typedef typename std::remove_reference<T>::type U;
  public:
      typedef typename std::conditional< 
          std::is_array<U>::value,
          typename std::add_pointer<typename std::remove_extent<U>::type>::type,
          typename std::conditional< 
              std::is_function<U>::value,
              typename std::add_pointer<U>::type,
              typename std::remove_cv<U>::type
          >::type
      >::type type;
  };
  // MSVC
  template <class _Ty>
  struct decay { // determines decayed version of _Ty
      using _Ty1 = remove_reference_t<_Ty>;
      using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
      using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
  };
  ```

- ä½¿ç”¨ç¤ºä¾‹ï¼š

  ```c++
  #include <iostream>
  #include <type_traits>
   
  template <typename T, typename U>
  struct decay_equiv : 
      std::is_same<typename std::decay<T>::type, U>::type 
  {};
   
  int main()
  {
      std::cout << std::boolalpha
                << decay_equiv<int, int>::value << '\n'    // æƒ…å†µ3
                << decay_equiv<int&, int>::value << '\n'  // æƒ…å†µ3
                << decay_equiv<int&&, int>::value << '\n'  // æƒ…å†µ3
                << decay_equiv<const int&, int>::value << '\n'  // æƒ…å†µ3
                << decay_equiv<int[2], int*>::value << '\n' // æƒ…å†µ1
                << decay_equiv<int(int), int(*)(int)>::value << '\n'; // æƒ…å†µ2
  }
  ```

### ä¼ é€’å‚æ•°

> - ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸è®ºçº¿ç¨‹å‡½æ•°ä¸­çš„å‚æ•°ç±»å‹æ˜¯å¦ä¸ºå¼•ç”¨ï¼Œåœ¨å‚æ•°ä¼ é€’æ—¶éƒ½æ˜¯å…ˆä½¿ç”¨[`decay_t`](https://zh.cppreference.com/w/cpp/types/decay)ç¡®å®šé€€åŒ–åçš„å‚æ•°ç±»å‹ï¼Œç„¶åé€šè¿‡å¤åˆ¶æ„é€ å‡½æ•°/ç§»åŠ¨æ„é€ å‡½æ•°æ„é€ å‡ºä¸€ä¸ªæ–°çš„[é€€åŒ–åçš„çº¯å³å€¼å‰¯æœ¬](https://zh.cppreference.com/w/cpp/standard_library/decay-copy)ï¼ˆä¹Ÿå°±æ˜¯`decay_t`ä¸­è·å¾—çš„ç±»å‹ï¼‰ï¼Œå­˜å…¥`tuple`ä¸­ï¼Œå¹¶å°†æŒ‡é’ˆä¼ ç»™`unique_ptr`ï¼Œç„¶åå°†æŒ‡é’ˆä¼ å…¥å­çº¿ç¨‹ä¸­ï¼Œç„¶åå­çº¿ç¨‹å†å°†è¯¥å‰¯æœ¬ä½œä¸ºå‡½æ•°å®å‚ä¼ å…¥å¯è°ƒç”¨å¯¹è±¡ï¼Œæ‰€ä»¥å½“å‡½æ•°å‚æ•°ç±»å‹ä¸ºæ™®é€šç±»å‹`T`å’Œå³å€¼ç±»å‹`T&&`æ—¶ï¼Œå¯ä»¥æŒ‰é¢„æœŸæ­£å¸¸ä½¿ç”¨ï¼Œç±»å‹ä¸º`T&`æ—¶ï¼Œéœ€è¦ä½¿ç”¨`ref()`æ‰è¡Œï¼ˆçœ‹ä¸æ‡‚å…ˆçœ‹ä¸‹é¢ï¼‰
>
>   ```c++
>   void f(int a, move_only&& mo, int& b) { }
>   int main() {
>       move_only mo;	// move_onlyæ˜¯ä¸€ä¸ªåªèƒ½é»˜è®¤æ„é€ ï¼Œç§»åŠ¨æ„é€ çš„ç±»ã€‚
>       int m = 2;
>       std::thread t { f, m, move(mo), ref(m) };
>       t.join();
>   }
>   ```

- å®¹æ˜“å‡ºç°çš„é—®é¢˜

  å‘å¯è°ƒç”¨å¯¹è±¡ä¼ é€’å‚æ•°å¾ˆç®€å•ï¼Œæˆ‘ä»¬å‰é¢ä¹Ÿéƒ½å†™äº†ï¼Œåªéœ€è¦å°†è¿™äº›å‚æ•°ä½œä¸º `std::thread` çš„æ„é€ å‚æ•°å³å¯ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™äº›å‚æ•°ä¼šå¤åˆ¶åˆ°æ–°çº¿ç¨‹çš„å†…å­˜ç©ºé—´ä¸­ï¼Œå³ä½¿å‡½æ•°ä¸­çš„å‚æ•°æ˜¯å¼•ç”¨ï¼Œä¾ç„¶**å®é™…æ˜¯å¤åˆ¶**ã€‚

  ```c++
  void f(int, const int& a) {
      std::cout << &a << '\n'; 
  }
  
  int main() {
      int n = 1;
      std::cout << &n << '\n';
      std::thread t { f, 3, n };
      t.join();
  }
  ```

  é—®é¢˜ï¼š

  - `&a`å’Œ`&n`ä¸¤è€…å€¼ä¸åŒ

    è¯´æ˜åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸»çº¿ç¨‹å‘å­çº¿ç¨‹ä¼ é€’å‚æ•°æ—¶æ˜¯**å€¼ä¼ é€’**

  - å¦‚æœå»æ‰å‡½æ•°`f`ä¸­å‚æ•°`a`çš„constä¿®é¥°ï¼Œåˆ™ç¼–è¯‘å¤±è´¥

    è¿™æ˜¯å› ä¸º `std::thread` å†…éƒ¨ä¼šå°†ä¿æœ‰çš„å‚æ•°å‰¯æœ¬è½¬æ¢ä¸º**å³å€¼è¡¨è¾¾å¼è¿›è¡Œä¼ é€’**ï¼Œè¿™æ˜¯ä¸ºäº†é‚£äº›**åªæ”¯æŒç§»åŠ¨çš„ç±»å‹**ï¼Œå·¦å€¼å¼•ç”¨æ²¡åŠæ³•å¼•ç”¨å³å€¼è¡¨è¾¾å¼ï¼Œæ‰€ä»¥äº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚

    ```c++
    // åªæ”¯æŒé»˜è®¤æ„é€ å’Œç§»åŠ¨æ„é€ 
    struct move_only {
        move_only() { std::puts("é»˜è®¤æ„é€ "); }
        move_only(move_only&&)noexcept {
            std::puts("ç§»åŠ¨æ„é€ ");
        }
        
        move_only(const move_only&) = delete;
    };
    
    void f(move_only mo){}	// çº¿ç¨‹å‡½æ•°
    
    int main(){
        move_only obj;
        std::thread t{ f,std::move(obj) };
        t.join();
    }
    // é»˜è®¤æ„é€ 
    // ç§»åŠ¨æ„é€ 
    // ç§»åŠ¨æ„é€ 
    ```

    æ²¡æœ‰ `std::ref` è‡ªç„¶æ˜¯ä¼šä¿æœ‰ä¸€ä¸ªå‰¯æœ¬ï¼Œæ‰€ä»¥æœ‰ä¸¤æ¬¡ç§»åŠ¨æ„é€ ï¼Œç¬¬ä¸€æ¬¡æ˜¯åœ¨ `std::thread` ä¸­é€šè¿‡ç§»åŠ¨æ„é€ å‡½æ•°ç§»åŠ¨æ„é€ äº†ä¸€ä¸ª`move(obj)`çš„å‰¯æœ¬ï¼Œç¬¬äºŒæ¬¡æ˜¯è°ƒç”¨å‡½æ•° `f`ã€‚

- è§£å†³åŠæ³•ï¼š

  ä½¿ç”¨æ ‡å‡†åº“çš„ [`std::ref`](https://zh.cppreference.com/w/cpp/utility/functional/ref) ã€ `std::cref` å‡½æ•°æ¨¡æ¿

  ```c++
  void f(int, int& a) {
      std::cout << &a << '\n'; 
  }
  
  int main() {
      int n = 1;
      std::cout << &n << '\n';
      std::thread t { f, 3, std::ref(n) };	// ä½¿ç”¨refï¼Œæ­¤æ—¶&aï¼Œ&nä¸¤è€…å€¼ç›¸åŒ
      t.join();
  }
  ```

  è§£é‡Šï¼š

  - `std::ref`(reference)å‡½æ•°æ¨¡æ¿è¿”å›ä¸€ä¸ªåŒ…è£…ç±»`std::reference_wrapper<T>`ï¼Œè¯¥ç±»æ˜¯åŒ…è£…å¼•ç”¨å¯¹è±¡çš„ç±»æ¨¡æ¿ï¼Œå°†å¯¹è±¡åŒ…è£…ï¼Œå¯ä»¥éšå¼è½¬æ¢ä¸ºè¢«åŒ…è£…å¯¹è±¡çš„å¼•ç”¨ï¼ˆåœ¨æœ¬ä¾‹ä¸­ç”¨æ¥åŒ…è£…å¯¹è±¡nï¼Œå¹¶å¯ä»¥éšå¼è½¬æ¢ä¸ºnçš„å¼•ç”¨ï¼‰ã€‚
  - `std::cref`(const reference)åŒç†ï¼Œè¿”å›`std::reference_wrapper<const T>`ï¼Œä¸è¿‡å®ƒæ˜¯è½¬æ¢ä¸ºåŒ…è£…å¯¹è±¡çš„constå¼•ç”¨ã€‚

- åœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œç±»çš„æˆå‘˜å‡½æ•°

  [**æˆå‘˜å‡½æ•°æŒ‡é’ˆ**](https://zh.cppreference.com/w/cpp/language/pointer#.E6.88.90.E5.91.98.E5.87.BD.E6.95.B0.E6.8C.87.E9.92.88)ä¹Ÿæ˜¯[*å¯è°ƒç”¨*](https://zh.cppreference.com/w/cpp/named_req/Callable)(*Callable*)çš„ ï¼Œå¯ä»¥ä¼ é€’ç»™ `std::thread` ä½œä¸ºæ„é€ å‚æ•°ï¼Œè®©å…¶å…³è”çš„çº¿ç¨‹æ‰§è¡Œæˆå‘˜å‡½æ•°ã€‚

  ```c++
  struct X{
      void task_run(int& n)const;
  };
  int main(){
  	X x;
  	int n = 0;
  	std::thread t{ &X::task_run, &x, ref(n) };
  	t.join();
  }
  
  ```

  è§£é‡Šï¼š

  - ç±»çš„æˆå‘˜å‡½æ•°å‰é¢è¦åŠ é™å®šç¬¦
  - æˆå‘˜å‡½æ•°ç¬¬ä¸€ä¸ªéšè—é»˜è®¤å®å‚æ˜¯è¯¥ç±»çš„å¯¹è±¡æŒ‡é’ˆ
  - å’Œä¹‹å‰ä¸€æ ·ï¼Œå¼•ç”¨ä¼ é€’è¦ç”¨`ref()`

  å½“ç„¶è¿˜èƒ½ç”¨`bind()`

  ```c++
  struct X {
      void task_run(int& a)const{
          std::cout << &a << '\n';
      }
  };
  int main(){
  	X x;
  	int n = 0;
  	std::cout << &n << '\n';
  	std::thread t{ std::bind(&X::task_run, &x, ref(n)) };
  	t.join();
  }
  
  ```

  è§£é‡Šï¼š

  - bind()å¿˜äº†çœ‹[#è¿™é‡Œ](../C++å…«è‚¡æ–‡/C++å­¦ä¹ éš¾ç‚¹.md#éé™æ€å‡½æ•°)
  - `std::bind` ä¹Ÿæ˜¯é»˜è®¤æŒ‰å€¼[**å¤åˆ¶**](https://godbolt.org/z/c5bh8Easd)çš„ï¼Œæ‰€ä»¥å’Œæˆ‘ä»¬ä¹‹å‰çš„å¤„ç†ä¸€æ ·ï¼Œå¼•ç”¨éœ€è¦ä½¿ç”¨`ref()`
  
- [#æ€»ç»“çœ‹å¼€å¤´](#ä¼ é€’å‚æ•°)

#### ä¼ é€’å‚æ•°ä¸­çš„bugæ‚¬ç©ºå¼•ç”¨

> - `std::thread` æ„é€ ä»…ä»£è¡¨â€œåˆ›å»ºå¹¶ä½¿å­çº¿ç¨‹è¿›å…¥å°±ç»ªæ€â€ï¼Œè€Œå¯è°ƒç”¨å¯¹è±¡ç”±å¯¹åº”çš„ï¼Œè¿›å…¥è¿è¡Œæ€çš„å­çº¿ç¨‹è¿›è¡Œè°ƒç”¨ã€‚

- å‰ç½®çŸ¥è¯†

  **Açš„å¼•ç”¨åªèƒ½å¼•ç”¨Aï¼Œæˆ–è€…ä»¥ä»»ä½•å½¢å¼è½¬æ¢åˆ°A**

  ```c++
  int main() {
      double a = 1;
      //int& p = a;   ç¼–è¯‘å¤±è´¥
      const int& p = a;
  }
  ```

  è§£é‡Šï¼š

  - aéšå¼è½¬æ¢åˆ°äº†intç±»å‹ï¼Œè½¬æ¢åçš„ç»“æœæ˜¯**çº¯å³å€¼è¡¨è¾¾å¼**ï¼Œæ‰€ä»¥éœ€è¦ç”¨`const int&`æˆ–è€…`int&&`æ¥æ¥æ”¶

- é—®é¢˜ä»£ç 

  ```c++
  void f(const std::string&){}
  void test(){
      char buffer[1024]{};
      //todo.. code
      std::thread t{ f,buffer };
      t.detach();
  }
  ```

  è§£é‡Šï¼š

  - buffer æ˜¯ä¸€ä¸ªæ•°ç»„å¯¹è±¡ï¼Œä½œä¸º `std::thread` æ„é€ å‚æ•°çš„ä¼ é€’çš„æ—¶å€™ä¼š[*`decay-copy`*](https://zh.cppreference.com/w/cpp/standard_library/decay-copy) ï¼ˆç¡®ä¿å®å‚åœ¨æŒ‰å€¼ä¼ é€’æ—¶ä¼šé€€åŒ–ï¼‰ **éšå¼è½¬æ¢ä¸ºäº†æŒ‡å‘è¿™ä¸ªæ•°ç»„çš„æŒ‡é’ˆ**ã€‚

  - æœ¬ä¾‹ä¸­çº¿ç¨‹åˆ›å»ºï¼Œæ‰§è¡Œæµç¨‹

    `std::thread` çš„æ„é€ å‡½æ•°ä¸­è°ƒç”¨äº†åˆ›å»ºçº¿ç¨‹çš„å‡½æ•°ï¼ˆwindows ä¸‹å¯èƒ½ä¸º [`_beginthreadex`](https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170)ï¼‰ï¼Œå®ƒå°†æˆ‘ä»¬ä¼ å…¥çš„å‚æ•°ï¼Œfã€buffer ï¼Œä¼ é€’ç»™è¿™ä¸ªå‡½æ•°ï¼Œåœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œå‡½æ•° `f`ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè°ƒç”¨å’Œæ‰§è¡Œ `f(buffer)` å¹¶ä¸æ˜¯è¯´è¦åœ¨ `std::thread` çš„æ„é€ å‡½æ•°ä¸­ï¼Œè€Œæ˜¯åœ¨åˆ›å»ºçš„æ–°çº¿ç¨‹ä¸­ï¼Œå…·ä½“ä»€ä¹ˆæ—¶å€™æ‰§è¡Œï¼Œå–å†³äºæ“ä½œç³»ç»Ÿçš„è°ƒåº¦ï¼Œæ‰€ä»¥å®Œå…¨æœ‰å¯èƒ½å‡½æ•° `test` å…ˆæ‰§è¡Œå®Œï¼Œè€Œæ–°çº¿ç¨‹æ­¤æ—¶è¿˜æ²¡æœ‰è¿›è¡Œ `f(buffer)` çš„è°ƒç”¨ï¼Œè½¬æ¢ä¸º`std::string`ï¼Œé‚£ä¹ˆ buffer æŒ‡é’ˆå°±**æ‚¬ç©º**äº†ï¼Œä¼šå¯¼è‡´é—®é¢˜ã€‚

  è§£å†³åŠæ³•ï¼š

  - å°† `detach()` æ›¿æ¢ä¸º `join()`ã€‚
  - `thread`æ„é€ æ—¶æ˜¾å¼å°† `buffer` è½¬æ¢ä¸º `std::string`ã€‚

### std::this_thread

[çœ‹è¿™é‡Œå°±å¥½äº†ï¼Œæ²¡ä»€ä¹ˆéš¾çš„](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02ä½¿ç”¨çº¿ç¨‹.html#std-this-thread)

### `std::thread`è½¬ç§»æ‰€æœ‰æƒ

> - ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡æœ‰ä¸”ä»…èƒ½æ‹¥æœ‰ä¸€ä¸ªçº¿ç¨‹èµ„æºï¼Œä¸€ä¸ªçº¿ç¨‹èµ„æºèƒ½ä¸”ä»…èƒ½è¢«ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡æŒæœ‰
> - æ‰€æœ‰æƒçš„è½¬ç§»ï¼Œå¯ä»¥é€šè¿‡ `ç§»åŠ¨æ„é€ `ï¼Œ`ç§»åŠ¨èµ‹å€¼`ï¼Œ`swap()` è¿›è¡Œ

ä¼ å…¥å¯è°ƒç”¨å¯¹è±¡ä»¥åŠå‚æ•°ï¼Œæ„é€  `std::thread` å¯¹è±¡ï¼Œå¯åŠ¨çº¿ç¨‹ï¼Œè€Œçº¿ç¨‹å¯¹è±¡æ‹¥æœ‰äº†çº¿ç¨‹çš„æ‰€æœ‰æƒï¼Œçº¿ç¨‹æ˜¯ä¸€ç§ç³»ç»Ÿèµ„æºï¼Œæ‰€ä»¥å¯ç§°ä½œâ€œ*çº¿ç¨‹èµ„æº*â€ã€‚

std::thread ä¸å¯å¤åˆ¶ã€‚ä¸¤ä¸ª std::thread å¯¹è±¡ä¸å¯è¡¨ç¤ºä¸€ä¸ªçº¿ç¨‹ï¼Œstd::thread å¯¹çº¿ç¨‹èµ„æºæ˜¯ç‹¬å æ‰€æœ‰æƒã€‚è€Œ**ç§»åŠ¨**æ“ä½œå¯ä»¥å°†ä¸€ä¸ª `std::thread` å¯¹è±¡çš„çº¿ç¨‹èµ„æºæ‰€æœ‰æƒè½¬ç§»ç»™å¦ä¸€ä¸ª `std::thread` å¯¹è±¡ã€‚

```c++
void f() {}
int main() {
	thread t1(f);
	thread t2(move(t1));	// é€šè¿‡ç§»åŠ¨æ„é€ å°†t1æŒæœ‰çš„çº¿ç¨‹èµ„æºè½¬ç§»ç»™t2
	thread t3 = move(t2);	// é€šè¿‡ç§»åŠ¨èµ‹å€¼å°†t2æŒæœ‰çš„çº¿ç¨‹èµ„æºè½¬ç§»ç»™t3
	thread t4 = thread(f);	// ä¸´æ—¶å¯¹è±¡ä¹Ÿæ˜¯å³å€¼è¡¨è¾¾å¼
	swap(t3, t4);			// é€šè¿‡swapäº¤æ¢t3ï¼Œt4çš„çº¿ç¨‹èµ„æº
}
```

å‡½æ•°è¿”å› `std::thread` å¯¹è±¡ï¼š

```c++
std::thread f(){
    std::thread t{ [] {} };
    return t;
}

int main(){
    std::thread rt = f();
    rt.join();
}
```

è§£é‡Šï¼š

- [#è¯·è€å¿ƒçœ‹å®Œè¿™é‡Œ](../2-æ·±å…¥ç†è§£C++11/æ·±å…¥ç†è§£C++11.md#å³å€¼å¼•ç”¨ï¼Œç§»åŠ¨è¯­ä¹‰ï¼Œå®Œç¾è½¬å‘)
- åœ¨å…³é—­rvo/nrvoçš„æƒ…å†µä¸‹ï¼Œä¸€å…±å‘ç”Ÿäº†ä¸‰æ¬¡æ„é€ ï¼ˆé»˜è®¤æ„é€ ï¼Œç§»åŠ¨æ„é€ ï¼Œç§»åŠ¨æ„é€ ï¼‰

æ‰€æœ‰æƒé€šè¿‡å‡½æ•°å‚æ•°ä¼ é€’ï¼š

> æ ¹æ®å‡½æ•°æ ˆå¸§ç›¸å…³ç†è§£ï¼Œå‡½æ•°è°ƒç”¨ä¼ å‚ï¼Œå®é™…ä¸Šæ˜¯åˆå§‹åŒ–äº†ï¼ˆæ„é€ ï¼‰å½¢å‚çš„å¯¹è±¡

```c++
void f(std::thread t){
    t.join();
}

int main(){
    std::thread t{ [] {} };
    f(std::move(t));
    f(std::thread{ [] {} });
}
```

## std::threadæ„é€ -æºç è§£æ

[è¯¦ç»†çœ‹è¿™é‡Œï¼šstd::thread çš„æ„é€ -æºç è§£æ](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/è¯¦ç»†åˆ†æ/01threadçš„æ„é€ ä¸æºç è§£æ.html)

é‡ç‚¹å…³æ³¨`thread(_Fn&& _Fx, _Args&&... _Ax)`è¿™ä¸ªå‡½æ•°çš„å®ç°

## å®ç°joining_thread

[ä½¿ç”¨çº¿ç¨‹ | ç°ä»£C++å¹¶å‘ç¼–ç¨‹æ•™ç¨‹](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02ä½¿ç”¨çº¿ç¨‹.html#å®ç°-joining-thread)

æ ¹æ®æ•™æ¡ˆä¸­çš„ä»£ç ï¼Œä¼˜åŒ–[#æœ¬ç« èŠ‚](#RAII)ä»£ç 

## C++20 std::jthread

[çœ‹çœ‹è¿™é‡Œï¼Œäº†è§£å°±å¥½äº†](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/02ä½¿ç”¨çº¿ç¨‹.html#c-20-std-jthread)

# å…±äº«æ•°æ®

æœ¬ç« èŠ‚ä¸»è¦å†…å®¹ï¼š

- å¤šçº¿ç¨‹å…±äº«æ•°æ®çš„é—®é¢˜
- ä½¿ç”¨äº’æ–¥é‡ä¿æŠ¤å…±äº«æ•°æ®
- ä¿æŠ¤å…±äº«æ•°æ®çš„å…¶å®ƒæ–¹æ¡ˆ
- æœ‰å…³çº¿ç¨‹å®‰å…¨çš„å…¶å®ƒé—®é¢˜

åœ¨ä¸Šä¸€ç« å†…å®¹ï¼Œæˆ‘ä»¬å¯¹äºçº¿ç¨‹çš„åŸºæœ¬ä½¿ç”¨å’Œç®¡ç†ï¼Œå¯ä»¥è¯´å·²ç»æ¯”è¾ƒäº†è§£äº†ï¼Œç”šè‡³æ·±å…¥é˜…è¯»äº†éƒ¨åˆ†çš„ `std::thread` æºç ã€‚æ‰€ä»¥å¦‚æœä½ å¥½å¥½å­¦ä¹ äº†ä¸Šä¸€ç« ï¼Œæœ¬ç« ä¹Ÿå®Œå…¨ä¸ç”¨æ‹…å¿ƒã€‚

æˆ‘ä»¬æœ¬ç« ï¼Œå°±è¦å¼€å§‹èŠå…±äº«æ•°æ®çš„é‚£äº›äº‹

## æ¡ä»¶ç«äº‰

- å‰ç½®çŸ¥è¯†ï¼š

  [çº¿ç¨‹å®‰å…¨ï¼ˆthread-safeï¼‰ä»‹ç»-CSDNåšå®¢](https://blog.csdn.net/liitdar/article/details/81030176)
  
  - å®šä¹‰ï¼š
  
    â€œçº¿ç¨‹å®‰å…¨â€å’Œâ€œçº¿ç¨‹ä¸å®‰å…¨â€çš„ç›¸å…³å†…å®¹ï¼Œéƒ½æ˜¯åœ¨æ¶‰åŠ**å¤šçº¿ç¨‹ç¼–ç¨‹**æ—¶æ‰ä¼šç”¨åˆ°ï¼Œåœ¨å•çº¿ç¨‹çš„åœºæ™¯ä¸‹æ— éœ€è€ƒè™‘ã€‚è‡³äºä¸ºä½•éœ€è¦å¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œè¯·å‚è€ƒæ­¤æ–‡ã€‚
  
    åœ¨æ“ä½œç³»ç»Ÿä¸­ï¼Œçº¿ç¨‹æ˜¯ç”±è¿›ç¨‹åˆ›å»ºçš„ï¼Œçº¿ç¨‹æœ¬èº«å‡ ä¹ä¸å æœ‰ç³»ç»Ÿèµ„æºï¼Œçº¿ç¨‹ç”¨åˆ°çš„ç³»ç»Ÿèµ„æºæ˜¯å±äºè¿›ç¨‹çš„ã€‚**ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œè¿™äº›çº¿ç¨‹å…±äº«ç€è¿›ç¨‹ä¸­çš„èµ„æºã€‚**æ‰€ä»¥ï¼Œå½“è¿™äº›çº¿ç¨‹å¹¶å‘è¿è¡Œæ—¶ï¼Œå¦‚æœåŒæ—¶å¯¹ä¸€ä¸ªæ•°æ®ï¼ˆè¯¥æ•°æ®å±äºè¿›ç¨‹ï¼Œè¢«è¯¥è¿›ç¨‹ä¸‹çš„å¤šä¸ªçº¿ç¨‹å…±äº«ä½¿ç”¨ï¼‰è¿›è¡Œä¿®æ”¹ï¼Œé‚£ä¹ˆå°±å¯èƒ½é€ æˆè¯¥æ•°æ®è¡¨ç°å‡ºä¸ç¬¦åˆæˆ‘ä»¬é¢„æœŸçš„å˜åŒ–ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„**çº¿ç¨‹ä¸å®‰å…¨**ã€‚
  
    ä¸çº¿ç¨‹ä¸å®‰å…¨å¯¹åº”ï¼Œåœ¨æ‹¥æœ‰å…±äº«æ•°æ®çš„å¤šä¸ªçº¿ç¨‹å¹¶è¡Œæ‰§è¡Œçš„ç¨‹åºä¸­ï¼Œ**çº¿ç¨‹å®‰å…¨**çš„ä»£ç ä¼šé€šè¿‡ï¼ˆè‡ªèº«å®ç°çš„ï¼‰åŒæ­¥æœºåˆ¶ä¿è¯å„ä¸ªçº¿ç¨‹éƒ½å¯ä»¥æ­£å¸¸ä¸”æ­£ç¡®çš„æ‰§è¡Œï¼Œä¸ä¼šå‡ºç°**æ•°æ®æ±¡æŸ“**ç­‰æ„å¤–æƒ…å†µã€‚
  
    ä»ä»£ç è§’åº¦æ¥è¯´ï¼Œå‡è®¾è¿›ç¨‹ä¸­æœ‰å¤šä¸ªçº¿ç¨‹åœ¨åŒæ—¶è¿è¡Œï¼Œè€Œè¿™äº›çº¿ç¨‹å¯èƒ½ä¼šåŒæ—¶è¿è¡Œä¸€æ®µä»£ç ï¼Œå¦‚æœè¿™æ®µä»£ç åœ¨å¤šçº¿ç¨‹å¹¶å‘æƒ…å†µä¸‹çš„è¿è¡Œç»“æœä¸å•çº¿ç¨‹è¿è¡Œæ—¶æ˜¯ä¸€æ ·çš„ï¼Œå¹¶ä¸”å…¶ä»–å˜é‡çš„å€¼ä¹Ÿå’Œé¢„æœŸä¸€æ ·ï¼Œé‚£ä¹ˆè¿™æ®µä»£ç å°±æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
  
    ä»æ¥å£çš„è§’åº¦æ¥è¯´ï¼Œå¦‚æœä¸€ä¸ªç±»ï¼ˆæˆ–è€…ç¨‹åºï¼‰æä¾›çš„æ¥å£ï¼Œå¯¹äºï¼ˆè°ƒç”¨è¯¥æ¥å£çš„ï¼‰çº¿ç¨‹æ¥è¯´æ˜¯**åŸå­çš„**ï¼Œæˆ–è€…å¤šä¸ªçº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢ä¸ä¼šå¯¼è‡´è¯¥æ¥å£çš„æ‰§è¡Œç»“æœå­˜åœ¨äºŒä¹‰æ€§ï¼Œè¿™æ ·åœ¨è°ƒç”¨è¯¥æ¥å£æ—¶å°±æ— éœ€é¢å¤–è€ƒè™‘çº¿ç¨‹åŒæ­¥é—®é¢˜ï¼Œé‚£ä¹ˆè¯¥æ¥å£å°±æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
  
    çº¿ç¨‹å®‰å…¨é—®é¢˜éƒ½æ˜¯ç”±**å…¨å±€å˜é‡**æˆ–**é™æ€å˜é‡**å¼•èµ·çš„ã€‚å¦‚æœæ¯ä¸ªçº¿ç¨‹ä¸­å¯¹å…¨å±€å˜é‡æˆ–é™æ€å˜é‡åªæœ‰è¯»æ“ä½œï¼Œè€Œæ— å†™æ“ä½œï¼Œé‚£ä¹ˆè¿™ä¸ªå…¨å±€å˜é‡æˆ–é™æ€å˜é‡æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼›å¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹å…¨å±€å˜é‡æˆ–é™æ€å˜é‡æ‰§è¡Œå†™æ“ä½œï¼Œåˆ™ä¸€èˆ¬éƒ½éœ€è¦è€ƒè™‘**çº¿ç¨‹åŒæ­¥**ï¼Œå¦åˆ™å°±å¯èƒ½å½±å“çº¿ç¨‹å®‰å…¨ã€‚
  
  - ç±»çš„çº¿ç¨‹å®‰å…¨
  
    çº¿ç¨‹å®‰å…¨çš„ç±»ï¼Œé¦–å…ˆå¿…é¡»åœ¨å•çº¿ç¨‹ç¯å¢ƒä¸­æœ‰**æ­£ç¡®è¡Œä¸º**ï¼šå¦‚æœä¸€ä¸ªç±»çš„å®ç°æ­£ç¡®ï¼ˆå³ç¬¦åˆè§„æ ¼è¯´æ˜ï¼‰ï¼Œé‚£ä¹ˆå¯¹è¿™ä¸ªç±»çš„å¯¹è±¡çš„ä»»ä½•æ“ä½œåºåˆ—ï¼ˆè¯»æˆ–å†™å…¬å…±å­—æ®µä»¥åŠè°ƒç”¨å…¬å…±æ–¹æ³•ï¼‰ï¼Œéƒ½ä¸ä¼šè®©è¯¥å¯¹è±¡å¤„äºæ— æ•ˆçŠ¶æ€ï¼Œæˆ–è€…è¿åç±»çš„ä»»ä½•ä¸å¯å˜é‡ã€å‰ç½®æ¡ä»¶æˆ–è€…åç½®æ¡ä»¶çš„æƒ…å†µã€‚
  
    æ­¤å¤–ï¼Œä¸€ä¸ªç±»è¦æˆä¸ºçº¿ç¨‹å®‰å…¨çš„ï¼Œåœ¨è¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®æ—¶ï¼Œä¸ç®¡è¿™äº›çº¿ç¨‹æ˜¯æ€æ ·çš„æ—¶åºå®‰æ’æˆ–è€…äº¤é”™ï¼Œè¯¥ç±»å¿…é¡»ä»ç„¶å…·å¤‡ä¸Šè¿°çš„**æ­£ç¡®è¡Œä¸º**ï¼Œå¹¶ä¸”è°ƒç”¨ä»£ç ä¸éœ€è¦è¿›è¡Œä»»ä½•é¢å¤–çš„**çº¿ç¨‹åŒæ­¥æ“ä½œ**ã€‚å…¶æ•ˆæœæ˜¯ï¼Œåœ¨æ‰€æœ‰çº¿ç¨‹çœ‹æ¥ï¼Œå¯¹äºï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰å¯¹è±¡çš„æ“ä½œæ˜¯ä»¥å›ºå®šçš„ã€å…¨å±€ä¸€è‡´çš„é¡ºåºå‘ç”Ÿçš„ã€‚
  
- è‰¯å¿ƒçš„æ¡ä»¶ç«äº‰

  > æ²¡æœ‰å¯¹å…±äº«æ•°æ®è¿›è¡Œè¯»å†™ï¼Œæˆ–è€…ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„å‡½æ•°å¯¹å…±äº«æ•°æ®è¯»å†™ï¼Œæˆ–è€…å¯¹æ˜¯åŸå­å˜é‡çš„å…±äº«æ•°æ®è¿›è¡Œè¯»å†™çš„çº¿ç¨‹ï¼Œå³ä½¿åœ¨å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹å‘ç”Ÿäº†æ¡ä»¶ç«äº‰ï¼Œéƒ½æ˜¯**è‰¯æ€§çš„æ¡ä»¶ç«äº‰**ï¼Œ**è‰¯æ€§çš„æ¡ä»¶ç«äº‰æ˜¯çº¿ç¨‹å®‰å…¨çš„**

  åœ¨å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æŠ¢ç€å®Œæˆè‡ªå·±çš„ä»»åŠ¡ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå³ä½¿ä¼šæ”¹å˜æ‰§è¡Œé¡ºåºï¼Œä¹Ÿæ˜¯è‰¯æ€§ç«äº‰ï¼Œè¿™æ˜¯æ— æ‰€è°“çš„ã€‚æ¯”å¦‚ä¸¤ä¸ªçº¿ç¨‹éƒ½è¦å¾€æ ‡å‡†è¾“å‡ºè¾“å‡ºä¸€æ®µå­—ç¬¦ï¼Œè°å…ˆè°åå¹¶ä¸ä¼šæœ‰ä»€ä¹ˆå¤ªå¤§å½±å“ã€‚

  ```c++
  void f() { std::cout << "â¤ï¸\n"; }
  void f2() { std::cout << "ğŸ˜¢\n"; }
  
  int main(){
      std::thread t{ f };
      std::thread t2{ f2 };
      t.join();
      t2.join();
  }
  ```

  > [`std::cout`](https://zh.cppreference.com/w/cpp/io/cout) çš„ operator<< è°ƒç”¨æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä¸ä¼šè¢«æ‰“æ–­ã€‚å³ï¼š*åŒæ­¥çš„ C++ æµä¿è¯æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ˆä»å¤šä¸ªçº¿ç¨‹è¾“å‡ºçš„å•ç‹¬å­—ç¬¦å¯èƒ½äº¤é”™ï¼Œä½†æ— æ•°æ®ç«äº‰ï¼‰*

- æ¶æ€§çš„æ¡ä»¶ç«äº‰

  > åªæœ‰åœ¨æ¶‰åŠå¤šçº¿ç¨‹è¯»å†™ç›¸åŒå…±äº«æ•°æ®çš„æ—¶å€™ï¼Œæ‰ä¼šå¯¼è‡´â€œ*æ¶æ€§çš„æ¡ä»¶ç«äº‰*â€ã€‚

  ```c++
  std::vector<int>v;
  
  void f() { v.emplace_back(1); }
  void f2() { v.erase(v.begin()); }
  
  int main() {
      std::thread t{ f };
      std::thread t2{ f2 };
      t.join();
      t2.join();
      std::cout << v.size() << '\n';
  }
  ```

  æ¯”å¦‚è¿™æ®µä»£ç å°±æ˜¯å…¸å‹çš„æ¶æ€§æ¡ä»¶ç«äº‰ï¼Œä¸¤ä¸ªçº¿ç¨‹å…±äº«ä¸€ä¸ª `vector`ï¼Œå¹¶å¯¹å®ƒè¿›è¡Œä¿®æ”¹ã€‚å¯èƒ½å¯¼è‡´è®¸å¤šé—®é¢˜ï¼Œæ¯”å¦‚ `f2` å…ˆæ‰§è¡Œï¼Œæ­¤æ—¶ `vector` è¿˜æ²¡æœ‰å…ƒç´ ï¼Œå¯¼è‡´æŠ›å‡ºå¼‚å¸¸ã€‚åˆæˆ–è€… `f` æ‰§è¡Œäº†ä¸€åŠï¼Œè°ƒç”¨äº† `f2()`ï¼Œç­‰ç­‰ã€‚

  å½“ç„¶äº†ï¼Œä¹Ÿæœ‰å¯èƒ½å…ˆæ‰§è¡Œ fï¼Œç„¶åæ‰§è¡Œ f2ï¼Œæœ€åæ‰“å°äº† 0ï¼Œç¨‹åºè€è€å®å®æ‰§è¡Œå®Œæ¯•ã€‚

  ä½†æ˜¯æˆ‘ä»¬æ˜¾ç„¶ä¸èƒ½å¯„å¸Œæœ›äºè¿™ç§æ“ä½œç³»ç»Ÿçš„è°ƒåº¦ã€‚

  è€Œä¸”å³ä½¿ä¸æ˜¯ä¸€ä¸ªæ·»åŠ å…ƒç´ ï¼Œä¸€ä¸ªåˆ é™¤å…ƒç´ ï¼Œå…¨æ˜¯ `emplace_back` æ·»åŠ å…ƒç´ ï¼Œä¹Ÿä¸€æ ·ä¼šæœ‰é—®é¢˜ï¼Œç”±äº std::vector ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„å®¹å™¨ï¼Œå› æ­¤å½“å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å¹¶ä¿®æ”¹ v æ—¶ï¼Œå¯èƒ½ä¼šå‘ç”Ÿ[*æœªå®šä¹‰çš„è¡Œä¸º*](https://zh.cppreference.com/w/cpp/language/memory_model#.E7.BA.BF.E7.A8.8B.E4.B8.8E.E6.95.B0.E6.8D.AE.E7.AB.9E.E4.BA.89)ã€‚å…·ä½“æ¥è¯´ï¼Œå½“ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶å°è¯•å‘ v ä¸­æ·»åŠ å…ƒç´ æ—¶ï¼Œä½†æ˜¯ `emplace_back` å‡½æ•°å´æ˜¯å¯ä»¥è¢«æ‰“æ–­çš„ï¼Œæ‰§è¡Œäº†ä¸€åŠï¼Œåˆå»æ‰§è¡Œå¦ä¸€ä¸ªçº¿ç¨‹ã€‚å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«äº‰ï¼Œä»è€Œå¼•å‘*æœªå®šä¹‰*çš„ç»“æœã€‚

  > å½“æŸä¸ªè¡¨è¾¾å¼çš„æ±‚å€¼å†™å…¥æŸä¸ªå†…å­˜ä½ç½®ï¼Œè€Œå¦ä¸€æ±‚å€¼è¯»æˆ–ä¿®æ”¹åŒä¸€å†…å­˜ä½ç½®æ—¶ï¼Œç§°è¿™äº›**è¡¨è¾¾å¼å†²çª**ã€‚**æ‹¥æœ‰ä¸¤ä¸ªå†²çªçš„æ±‚å€¼çš„ç¨‹åºå°±æœ‰æ•°æ®ç«äº‰**ï¼Œé™¤é
  >
  > - ä¸¤ä¸ªæ±‚å€¼éƒ½åœ¨åŒä¸€çº¿ç¨‹ä¸Šï¼Œæˆ–è€…åœ¨åŒä¸€ä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰§è¡Œï¼Œæˆ–
  > - ä¸¤ä¸ªå†²çªçš„æ±‚å€¼éƒ½æ˜¯åŸå­æ“ä½œï¼ˆè§ std::atomicï¼‰ï¼Œæˆ–
  > - ä¸€ä¸ªå†²çªçš„æ±‚å€¼å‘ç”Ÿæ—©äºâ€Šå¦ä¸€ä¸ªï¼ˆè§ std::memory_orderï¼‰
  >
  > **å¦‚æœå‡ºç°æ•°æ®ç«äº‰ï¼Œé‚£ä¹ˆç¨‹åºçš„è¡Œä¸ºæœªå®šä¹‰ã€‚**

  æ ‡é‡ç±»å‹ç­‰éƒ½åŒç†ï¼Œæœ‰*æ•°æ®ç«äº‰*ï¼Œ[*æœªå®šä¹‰è¡Œä¸º*](https://zh.cppreference.com/w/cpp/language/memory_model#.E7.BA.BF.E7.A8.8B.E4.B8.8E.E6.95.B0.E6.8D.AE.E7.AB.9E.E4.BA.89)ï¼š

  ```c++
  int cnt = 0;
  auto f = [&]{cnt++;};
  std::thread t1{f}, t2{f}, t3{f}; // æœªå®šä¹‰è¡Œä¸º
  ```

## ä½¿ç”¨äº’æ–¥é‡

- å®šä¹‰ï¼š

  äº’æ–¥é‡ï¼ˆMutexï¼‰ï¼Œåˆå¸¸è¢«ç§°ä¸ºäº’æ–¥é”ã€äº’æ–¥ä½“ï¼ˆæˆ–è€…ç›´æ¥è¢«ç§°ä½œâ€œé”â€ï¼‰ï¼Œæ˜¯ä¸€ç§ç”¨æ¥ä¿æŠ¤**ä¸´ç•ŒåŒº**[[1\]](æŒ‡çš„æ˜¯ä¸€ä¸ªè®¿é—®å…±äº«èµ„æºçš„ç¨‹åºç‰‡æ®µï¼Œè€Œè¿™äº›å…±äº«èµ„æºåˆæ— æ³•åŒæ—¶è¢«å¤šä¸ªçº¿ç¨‹è®¿é—®çš„ç‰¹æ€§ã€‚åœ¨ä¸´ç•ŒåŒºä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨åŒæ­¥æœºåˆ¶ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦è®²çš„äº’æ–¥é‡ï¼ˆMutexï¼‰ã€‚)çš„ç‰¹æ®Šå¯¹è±¡ï¼Œå…¶ç›¸å½“äºå®ç°äº†ä¸€ä¸ªå…¬å…±çš„â€œ**æ ‡å¿—ä½**â€ã€‚å®ƒå¯ä»¥å¤„äºé”å®šï¼ˆlockedï¼‰çŠ¶æ€ï¼Œä¹Ÿå¯ä»¥å¤„äºè§£é”ï¼ˆunlockedï¼‰çŠ¶æ€ï¼š

  1. å¦‚æœäº’æ–¥é‡æ˜¯é”å®šçš„ï¼Œé€šå¸¸è¯´æŸä¸ªç‰¹å®šçš„çº¿ç¨‹æ­£æŒæœ‰è¿™ä¸ªé”ã€‚
  2. å¦‚æœæ²¡æœ‰çº¿ç¨‹æŒæœ‰è¿™ä¸ªäº’æ–¥é‡ï¼Œé‚£ä¹ˆè¿™ä¸ªäº’æ–¥é‡å°±å¤„äºè§£é”çŠ¶æ€ã€‚
  3. ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬éœ€è¦æŠŠ`äº’æ–¥é”`å’Œ`ä¸´ç•ŒåŒº`/`ä¸´ç•ŒåŒºèµ„æº`æ”¾åœ¨åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹ã€‚**ä½¿å¾—ä¸åŒçš„çº¿ç¨‹åœ¨è®¿é—®ä¸´ç•ŒåŒº/ä¸´ç•ŒåŒºèµ„æºæ—¶ï¼Œä¹Ÿå¯ä»¥è®¿é—®åˆ°äº’æ–¥é”ï¼Œä¸”ä¸€æŠŠé”èƒ½ä¸”åªèƒ½å¯¹åº”å”¯ä¸€çš„ä¸´ç•ŒåŒº/ä¸´ç•ŒåŒºèµ„æºï¼Œåä¹‹äº¦ç„¶**ã€‚å½“çº¿ç¨‹å‡½æ•°æƒ³è¦è®¿é—®`ä¸´ç•ŒåŒº`/`ä¸´ç•ŒåŒºèµ„æº`æ—¶ï¼Œåº”è¯¥å…ˆå°è¯•ä¸Šé”ï¼Œåªæœ‰ä¸Šé”æˆåŠŸæ‰èƒ½è®¿é—®ä¸´ç•ŒåŒº/ä¸´ç•Œèµ„æº

- ç¤ºä¾‹ï¼š

  ```c++
  #include <mutex> // å¿…è¦æ ‡å¤´
  std::mutex m;	 // äº’æ–¥é”å˜é‡åº”å½“è§†æƒ…å†µæ”¾åœ¨ä¸´ç•ŒåŒº/ä¸´ç•ŒåŒºèµ„æºçš„å½“å‰ä½œç”¨åŸŸï¼ˆä¸´ç•ŒåŒºèµ„æºä¸ºæˆå‘˜å˜é‡æ—¶ï¼‰/çˆ¶ä½œç”¨åŸŸï¼ˆä¸´ç•ŒåŒºåœ¨æ™®é€šå‡½æ•°ä¸­æ—¶ï¼‰ï¼Œå…¶ä½œç”¨æ˜¯ä¸ºäº†è®©ä¸åŒçš„çº¿ç¨‹åœ¨è®¿é—®ä¸´ç•ŒåŒº/ä¸´ç•ŒåŒºèµ„æºæ—¶ï¼Œå¯ä»¥è®¿é—®åˆ°äº’æ–¥é”ï¼Œä¸”ä¸€æŠŠé”èƒ½ä¸”åªèƒ½å¯¹åº”å”¯ä¸€çš„ä¸´ç•ŒåŒº/ä¸´ç•ŒåŒºèµ„æºï¼Œåä¹‹äº¦ç„¶ï¼Œè¯¦æƒ…è§ æ­»é” ç« èŠ‚
  
  void f() {
      m.lock();	// ä¸Šé”
      std::cout << std::this_thread::get_id() << '\n';
      m.unlock();	// è§£é”
  }
  
  int main() {
      std::vector<std::thread>threads;
      for (std::size_t i = 0; i < 10; ++i)
          threads.emplace_back(f);
  
      for (auto& thread : threads)
          thread.join();
  }
  ```

  è§£é‡Šï¼š

  - å½“å¤šä¸ªçº¿ç¨‹æ‰§è¡Œå‡½æ•° `f` çš„æ—¶å€™ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½æˆåŠŸè°ƒç”¨ `lock()` ç»™äº’æ–¥é‡ä¸Šé”ï¼Œå…¶ä»–æ‰€æœ‰çš„çº¿ç¨‹ `lock()` çš„è°ƒç”¨å°†é˜»å¡æ‰§è¡Œï¼Œç›´è‡³è·å¾—é”ã€‚ç¬¬ä¸€ä¸ªè°ƒç”¨ `lock()` çš„çº¿ç¨‹å¾—ä»¥ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œæ‰§è¡Œæˆ‘ä»¬çš„ `std::cout` è¾“å‡ºè¯­å¥ï¼Œä¸ä¼šæœ‰ä»»ä½•å…¶ä»–çš„çº¿ç¨‹æ‰“æ–­è¿™ä¸ªæ“ä½œã€‚ç›´åˆ°çº¿ç¨‹æ‰§è¡Œ `unlock()`ï¼Œå°±è§£é”äº†äº’æ–¥é‡ã€‚**æ­¤ä¸¾ä¿è¯äº†`get_id()`å’Œ`'\n'`çš„è¾“å‡ºåœ¨åŒä¸€ä¸ªæ—¶é—´ç‰‡å†…**
  - è¢« `lock()` å’Œ `unlock()` åŒ…å«åœ¨å…¶ä¸­çš„ä»£ç æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œä¸ä¼šè¢«å…¶å®ƒçº¿ç¨‹çš„æ‰§è¡Œæ‰€æ‰“æ–­ã€‚

### std::lock_guard

> - ä½¿ç”¨ RAII æ€æƒ³çš„é”çš„ç®¡ç†ç±»

ä¸è¿‡ä¸€èˆ¬ä¸æ¨èè¿™æ ·æ˜¾å¼çš„ `lock()` ä¸ `unlock()`ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ C++11 æ ‡å‡†åº“å¼•å…¥çš„â€œç®¡ç†ç±»â€[`std::lock_guard`](https://zh.cppreference.com/w/cpp/thread/lock_guard)ï¼š

- ä½¿ç”¨ç¤ºä¾‹ï¼š

  ```c++
  void f() {
      std::lock_guard<std::mutex> lc{ m };
      std::cout << std::this_thread::get_id() << '\n';
  }
  ```

- åŸç†ï¼š

  ```c++
  template <class _Mutex>
  class lock_guard { // class with destructor that unlocks a mutex
  public:
      using mutex_type = _Mutex;
  
      explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock
          _MyMutex.lock();
      }
  
      lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept // strengthened
          : _MyMutex(_Mtx) {} // construct but don't lock
  
      ~lock_guard() noexcept {
          _MyMutex.unlock();
      }
  
      lock_guard(const lock_guard&)            = delete;
      lock_guard& operator=(const lock_guard&) = delete;
  
  private:
      _Mutex& _MyMutex;
  };
  ```

  è§£é‡Šï¼š

  - åªä¿æœ‰ä¸€ä¸ªç§æœ‰æ•°æ®æˆå‘˜ï¼Œä¸€ä¸ªå¼•ç”¨ï¼Œç”¨æ¥å¼•ç”¨äº’æ–¥é‡ã€‚
  - æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–è¿™ä¸ªå¼•ç”¨ï¼ŒåŒæ—¶ä¸Šé”ï¼Œææ„å‡½æ•°ä¸­è§£é”ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„ `RAII` å¼çš„ç®¡ç†ã€‚
  - åŒæ—¶å®ƒè¿˜æä¾›ä¸€ä¸ªæœ‰é¢å¤–[`std::adopt_lock_t`](https://zh.cppreference.com/w/cpp/thread/lock_tag_t)å‚æ•°çš„æ„é€ å‡½æ•° ï¼Œå¦‚æœä½¿ç”¨è¿™ä¸ªæ„é€ å‡½æ•°ï¼Œåˆ™æ„é€ å‡½æ•°ä¸ä¼šä¸Šé”ã€‚
  - ç®¡ç†ç±»ï¼Œè‡ªç„¶ä¸å¯ç§»åŠ¨ä¸å¯å¤åˆ¶ï¼Œæ‰€ä»¥å®šä¹‰å¤åˆ¶æ„é€ ä¸å¤åˆ¶èµ‹å€¼ä¸º[å¼ƒç½®å‡½æ•°](https://zh.cppreference.com/w/cpp/language/function#.E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0)ï¼ŒåŒæ—¶[é˜»æ­¢](https://zh.cppreference.com/w/cpp/language/rule_of_three#.E4.BA.94.E4.B9.8B.E6.B3.95.E5.88.99)äº†ç§»åŠ¨ç­‰å‡½æ•°çš„éšå¼å®šä¹‰ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  void f(){
      //code..
      {
          std::lock_guard<std::mutex> lc{ m };
          // æ¶‰åŠå…±äº«èµ„æºçš„ä¿®æ”¹çš„ä»£ç ...
      }
      //code..
  }
  ```

  è§£é‡Šï¼š

  ä½¿ç”¨ `{}` åˆ›å»ºäº†ä¸€ä¸ªå—ä½œç”¨åŸŸï¼Œé™åˆ¶äº†å¯¹è±¡ `lc` çš„ç”Ÿå­˜æœŸï¼Œè¿›å…¥ä½œç”¨åŸŸæ„é€  `lock_guard` çš„æ—¶å€™ä¸Šé”ï¼ˆlockï¼‰ï¼Œç¦»å¼€ä½œç”¨åŸŸææ„çš„æ—¶å€™è§£é”ï¼ˆunlockï¼‰ã€‚

  - æˆ‘ä»¬è¦å°½å¯èƒ½çš„è®©äº’æ–¥é‡ä¸Šé”çš„**ç²’åº¦**å°ï¼Œåªç”¨æ¥ç¡®ä¿å¿…é¡»çš„å…±äº«èµ„æºçš„çº¿ç¨‹å®‰å…¨ã€‚

  > **â€œç²’åº¦â€é€šå¸¸ç”¨äºæè¿°é”å®šçš„èŒƒå›´å¤§å°ï¼Œè¾ƒå°çš„ç²’åº¦æ„å‘³ç€é”å®šçš„èŒƒå›´æ›´å°ï¼Œå› æ­¤æœ‰æ›´å¥½çš„æ€§èƒ½å’Œæ›´å°‘çš„ç«äº‰ã€‚**

- æ›´åŠ å¤æ‚çš„ç¤ºä¾‹ï¼š

  ```c++
  std::mutex m;
  
  void add_to_list(int n, std::list<int>& list) {
      std::vector<int> numbers(n + 1);
      std::iota(numbers.begin(), numbers.end(), 0);
      int sum = std::accumulate(numbers.begin(), numbers.end(), 0);
  
      {	// é€šè¿‡ä½œç”¨åŸŸæ§åˆ¶lock_guardåªç»™å¿…è¦çš„ä»£ç ä¸Šé”
          std::lock_guard<std::mutex> lc{ m };
          list.push_back(sum);
      }
  }
  void print_list(const std::list<int>& list){
      std::lock_guard<std::mutex> lc{ m };
      for(const auto& i : list){
          std::cout << i << ' ';
      }
      std::cout << '\n';
  }
  ```

  è§£é‡Šï¼š

  [çœ‹è¿™é‡Œ](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#std-lock-guard)

- è¡¥å……çŸ¥è¯†ï¼š

  C++17 è¿˜å¼•å…¥äº†ä¸€ä¸ªæ–°çš„â€œç®¡ç†ç±»â€ï¼š[`std::scoped_lock`](https://zh.cppreference.com/w/cpp/thread/scoped_lock)ï¼Œå®ƒç›¸è¾ƒäº `lock_guard`çš„åŒºåˆ«åœ¨äºï¼Œ**å®ƒå¯ä»¥ç®¡ç†å¤šä¸ªäº’æ–¥é‡**ã€‚ä¸è¿‡å¯¹äºå¤„ç†ä¸€ä¸ªäº’æ–¥é‡çš„æƒ…å†µï¼Œå®ƒå’Œ `lock_guard` å‡ ä¹å®Œå…¨ç›¸åŒã€‚

  ```c++
  std::mutex m;
  std::scoped_lock lc{ m }; // std::scoped_lock<std::mutex>
  ```

  æˆ‘ä»¬åœ¨åç»­ç®¡ç†å¤šä¸ªäº’æ–¥é‡ï¼Œä¼šè¯¦ç»†äº†è§£è¿™ä¸ªç±»ã€‚

### try_lock

> ä¸è®ºæ˜¯`try_lock()`è¿˜æ˜¯`lock()`ï¼Œéƒ½ä¿è¯ä¸äº†ä»€ä¹ˆï¼Œä»–ä»¬åªèƒ½ä¿è¯**åœ¨åŒä¸€æ—¶é—´ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è®¿é—®è¢«äº’æ–¥é”åŒ…å›´èµ·æ¥çš„ä»£ç å—**ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œçº¿ç¨‹åœ¨æ‰§è¡Œè¢«äº’æ–¥é”åŒ…å›´ä½çš„ä»£ç å—æ—¶ï¼Œä¹Ÿå¯ä»¥è¢«å…¶ä»–æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹æ‰“æ–­ï¼Œå¹¶ä¸æ˜¯è¯´è¢«äº’æ–¥é”åŒ…å›´ä½çš„ä»£ç å—ä¸€å®šä¼šåœ¨ä¸€ä¸ªæ—¶é—´ç‰‡å†…æ‰§è¡Œå®Œï¼›åªæ˜¯è¯´çº¿ç¨‹åœ¨æ‰§è¡Œè¢«äº’æ–¥é”åŒ…å›´ä½çš„ä»£ç å—æ—¶ï¼Œå…¶ä»–çº¿ç¨‹æ— æ³•æ‰§è¡Œè¯¥ä»£ç å—ã€‚å¦‚æœä¸æ‡‚ï¼Œè¯·çœ‹ä¸‹é¢çš„ä¾‹å­

- å®šä¹‰ï¼š

  `try_lock` æ˜¯äº’æ–¥é‡ä¸­çš„ä¸€ç§å°è¯•ä¸Šé”çš„æ–¹å¼ã€‚ä¸å¸¸è§„çš„ `lock` ä¸åŒï¼Œ`try_lock` ä¼šå°è¯•ä¸Šé”ï¼Œä½†å¦‚æœé”å·²ç»è¢«å…¶ä»–çº¿ç¨‹å ç”¨ï¼Œåˆ™**ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œè€Œæ˜¯ç«‹å³è¿”å›**ã€‚

  å®ƒçš„è¿”å›ç±»å‹æ˜¯ `bool` ï¼Œå¦‚æœä¸Šé”æˆåŠŸå°±è¿”å› `true`ï¼Œå¤±è´¥å°±è¿”å› `false`ã€‚

- ç¤ºä¾‹ï¼š

  è¿™ç§æ–¹æ³•åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å¾ˆæœ‰ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦ä¿æŠ¤ä¸´ç•ŒåŒºçš„åŒæ—¶ï¼Œåˆä¸æƒ³çº¿ç¨‹å› ä¸ºç­‰å¾…é”è€Œé˜»å¡çš„æƒ…å†µä¸‹ã€‚

  ```c++
  std::mutex mtx;
  
  void thread_function(int id) {
      // å°è¯•åŠ é”
      if (mtx.try_lock()) {
          std::cout << "thread: " << id << " get lock" << std::endl;
          // ä¸´ç•ŒåŒºä»£ç 
          std::this_thread::sleep_for(std::chrono::milliseconds(100)); // æ¨¡æ‹Ÿä¸´ç•ŒåŒºæ“ä½œ
          mtx.unlock(); // è§£é”
          std::cout << "thread: " << id << " release lock" << std::endl;
      } else {
          std::cout << "thread_fail: " << id << " get lock failed, handling......" << std::endl;
      }
  }
  ```

  å¦‚æœæœ‰ä¸¤ä¸ªçº¿ç¨‹è¿è¡Œè¿™æ®µä»£ç ï¼Œå¿…ç„¶æœ‰ä¸€ä¸ªçº¿ç¨‹æ— æ³•æˆåŠŸä¸Šé”ï¼Œè¦èµ° else çš„åˆ†æ”¯ã€‚

  ```c++
  std::thread t1(thread_function, 1);
  std::thread t2(thread_function, 2);
  
  t1.join();
  t2.join();
  ```

  è¾“å‡ºç»“æœï¼š

  ```text
  thread: thread_fail: 1 get lock
  2thread:  get lock failed, handling......1
   release lock
  ```

  è§£é‡Šï¼š

  - æ³¨æ„ç¬¬ä¸€è¡Œï¼šè¢«äº’æ–¥é”åŒ…å›´çš„ä»£ç å—åœ¨è¾“å‡ºå®Œ"thread: "åæ—¶é—´ç‰‡ç»“æŸï¼Œè½¬åˆ°äº†å¦ä¸€ä¸ªçº¿ç¨‹ï¼Œè¯´æ˜è¢«äº’æ–¥é”åŒ…å›´çš„ä»£ç å—ï¼Œå¹¶ä¸èƒ½ä¿è¯å…¨åœ¨ä¸€ä¸ªæ—¶é—´ç‰‡å†…æ‰§è¡Œå®Œæ¯•ï¼Œåªèƒ½ä¿è¯åœ¨**åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è®¿é—®è¢«äº’æ–¥é”åŒ…å›´çš„ä»£ç å—**ã€‚
  - æƒ³æ”¹ä¹Ÿå¾ˆç®€å•ï¼ŒæŠŠè¿™äº›`cout`è¯­å¥åˆå¹¶æˆä¸€ä¸ªå°±å¥½äº†

## ä¿æŠ¤å…±äº«æ•°æ®

äº’æ–¥é‡ä¸»è¦ä¹Ÿå°±æ˜¯ä¸ºäº†ä¿æŠ¤å…±äº«æ•°æ®ï¼Œä¸Šä¸€èŠ‚çš„*ä½¿ç”¨äº’æ–¥é‡*ä¹Ÿå·²ç»ä¸ºå„ä½å±•ç¤ºäº†ä¸€äº›ã€‚

ç„¶è€Œä½¿ç”¨äº’æ–¥é‡æ¥ä¿æŠ¤å…±äº«æ•°æ®ä¹Ÿå¹¶ä¸æ˜¯åœ¨å‡½æ•°ä¸­åŠ ä¸Šä¸€ä¸ª `std::lock_guard` å°±ä¸‡äº‹å¤§å‰äº†ã€‚æœ‰çš„æ—¶å€™åªéœ€è¦ä¸€ä¸ªæŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œå°±èƒ½è®©è¿™ç§ä¿æŠ¤**å½¢åŒè™šè®¾**ã€‚

```c++
class Data{
    int a{};
    std::string b{};
public:
    void do_something(){
        // ä¿®æ”¹æ•°æ®æˆå‘˜ç­‰...
    }
};

class Data_wrapper{
    Data data;
    std::mutex m;
public:
    template<class Func>
    void process_data(Func func){
        std::lock_guard<std::mutex> lc{m};
        func(data);  // å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å‡½æ•°
    }
};

Data* p = nullptr;

void malicious_function(Data& protected_data){
    p = &protected_data; // å—ä¿æŠ¤çš„æ•°æ®è¢«ä¼ é€’åˆ°å¤–éƒ¨
}

Data_wrapper d;

void foo(){
    d.process_data(malicious_function);  // ä¼ é€’äº†ä¸€ä¸ªæ¶æ„çš„å‡½æ•°
    p->do_something();                   // åœ¨æ— ä¿æŠ¤çš„æƒ…å†µä¸‹è®¿é—®ä¿æŠ¤æ•°æ®
}
```

æˆå‘˜å‡½æ•°æ¨¡æ¿ `process_data` çœ‹èµ·æ¥ä¸€ç‚¹é—®é¢˜ä¹Ÿæ²¡æœ‰ï¼Œä½¿ç”¨ `std::lock_guard` å¯¹æ•°æ®åšäº†ä¿æŠ¤ï¼Œä½†æ˜¯è°ƒç”¨æ–¹ä¼ é€’äº† `malicious_function` è¿™æ ·ä¸€ä¸ªæ¶æ„çš„å‡½æ•°ï¼Œä½¿å—ä¿æŠ¤æ•°æ®ä¼ é€’ç»™å¤–éƒ¨ï¼Œå¯ä»¥åœ¨æ²¡æœ‰è¢«äº’æ–¥é‡ä¿æŠ¤çš„æƒ…å†µä¸‹è°ƒç”¨ `do_something()`ã€‚

æˆ‘ä»¬ä¼ é€’çš„å‡½æ•°å°±ä¸è¯¥æ˜¯æ¶‰åŠå¤–éƒ¨å‰¯ä½œç”¨çš„ï¼Œå°±åº”è¯¥æ˜¯å•çº¯çš„åœ¨å—äº’æ–¥é‡ä¿æŠ¤çš„æƒ…å†µä¸‹è€è€å®å®è°ƒç”¨ `do_something()` æ“ä½œå—ä¿æŠ¤çš„æ•°æ®ã€‚

- *ç®€è€Œè¨€ä¹‹ï¼š**åˆ‡å‹¿å°†å—ä¿æŠ¤æ•°æ®çš„æŒ‡é’ˆæˆ–å¼•ç”¨ä¼ é€’åˆ°äº’æ–¥é‡ä½œç”¨åŸŸä¹‹å¤–**ï¼Œä¸ç„¶ä¿æŠ¤å°†**å½¢åŒè™šè®¾**ã€‚*

> `process_data` çš„ç¡®ç®—æ˜¯æ²¡é—®é¢˜ï¼Œç”¨æˆ·éè¦åšè¿™äº›äº‹æƒ…ä¹Ÿæ˜¯é˜²ä¸ä½çš„ï¼Œæˆ‘ä»¬åªæ˜¯å‘Šè¯‰å„ä½å¯èƒ½çš„æƒ…å†µã€‚

## æ­»é”ï¼šé—®é¢˜ä¸è§£å†³

> - ä»è¡¨ç°å½¢å¼ä¸Šæ¥è¯´ï¼Œæ­»é”æ˜¯ç”±**å¤šä¸ªçº¿ç¨‹**ï¼ˆå¤šä¸ªçº¿ç¨‹æ‰§è¡Œçš„å¯èƒ½æ˜¯åŒä¸€ä¸ªå‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸åŒçš„å‡½æ•°ï¼‰ä½¿ç”¨å¤šä¸ªäº’æ–¥é”æ—¶ï¼Œå°è¯•ç»™è¯¥èµ„æºçš„äº’æ–¥é”ä¸Šé”çš„é¡ºåºï¼Œæ—¶é—´ä¸ä¸€è‡´å¯¼è‡´çš„ã€‚
> - è§£å†³æ–¹æ³•ï¼šè®©ä¸¤ä¸ªäº’æ–¥é‡ä½¿ç”¨ç›¸åŒé¡ºåºä¸Šé”ï¼Œæˆ–è€…ä½¿ç”¨`lock()`ä¸€æ¬¡æ€§é”ä½å¤šä¸ªäº’æ–¥é‡

- å‰è¨€ï¼š

  è¯•æƒ³ä¸€ä¸‹ï¼Œæœ‰ä¸€ä¸ªç©å…·ï¼Œè¿™ä¸ªç©å…·æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå¿…é¡»åŒæ—¶æ‹¿åˆ°ä¸¤éƒ¨åˆ†æ‰èƒ½ç©ã€‚æ¯”å¦‚ä¸€ä¸ªé¥æ§æ±½è½¦ï¼Œéœ€è¦é¥æ§å™¨å’Œç©å…·è½¦æ‰èƒ½ç©ã€‚æœ‰ä¸¤ä¸ªå°å­©ï¼Œä»–ä»¬éƒ½æƒ³ç©è¿™ä¸ªç©å…·ã€‚å½“å…¶ä¸­ä¸€ä¸ªå°å­©æ‹¿åˆ°äº†é¥æ§å™¨å’Œç©å…·è½¦æ—¶ï¼Œå°±å¯ä»¥å°½æƒ…ç©è€ã€‚å½“å¦ä¸€ä¸ªå°å­©ä¹Ÿæƒ³ç©ï¼Œä»–å°±å¾—ç­‰å¾…å¦ä¸€ä¸ªå°å­©ç©å®Œæ‰è¡Œã€‚å†è¯•æƒ³ï¼Œé¥æ§å™¨å’Œç©å…·è½¦è¢«æ”¾åœ¨ä¸¤ä¸ªä¸åŒçš„åœ°æ–¹ï¼Œå¹¶ä¸”ä¸¤ä¸ªå°å­©éƒ½æƒ³è¦ç©ï¼Œå¹¶ä¸”ä¸€ä¸ªæ‹¿åˆ°äº†é¥æ§å™¨ï¼Œå¦ä¸€ä¸ªæ‹¿åˆ°äº†ç©å…·è½¦ã€‚é—®é¢˜å°±å‡ºç°äº†ï¼Œé™¤éå…¶ä¸­ä¸€ä¸ªå­©å­å†³å®šè®©å¦ä¸€ä¸ªå…ˆç©ï¼Œä»–æŠŠè‡ªå·±çš„é‚£ä¸ªéƒ¨åˆ†ç»™å¦ä¸€ä¸ªå°å­©ã€‚ä½†å¦‚æœä»–ä»¬éƒ½ä¸æ„¿æ„ï¼Œé‚£ä¹ˆè¿™ä¸ªé¥æ§æ±½è½¦å°±è°éƒ½æ²¡æœ‰åŠæ³•ç©ã€‚

  æˆ‘ä»¬å½“ç„¶ä¸åœ¨ä¹å°å­©æŠ¢ç©å…·ï¼Œæˆ‘ä»¬è¦èŠçš„æ˜¯çº¿ç¨‹å¯¹é”çš„ç«äº‰ï¼š*ä¸¤ä¸ªçº¿ç¨‹éœ€è¦å¯¹å®ƒä»¬æ‰€æœ‰çš„äº’æ–¥é‡åšä¸€äº›æ“ä½œï¼Œå…¶ä¸­æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰ä¸€ä¸ªäº’æ–¥é‡ï¼Œä¸”ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹çš„äº’æ–¥é‡è§£é”ã€‚å› ä¸ºå®ƒä»¬éƒ½åœ¨ç­‰å¾…å¯¹æ–¹é‡Šæ”¾äº’æ–¥é‡ï¼Œæ²¡æœ‰çº¿ç¨‹å·¥ä½œã€‚* è¿™ç§æƒ…å†µå°±æ˜¯æ­»é”ã€‚

- é—®é¢˜ä»£ç ä¸€ï¼š

  é¿å…æ­»é”çš„ä¸€èˆ¬å»ºè®®æ˜¯è®©ä¸¤ä¸ªäº’æ–¥é‡ä»¥ç›¸åŒçš„é¡ºåºä¸Šé”ï¼Œæ€»åœ¨äº’æ–¥é‡ B ä¹‹å‰é”ä½äº’æ–¥é‡ Aï¼Œå°±é€šå¸¸ä¸ä¼šæ­»é”ã€‚åé¢ç¤ºä¾‹ï¼š

  ```c++
  std::mutex m1,m2;
  std::size_t n{};
  
  void f(){
      std::lock_guard<std::mutex> lc1{ m1 };
      this_thread::sleep_for(5ms);
      std::lock_guard<std::mutex> lc2{ m2 };
      ++n;
  }
  void f2() {
      std::lock_guard<std::mutex> lc2{ m2 };
      this_thread::sleep_for(5ms);
      std::lock_guard<std::mutex> lc1{ m1 };
      ++n;
  }
  ```

  è§£é‡Šï¼š

  - `f` ä¸ `f2` å› ä¸ºäº’æ–¥é‡**ä¸Šé”é¡ºåºä¸åŒ**ï¼Œå°±æœ‰æ­»é”é£é™©ã€‚å‡½æ•° `f` å…ˆé”å®š `m1`ï¼Œç„¶åå†å°è¯•é”å®š `m2`ï¼Œè€Œå‡½æ•° `f2` å…ˆé”å®š `m2` å†é”å®š `m1` ã€‚å¦‚æœä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¿è¡Œï¼Œå®ƒä»¬å°±å¯èƒ½ä¼šå½¼æ­¤ç­‰å¾…å¯¹æ–¹é‡Šæ”¾å…¶æ‰€éœ€çš„é”ï¼Œä»è€Œé€ æˆæ­»é”ã€‚
  - æ›´æ”¹å…¶ä¸­ä¸€ä¸ªå‡½æ•°ä¸­çš„lc1ï¼Œlc2çš„é¡ºåºå³å¯

- é—®é¢˜ä»£ç äºŒï¼š

  ä½†æ˜¯æœ‰çš„æ—¶å€™å³ä½¿å›ºå®šé”é¡ºåºï¼Œä¾æ—§ä¼šäº§ç”Ÿé—®é¢˜ã€‚å½“æœ‰å¤šä¸ªäº’æ–¥é‡ä¿æŠ¤åŒä¸€ä¸ªç±»çš„å¯¹è±¡æ—¶ï¼Œå¯¹äºç›¸åŒç±»å‹çš„ä¸¤ä¸ªä¸åŒå¯¹è±¡è¿›è¡Œæ•°æ®çš„äº¤æ¢æ“ä½œï¼Œä¸ºäº†ä¿è¯æ•°æ®äº¤æ¢çš„æ­£ç¡®æ€§ï¼Œå°±è¦é¿å…å…¶å®ƒçº¿ç¨‹ä¿®æ”¹ï¼Œç¡®ä¿æ¯ä¸ªå¯¹è±¡çš„äº’æ–¥é‡éƒ½é”ä½è‡ªå·±è¦ä¿æŠ¤çš„åŒºåŸŸã€‚

  ```c++
  struct X{
      X(const std::string& str) :object{ str } {}
  
      friend void swap(X& lhs, X& rhs);
  private:
      std::string object;
      std::mutex m;
  };
  
  void swap(X& lhs, X& rhs) {
      if (&lhs == &rhs) return;
      std::lock_guard<std::mutex> lock1{ lhs.m };
      this_thread::sleep_for(5ms);
      std::lock_guard<std::mutex> lock2{ rhs.m }; 
      swap(lhs.object, rhs.object);
  }
  ```

  è€ƒè™‘ç”¨æˆ·è°ƒç”¨çš„æ—¶å€™å°†å‚æ•°äº¤æ¢ï¼Œå°±ä¼šäº§ç”Ÿæ­»é”ï¼š

  ```c++
  X a{ "ğŸ¤£" }, b{ "ğŸ˜…" };
  std::thread t{ [&] {swap(a, b); } };  // 1
  std::thread t2{ [&] {swap(b, a); } }; // 2
  ```

- è§£å†³æ–¹æ³•ï¼š

  - `std::lock<>()`

    - ç®€ä»‹ï¼š

      å®ƒèƒ½å¾ªç¯å°è¯•é”ä½ä¼ å…¥çš„æ‰€æœ‰çš„äº’æ–¥é‡ï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œæ²¡æœ‰æ­»é”é£é™©

    - ä½¿ç”¨æ–¹æ³•ï¼š

      ```c++
      void swap(X& lhs, X& rhs) {
          if (&lhs == &rhs) return;
          std::lock(lhs.m, rhs.m);    // ç»™ä¸¤ä¸ªäº’æ–¥é‡ä¸Šé”
          swap(lhs.object, rhs.object);
          lhs.m.unlock();
          rhs.m.unlock();
      }
      ```

    - æºç é˜…è¯»ï¼ˆä»…ä¼ å…¥ä¸¤ä¸ªå‚æ•°æ—¶ï¼‰ï¼š

      å»ºè®®ä»ä¸‹å¾€ä¸Šçœ‹ï¼Œæœ€å¥½å¤åˆ¶åˆ°IDEä¸­çœ‹

      ```c++
      template <class _Lock>
      struct _NODISCARD _Unlock_one_guard {
          explicit _Unlock_one_guard(_Lock& _Lk) noexcept : _Lk_ptr(_STD addressof(_Lk)) {}
      
          ~_Unlock_one_guard() noexcept {
              if (_Lk_ptr) {
                  _Lk_ptr->unlock();
              }
          }
      
          _Unlock_one_guard(const _Unlock_one_guard&)            = delete;
          _Unlock_one_guard& operator=(const _Unlock_one_guard&) = delete;
      
          _Lock* _Lk_ptr;
      };
      
      template <class _Lock0, class _Lock1>
      bool _Lock_attempt_small(_Lock0& _Lk0, _Lock1& _Lk1) {
          // attempt to lock 2 locks, by first locking _Lk0, and then trying to lock _Lk1 returns whether to try again
          _Lk0.lock();
          {
              _Unlock_one_guard<_Lock0> _Guard{_Lk0};
              if (_Lk1.try_lock()) {
                  _Guard._Lk_ptr = nullptr;
                  return false;
              }
          }// è¿™ä¸ªèŠ±æ‹¬å·æ˜¯ç”¨äºä½œç”¨åŸŸä¿æŠ¤ï¼Œä½¿å¾—_Guardç¦»å¼€æ­¤ä½œç”¨åŸŸæ—¶è‡ªåŠ¨é‡Šæ”¾
      
          _STD this_thread::yield();
          return true;
      }
      
      template <class _Lock0, class _Lock1>
      void _Lock_nonmember1(_Lock0& _Lk0, _Lock1& _Lk1) {
          // lock 2 locks, without deadlock, special case for better codegen and reduced metaprogramming for common case
          while (_Lock_attempt_small(_Lk0, _Lk1) && _Lock_attempt_small(_Lk1, _Lk0)) { // keep trying
          }
      }
      
      _EXPORT_STD template <class _Lock0, class _Lock1, class... _LockN>
      void lock(_Lock0& _Lk0, _Lock1& _Lk1, _LockN&... _LkN) { // lock multiple locks, without deadlock
          _Lock_nonmember1(_Lk0, _Lk1, _LkN...);
      }
      ```

  - `std::scoped_lock<>`ï¼ˆC++17èµ·ï¼‰

    - ç®€ä»‹ï¼š

      `std::lock<>()`çš„ç®¡ç†ç±»ï¼Œå¯ä»¥è‡ªåŠ¨unlockæ‰€æœ‰ä¼ å…¥çš„äº’æ–¥é”

    - ä½¿ç”¨æ–¹æ³•ï¼š

      ```c++
      void swap(X& lhs, X& rhs) {
          if (&lhs == &rhs) return;
          std::scoped_lock guard{ lhs.m, rhs.m };
          swap(lhs.object, rhs.object);
      }
      ```

    - æºç é˜…è¯»ï¼ˆä¼ å…¥å¤šä¸ªå‚æ•°æ—¶ï¼‰ï¼š

      å…¶å®å°±æ˜¯å°†`lock()`åŒ…è£…äº†ä¸€ä¸‹ï¼Œå¯ä»¥è‡ªåŠ¨`unlock()`

      ```c++
      _EXPORT_STD template <class... _Mutexes>
      class _NODISCARD_LOCK scoped_lock { // class with destructor that unlocks mutexes
      public:
          explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock
              _STD lock(_Mtxes...);
          }
      
          explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened
              : _MyMutexes(_Mtxes...) {} // construct but don't lock
      
          ~scoped_lock() noexcept {
              _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes);
          }
      
          scoped_lock(const scoped_lock&)            = delete;
          scoped_lock& operator=(const scoped_lock&) = delete;
      
      private:
          tuple<_Mutexes&...> _MyMutexes;
      };
      ```

      è§£é‡Šï¼š

      - ææ„å‡½æ•°ä¸­çš„`apply`

        [std::apply - cppreference.com](https://zh.cppreference.com/w/cpp/utility/apply)

- æ‚è°ˆï¼š

  æ­»é”æ˜¯å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ä»¤äººç›¸å½“å¤´ç–¼çš„é—®é¢˜ï¼Œå¹¶ä¸”æ­»é”ç»å¸¸æ˜¯ä¸å¯é¢„è§ï¼Œç”šè‡³éš¾ä»¥å¤ç°ï¼Œå› ä¸ºåœ¨å¤§éƒ¨åˆ†æ—¶é—´é‡Œï¼Œç¨‹åºéƒ½èƒ½æ­£å¸¸å®Œæˆå·¥ä½œã€‚æˆ‘ä»¬å¯ä»¥**é€šè¿‡ä¸€äº›ç®€å•çš„è§„åˆ™ï¼Œçº¦æŸå¼€å‘è€…çš„è¡Œä¸ºï¼Œå¸®åŠ©å†™å‡ºâ€œæ— æ­»é”â€çš„ä»£ç **ã€‚

  - **é¿å…åµŒå¥—é”**

    çº¿ç¨‹è·å–ä¸€ä¸ªé”æ—¶ï¼Œå°±åˆ«å†è·å–ç¬¬äºŒä¸ªé”ã€‚æ¯ä¸ªçº¿ç¨‹åªæŒæœ‰ä¸€ä¸ªé”ï¼Œè‡ªç„¶ä¸ä¼šäº§ç”Ÿæ­»é”ã€‚å¦‚æœå¿…é¡»è¦è·å–å¤šä¸ªé”ï¼Œä½¿ç”¨ `std::lock` ã€‚

  - **é¿å…åœ¨æŒæœ‰é”æ—¶è°ƒç”¨å¤–éƒ¨ä»£ç **

    è¿™ä¸ªå»ºè®®æ˜¯å¾ˆç®€å•çš„ï¼šå› ä¸ºä»£ç æ˜¯å¤–éƒ¨æä¾›çš„ï¼Œæ‰€ä»¥æ²¡åŠæ³•ç¡®å®šå¤–éƒ¨è¦åšä»€ä¹ˆã€‚å¤–éƒ¨ç¨‹åºå¯èƒ½åšä»»ä½•äº‹æƒ…ï¼ŒåŒ…æ‹¬è·å–é”ã€‚åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹ï¼Œå¦‚æœç”¨å¤–éƒ¨ä»£ç è¦è·å–ä¸€ä¸ªé”ï¼Œå°±ä¼šè¿åç¬¬ä¸€ä¸ªæŒ‡å¯¼æ„è§ï¼Œå¹¶é€ æˆæ­»é”ï¼ˆæœ‰æ—¶è¿™æ˜¯æ— æ³•é¿å…çš„ï¼‰ã€‚å½“å†™é€šç”¨ä»£ç æ—¶ï¼ˆæ¯”å¦‚[ä¿æŠ¤å…±äº«æ•°æ®](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#ä¿æŠ¤å…±äº«æ•°æ®)ä¸­çš„ `Date` ç±»ï¼‰ã€‚è¿™ä¸æ˜¯æ¥å£è®¾è®¡è€…å¯ä»¥å¤„ç†çš„ï¼Œåªèƒ½å¯„å¸Œæœ›äºè°ƒç”¨æ–¹ä¼ é€’çš„ä»£ç æ˜¯èƒ½æ­£å¸¸æ‰§è¡Œçš„ã€‚

  - **ä½¿ç”¨å›ºå®šé¡ºåºè·å–é”**

    å¦‚åŒç¬¬ä¸€ä¸ªç¤ºä¾‹é‚£æ ·ï¼Œå›ºå®šçš„é¡ºåºä¸Šé”å°±ä¸å­˜åœ¨é—®é¢˜ã€‚

## std::unique_lock çµæ´»çš„é”

- ç®€ä»‹ï¼š

  [`std::unique_lock<>`](https://zh.cppreference.com/w/cpp/thread/unique_lock) æ˜¯ C++11 å¼•å…¥çš„ä¸€ç§é€šç”¨äº’æ–¥åŒ…è£…å™¨ï¼Œå®ƒç›¸æ¯”äº `std::lock_guard` æ›´åŠ çš„çµæ´»ã€‚å½“ç„¶ï¼Œå®ƒä¹Ÿæ›´åŠ çš„å¤æ‚ï¼Œå°¤å…¶å®ƒè¿˜å¯ä»¥ä¸æˆ‘ä»¬ä¸‹ä¸€ç« è¦è®²çš„[æ¡ä»¶å˜é‡](https://zh.cppreference.com/w/cpp/thread#.E6.9D.A1.E4.BB.B6.E5.8F.98.E9.87.8F)ä¸€èµ·ä½¿ç”¨ã€‚ä½¿ç”¨å®ƒå¯ä»¥å°†ä¹‹å‰ä½¿ç”¨ `std::lock_guard` çš„ `swap` æ”¹å†™ä¸€ä¸‹ï¼š

  ```c++
  void swap(X& lhs, X& rhs) {
      if (&lhs == &rhs) return;
      std::unique_lock<std::mutex> lock1{ lhs.m, std::defer_lock };
      std::unique_lock<std::mutex> lock2{ rhs.m, std::defer_lock };
      std::lock(lock1, lock2);
      swap(lhs.object, rhs.object);
  }
  ```

- æºç è§£æï¼š

  æ­¤å¤„åº”è¯¥æ‰“å¼€msvc STLçš„å®ç°

  **é‡ç‚¹å…³æ³¨`_Validate()`(éªŒè¯mutexæ˜¯å¦å¯ä»¥ä¸Šé”)ä»¥åŠå˜é‡`_Owns`çš„å˜åŒ–**

  - ```c++
    _EXPORT_STD _INLINE_VAR constexpr adopt_lock_t adopt_lock{};	// adoptï¼šæ¥æ”¶ï¼Œé‡‡çº³
    _EXPORT_STD _INLINE_VAR constexpr defer_lock_t defer_lock{};	// deferï¼šæ¨è¿Ÿ
    _EXPORT_STD _INLINE_VAR constexpr try_to_lock_t try_to_lock{};
    ```

    æ¸©é¦¨æç¤ºï¼šç¿»è¯‘è¦è·Ÿç€é”çš„çŠ¶æ€æ¥ç†è§£

  - æ•°æ®æˆå‘˜ï¼š

    ```c++
    private:
        _Mutex* _Pmtx = nullptr;
        bool _Owns    = false;
    ```

    è§£é‡Šï¼š

    - `_Owns`ï¼šè¡¨ç¤ºæˆå‘˜`_Pmtx`æ˜¯å¦å·²ç»è¢«**å½“å‰çº¿ç¨‹**æ‹¥æœ‰ï¼ˆ`_Owns`ä¸º`true`æ—¶ï¼Œè¡¨ç¤º`_Pmtx`å·²ç»è¢«ä¸Šé”äº†ï¼Œä¹Ÿå¯ä»¥ç†è§£æˆå·²ç»æœ‰çº¿ç¨‹æŒæœ‰`_Pmtx`ï¼›`_Owns`ä¸º`false`æ—¶ï¼Œè¡¨ç¤º`_Pmtx`è¿˜æ²¡æœ‰è¢«å½“å‰çº¿ç¨‹æ‰€æ‹¥æœ‰ã€‚

  - æ„é€ å‡½æ•°ï¼š

    - ä¸€å…ƒæ„é€ å‡½æ•°

      ```c++
      explicit unique_lock(_Mutex& _Mtx)
          : _Pmtx(_STD addressof(_Mtx)), _Owns(false) { // construct and lock
          _Pmtx->lock();
          _Owns = true;
      }
      ```

      è§£é‡Šï¼š

      - åªæœ‰ä¸€å…ƒæ„é€ å‡½æ•°åœ¨æ„é€ çš„æ—¶å€™ç»™äº’æ–¥é”ä¸Šé”ï¼Œå…¶ä»–çš„éƒ½éœ€è¦æ‰‹åŠ¨ä¸Šé”

    - äºŒå…ƒæ„é€ å‡½æ•°ï¼ˆé‡è½½ä¸€ï¼‰

      ```c++
      unique_lock(_Mutex& _Mtx, adopt_lock_t) noexcept // strengthened
          : _Pmtx(_STD addressof(_Mtx)), _Owns(true) {} // construct and assume already locked
      ```

      è§£é‡Šï¼š

      - ç¬¬äºŒä¸ªå‚æ•°ä¸­çš„`adopt`è¡¨ç¤ºæ¥å—ï¼Œé‡‡çº³ã€‚è¯´æ˜åœ¨`unique_lock`æ„é€ ä¹‹å‰ï¼Œäº’æ–¥é‡å°±å·²ç»ä¸Šé”äº†

    - äºŒå…ƒæ„é€ å‡½æ•°ï¼ˆé‡è½½äºŒï¼‰

      ```c++
      unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept
          : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock
      ```

      è§£é‡Šï¼š

      - ç¬¬äºŒä¸ªå‚æ•°ä¸­çš„`defer`è¡¨ç¤ºæ¨è¿Ÿã€‚äº’æ–¥é‡éœ€è¦åœ¨`unique_ptr`æ„é€ å®Œæˆä¹‹åä¸Šé”

    - äºŒå…ƒæ„é€ å‡½æ•°ï¼ˆé‡è½½ä¸‰ï¼‰

      ```c++
      unique_lock(_Mutex& _Mtx, try_to_lock_t)
          : _Pmtx(_STD addressof(_Mtx)), _Owns(_Pmtx->try_lock()) {} // construct and try to lock
      ```

      è§£é‡Šï¼š

      - æ³¨æ„`_Owns`çš„å˜åŒ–

    - å…¶ä»–çš„æ„é€ å‡½æ•°è‡ªå·±çœ‹

  - `_Validate()`

    ```c++
    void _Validate() const { // check if the mutex can be locked
        if (!_Pmtx) {
            _Throw_system_error(errc::operation_not_permitted);
        }
    
        if (_Owns) {
            _Throw_system_error(errc::resource_deadlock_would_occur);
        }
    }
    ```

    ä¸æ‡‚æ²¡å…³ç³»ï¼Œæ…¢æ…¢å¾€åçœ‹

  - `lock()`

    ```c++
    void lock() { // lock the mutex
        _Validate();
        _Pmtx->lock();
        _Owns = true;
    }
    ```

    è§£é‡Šï¼š

    - æ˜¾ç„¶ï¼Œå½“äº’æ–¥é”ä¸ºç©ºä¸”å½“å‰çº¿ç¨‹å·²æ‹¥æœ‰è¯¥äº’æ–¥é”æ—¶ï¼Œä¸å…è®¸`lock()`ï¼Œä¸”åœ¨`lock()`åï¼Œç«‹é©¬è®¾ç½®å½“å‰çº¿ç¨‹å·²æ‹¥æœ‰è¯¥äº’æ–¥é”

  - ææ„å‡½æ•°ï¼š

    ```c++
    ~unique_lock() noexcept {
        if (_Owns) {
            _Pmtx->unlock();
        }
    }
    ```

    è§£é‡Šï¼š

    - æ²¡å•¥å¥½è¯´çš„ï¼Œæ˜¾ç„¶ï¼Œå·²æ‹¥æœ‰çš„æƒ…å†µä¸‹æ‰èƒ½`unlock`ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  mutex mtx1, mtx2, mtx3;
  void test()
  {
      // ä½¿ç”¨ defer_lock
      unique_lock<mutex> unqlc1(mtx1, std::defer_lock);
  	unqlc1.lock();
      
      // ä½¿ç”¨ adopt_lock
      mtx2.lock();
  	unique_lock<mutex> unqlc2(mtx2, std::adopt_lock);
  
      // ä½¿ç”¨ä¸€å…ƒæœ‰å‚æ„é€ 
  	unique_lock<mutex> unqlc3(mtx3);
  }
  ```

  ä»¥ä¸Šæ˜¯ä¸‰ç§æ­£ç¡®ç”¨æ³•ï¼Œå…¶ä»–ç”¨æ³•éƒ½æ˜¯é”™è¯¯çš„ï¼Œæ˜¾ç„¶å¾ˆå¥½ç†è§£
  
- æˆ‘ä»¬å‰é¢æåˆ°äº† `std::unique_lock` æ›´åŠ çµæ´»ï¼Œé‚£ä¹ˆçµæ´»åœ¨å“ªï¼Ÿå¾ˆç®€å•ï¼Œå®ƒæ‹¥æœ‰ `lock()` å’Œ `unlock()` æˆå‘˜å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬èƒ½å†™å‡ºå¦‚ä¸‹ä»£ç ï¼š

  ```c++
  void f() {
      //code..
      
      std::unique_lock<std::mutex> lock{ m };
  
      // æ¶‰åŠå…±äº«èµ„æºçš„ä¿®æ”¹çš„ä»£ç ...
  
      lock.unlock(); // è§£é”å¹¶é‡Šæ”¾æ‰€æœ‰æƒï¼Œææ„å‡½æ•°ä¸ä¼šå† unlock()
  
      //code..
  }
  ```

  è€Œä¸æ˜¯åƒä¹‹å‰ `std::lock_guard` ä¸€æ ·ä½¿ç”¨ `{}`ã€‚

  å¦å¤–å†èŠä¸€èŠå¼€é”€å§ï¼Œå…¶å®å€’ä¹Ÿè¿˜å¥½ï¼Œå¤šäº†ä¸€ä¸ª `bool` ï¼Œå†…å­˜å¯¹é½ï¼Œx64 ç¯å¢ƒä¹Ÿå°±æ˜¯ `16` å­—èŠ‚ã€‚è¿™éƒ½ä¸æ˜¯æœ€é‡è¦çš„ï¼Œä¸»è¦æ˜¯å¤æ‚æ€§å’Œéœ€æ±‚ï¼Œé€šå¸¸å»ºè®®ä¼˜å…ˆ `std::lock_guard`ï¼Œå½“å®ƒæ— æ³•æ»¡è¶³ä½ çš„éœ€æ±‚æˆ–è€…æ˜¾å¾—ä»£ç éå¸¸ç¹çï¼Œé‚£ä¹ˆå¯ä»¥è€ƒè™‘ä½¿ç”¨ `std::unique_lock`ã€‚

## æ€»ç»“

åœ¨â€œå…±äº«æ•°æ®â€ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ç°åœ¨å·²ç»å­¦ä¹ äº†`std::mutex::lock()`ï¼Œ`std::mutex::try_lock()`ï¼Œ`std::mutex::unlock()`ï¼Œ`std::lock_guard<>`ï¼Œ`std::unique_lock<>`ï¼Œ`std::lock<>()`ï¼Œ`std::scoped_lock<>`è¿™å‡ ä¸ªmutexåº“ä¸­çš„åŠŸèƒ½ï¼Œæ€»ç»“å¦‚ä¸‹ï¼š

- `std::mutex::lock()`ï¼Œ`std::mutex::unlock()`

  ```c++
  #include <mutex> // å¿…è¦æ ‡å¤´
  std::mutex m;
  
  void f() {
      m.lock();	// ä¸Šé”
      // do_something()
      m.unlock();	// è§£é”
  }
  ```

- `std::mutex::try_lock()`ï¼Œ`std::mutex::unlock()`

  ```c++
  std::mutex mtx;
  
  void thread_function(int id) {
      if (mtx.try_lock()) {		// å°è¯•åŠ é”
          // do_something....
          mtx.unlock(); 			// è§£é”
      } else {
          // do_something....
      }
  }
  ```

- `std::lock_guard<>`

  ä½¿ç”¨ RAII æ€æƒ³çš„é”çš„ç®¡ç†ç±»ï¼Œä»…èƒ½é€šè¿‡æ„é€ å‡½æ•°ä¼ é€’é”ï¼Œè‡ªåŠ¨`unlock()`ã€‚

  ```c++
  template <class _Mutex>
  class lock_guard { // class with destructor that unlocks a mutex
  public:
      using mutex_type = _Mutex;
  
      explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock
          _MyMutex.lock();
      }
  
      lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept // strengthened
          : _MyMutex(_Mtx) {} // construct but don't lock
  
      ~lock_guard() noexcept {
          _MyMutex.unlock();
      }
  
      lock_guard(const lock_guard&)            = delete;
      lock_guard& operator=(const lock_guard&) = delete;
  
  private:
      _Mutex& _MyMutex;
  };
  ```

- `std::unique_lock<>`

  `std::lock_guard<>`çš„åŠ å¼ºç‰ˆï¼Œå¤šäº†ä¸€ä¸ª`_Owns`è¡¨ç¤ºè¯¥å¯¹è±¡æ˜¯å¦æŒæœ‰é”ï¼Œæ›´åŠ çµæ´»ï¼Œå¯ä»¥æ‰‹åŠ¨`lock()`ï¼Œ`unlock()`ï¼Œä¹Ÿå¯ä»¥åƒ`std::lock_guard<>`ä¸€æ ·ä½¿ç”¨RAIIè‡ªåŠ¨`lock()`ï¼Œ`unlock()`

- `std::lock<>()`

  å‡½æ•°æ¨¡æ¿ï¼Œç”¨äºè§£å†³æ­»é”é—®é¢˜ã€‚å¯ä»¥ä¸€æ¬¡æ€§ä¼ é€’å¤šä¸ªé”ï¼Œä¼ å…¥çš„é”è¦ä¹ˆéƒ½ä¸Šé”ï¼Œè¦ä¹ˆéƒ½ä¸ä¸Šé”

- `std::scoped_lock<>`ï¼ˆC++17èµ·ï¼‰

  å’Œ`std::lock_guard<>`å¾ˆåƒï¼Œ`std::scoped_lock<>`æ˜¯ä½¿ç”¨ RAII æ€æƒ³çš„`std::lock<>()`çš„ç®¡ç†ç±»ã€‚å…¶æ„é€ å‡½æ•°å¯ä»¥æ¥æ”¶å¤šä¸ªé”ï¼Œå¹¶èƒ½å°†è¿™äº›é”å…¨éƒ½è‡ªåŠ¨ä¸Šé”/è§£é”ã€‚

  ```c++
  template <class... _Mutexes>
  class scoped_lock { // class with destructor that unlocks mutexes
  public:
      explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock
          _STD lock(_Mtxes...);
      }
  
      explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened
          : _MyMutexes(_Mtxes...) {} // construct but don't lock
  
      ~scoped_lock() noexcept {
          _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes);
      }
  
      scoped_lock(const scoped_lock&)            = delete;
      scoped_lock& operator=(const scoped_lock&) = delete;
  
  private:
      tuple<_Mutexes&...> _MyMutexes;
  };
  ```

## åœ¨ä¸åŒä½œç”¨åŸŸä¼ é€’äº’æ–¥é‡

> - äº’æ–¥é‡æœ¬èº«**ä¸å¯ç§»åŠ¨ï¼Œä¸å¯å¤åˆ¶**ï¼Œåªèƒ½é€šè¿‡ç§»åŠ¨æŒ‡é’ˆè¾¾åˆ°ä¼ é€’äº’æ–¥é‡çš„æ•ˆæœ
> - ç§»åŠ¨æŒ‡é’ˆæ—¶è¦æ³¨æ„äº’æ–¥é‡çš„ç”Ÿå­˜æœŸ

- åŸºæœ¬æ¦‚å¿µï¼š

  é¦–å…ˆæˆ‘ä»¬è¦æ˜ç™½ï¼Œäº’æ–¥é‡æ»¡è¶³äº’æ–¥ä½“ (Mutex)çš„è¦æ±‚ï¼Œ**ä¸å¯å¤åˆ¶ä¸å¯ç§»åŠ¨**ã€‚æ‰€ä»¥æ˜¾ç„¶ï¼Œmutexå¯¹è±¡åªèƒ½æ”¾åœ¨ä¸€ä¸ªå›ºå®šçš„ä½ç½®ï¼Œåƒä¸‹é¢ä»£ç ä¸­ï¼Œ`mtx`è¢«åˆ›å»ºä¹‹åï¼Œå°±åªèƒ½æ”¾åœ¨mainçš„ä½œç”¨åŸŸå†…ï¼Œå®ƒçš„æœ¬ä½“æ— æ³•ç§»åŠ¨/å¤åˆ¶åˆ°å…¶ä»–åœ°æ–¹

  ```c++
  int main() {
      mutex mtx;
      //mutex mtx2(mtx);		// ç¼–è¯‘é”™è¯¯
      //mutex mtx3(move(mtx));	 // ç¼–è¯‘é”™è¯¯
      //mutex mtx4 = mtx;		// ç¼–è¯‘é”™è¯¯
  }
  ```

  æ‰€ä»¥æˆ‘ä»¬æ‰€è°“åœ¨ä¸åŒä½œç”¨åŸŸå†…ä¼ é€’äº’æ–¥é‡ï¼Œä¼ é€’çš„åªæ˜¯**æŒ‡é’ˆ**/**å¼•ç”¨**è€Œå·²ï¼Œä¹Ÿå°±æ˜¯è¯´ä¼ é€’çš„åªæ˜¯å®ƒçš„æµ…å±‚æ•°æ®ï¼Œmutexçš„æœ¬ä½“ä¾ç„¶è¢«å­˜æ”¾åœ¨åŸæ¥çš„ä½ç½®ã€‚ä¸”æˆ‘ä»¬éœ€è¦æ³¨æ„ï¼Œ**ä¼ é€’æµ…å±‚æ•°æ®æ—¶ï¼Œæˆ‘ä»¬ä¹Ÿåªèƒ½ç§»åŠ¨ä¸èƒ½å¤åˆ¶**ã€‚

- ä¼ é€’mutexæŒ‡é’ˆçš„ç±»

  å¯ä»¥åˆ©ç”¨å„ç§ç±»æ¥è¿›è¡Œä¼ é€’æŒ‡é’ˆ/å¼•ç”¨ï¼Œæ¯”å¦‚å‰é¢æåˆ°çš„ `std::unique_lock`ã€‚**å®ƒå­˜å‚¨çš„æ˜¯mutexæŒ‡é’ˆï¼Œæ˜¯åªèƒ½ç§»åŠ¨ä¸å¯å¤åˆ¶çš„ç±»ï¼Œå®ƒç§»åŠ¨å³ä»£è¡¨ç€å¯¹åº”çš„mutexæŒ‡é’ˆå’Œå¯¹æŒ‡é’ˆçš„æ‰€æœ‰æƒè½¬ç§»ç»™äº†å¦ä¸€ä¸ªå¯¹è±¡ã€‚**

  `std::unique_lock` å¯ä»¥è·å–äº’æ–¥é‡çš„æ‰€æœ‰æƒï¼Œè€Œäº’æ–¥é‡çš„æ‰€æœ‰æƒå¯ä»¥é€šè¿‡ç§»åŠ¨æ“ä½œè½¬ç§»ç»™å…¶ä»–çš„ `std::unique_lock` å¯¹è±¡ã€‚æœ‰äº›æ—¶å€™ï¼Œè¿™ç§è½¬ç§»ï¼ˆ*å°±æ˜¯è°ƒç”¨ç§»åŠ¨æ„é€ *ï¼‰æ˜¯è‡ªåŠ¨å‘ç”Ÿçš„ï¼Œæ¯”å¦‚å½“[å‡½æ•°è¿”å›](https://zh.cppreference.com/w/cpp/language/return#.E8.87.AA.E5.8A.A8.E4.BB.8E.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F.E5.92.8C.E5.BD.A2.E5.8F.82.E7.A7.BB.E5.8A.A8) `std::unique_lock` å¯¹è±¡ã€‚å¦ä¸€ç§æƒ…å†µå°±æ˜¯å¾—æ˜¾å¼ä½¿ç”¨ [`std::move`](https://zh.cppreference.com/w/cpp/utility/move)ï¼Œä»¥ä¸‹ä¸º`unique_lock`ç§»åŠ¨æ„é€ æºç ï¼š

  ```c++
  unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) {
      _Other._Pmtx = nullptr;
      _Other._Owns = false;
  }
  ```

- ä½¿ç”¨`unique_ptr`è¿›è¡Œä¼ é€’çš„æ–¹æ³•

  ä¸€ç§å¯èƒ½çš„ä½¿ç”¨æ˜¯å…è®¸å‡½æ•°å»é”ä½ä¸€ä¸ªäº’æ–¥é‡ï¼Œå¹¶å°†äº’æ–¥é‡çš„æ‰€æœ‰æƒè½¬ç§»åˆ°è°ƒç”¨è€…ä¸Šï¼Œæ‰€ä»¥è°ƒç”¨è€…å¯ä»¥åœ¨è¿™ä¸ªé”ä¿æŠ¤çš„èŒƒå›´å†…æ‰§è¡Œä»£ç ã€‚

  ```c++
  std::unique_lock<std::mutex> get_lock(){
      extern std::mutex some_mutex;
      std::unique_lock<std::mutex> lk{ some_mutex };
      return lk;
  }
  void process_data(){
      std::unique_lock<std::mutex> lk{ get_lock() };
      // æ‰§è¡Œä¸€äº›ä»»åŠ¡...
  }
  ```

  è§£é‡Šï¼š

  - åœ¨ä¸åŒä½œç”¨åŸŸä¹‹é—´ä¼ é€’`mutex`æŒ‡é’ˆ/å¼•ç”¨æ—¶ï¼Œ**è¦ç‰¹åˆ«æ³¨æ„äº’æ–¥é‡çš„[ç”Ÿå­˜æœŸ](https://zh.cppreference.com/w/cpp/language/lifetime)**ã€‚

    > extern è¯´æ˜ç¬¦åªèƒ½æ­é…å˜é‡å£°æ˜å’Œå‡½æ•°å£°æ˜ï¼ˆé™¤äº†ç±»æˆå‘˜æˆ–å‡½æ•°å½¢å‚ï¼‰ã€‚*å®ƒæŒ‡å®šå¤–éƒ¨é“¾æ¥ï¼Œè€Œä¸”æŠ€æœ¯ä¸Šä¸å½±å“å­˜å‚¨æœŸï¼Œä½†å®ƒä¸èƒ½ç”¨æ¥å®šä¹‰è‡ªåŠ¨å­˜å‚¨æœŸçš„å¯¹è±¡ï¼Œæ•…æ‰€æœ‰ extern å¯¹è±¡éƒ½å…·æœ‰**é™æ€æˆ–çº¿ç¨‹[å­˜å‚¨æœŸ](https://zh.cppreference.com/w/cpp/language/storage_duration)ã€‚***

    å¦‚æœä½ ç®€å•å†™ä¸€ä¸ª `std::mutex some_mutex` é‚£ä¹ˆå‡½æ•° `process_data` ä¸­çš„ `lk` ä¼šæŒæœ‰ä¸€ä¸ªæ‚¬å‚æŒ‡é’ˆã€‚

    > ä¸¾ä¸€ä¸ªä½¿ç”¨ `extern std::mutex` çš„å®Œæ•´[è¿è¡Œç¤ºä¾‹](https://godbolt.org/z/z47x1Es5z)ã€‚å½“ç„¶ï¼Œå…¶å®ç†è®ºä¸Šä½  `new std::mutex` ä¹Ÿæ˜¯å®Œå…¨å¯è¡Œ...... ğŸ¤£ğŸ¤£

  - å¯¹äº`unique_lock`è€Œè¨€ï¼Œå…³é—­rvo/nrvoçš„æƒ…å†µä¸‹ï¼Œä¸€å…±ç»å†äº†ä¸‰æ¬¡æ„é€ ï¼ˆä¸€å…ƒæœ‰å‚ï¼Œç§»åŠ¨ï¼Œç§»åŠ¨ï¼‰
  - åœ¨æœ¬ä¾‹ä¸­ï¼Œé”ä¿æŠ¤çš„èŒƒå›´ä»`std::unique_lock<std::mutex> lk{ some_mutex };`å¼€å§‹ï¼Œåˆ°`process_data()`ç»“æŸæ—¶ç»“æŸã€‚
  - `std::unique_lock` æ˜¯çµæ´»çš„ï¼ŒåŒæ ·å…è®¸åœ¨å¯¹è±¡é”€æ¯ä¹‹å‰å°±è§£é”äº’æ–¥é‡ï¼Œè°ƒç”¨ `unlock()` æˆå‘˜å‡½æ•°å³å¯ï¼Œä¸å†å¼ºè°ƒã€‚

## ä¿æŠ¤å…±äº«æ•°æ®çš„åˆå§‹åŒ–è¿‡ç¨‹

[å…±äº«æ•°æ® | ç°ä»£C++å¹¶å‘ç¼–ç¨‹æ•™ç¨‹](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#ä¿æŠ¤å…±äº«æ•°æ®çš„åˆå§‹åŒ–è¿‡ç¨‹)

> - ä¸€èˆ¬è®¨è®ºçš„æ¯”è¾ƒå¤šçš„æ˜¯æ‡’æ±‰å¼çš„å•ä¾‹æ¨¡å¼åœ¨å¤šçº¿ç¨‹ä¸‹çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚ä½¿ç”¨åŒæ£€é”çš„å½¢å¼çº¿ç¨‹ä¸å®‰å…¨ï¼Œå› ä¸ºnew/resetå¹¶éåŸå­æ“ä½œï¼Œå¯ä»¥è¢«å…¶ä»–çº¿ç¨‹ä¸­æ–­ã€‚åœ¨C++11ä¹‹åï¼Œåº”è¯¥ä½¿ç”¨call_once/é™æ€å±€éƒ¨å˜é‡ä¿è¯ç»å¯¹çš„çº¿ç¨‹å®‰å…¨

### å‰è¨€

ä¿æŠ¤å…±äº«æ•°æ®å¹¶éå¿…é¡»ä½¿ç”¨äº’æ–¥é‡ï¼Œäº’æ–¥é‡åªæ˜¯å…¶ä¸­ä¸€ç§å¸¸è§çš„æ–¹å¼è€Œå·²ï¼Œå¯¹äºä¸€äº›ç‰¹æ®Šçš„åœºæ™¯ï¼Œä¹Ÿæœ‰ä¸“é—¨çš„ä¿æŠ¤æ–¹å¼ï¼Œæ¯”å¦‚**å¯¹äºå…±äº«æ•°æ®çš„åˆå§‹åŒ–è¿‡ç¨‹çš„ä¿æŠ¤**ã€‚æˆ‘ä»¬é€šå¸¸å°±ä¸ä¼šç”¨äº’æ–¥é‡ï¼Œ**è¿™ä¼šé€ æˆå¾ˆå¤šçš„é¢å¤–å¼€é”€**ã€‚

æˆ‘ä»¬ä¸æƒ³ä¸ºå„ä½ä»‹ç»å…¶å®ƒä¹±ä¸ƒå…«ç³Ÿçš„å„ç§ä¿æŠ¤åˆå§‹åŒ–çš„æ–¹å¼ï¼Œæˆ‘ä»¬åªä»‹ç»ä¸‰ç§ï¼š**åŒæ£€é”ï¼ˆé”™è¯¯ï¼‰**ã€**ä½¿ç”¨ `std::call_once`**ã€**é™æ€å±€éƒ¨å˜é‡åˆå§‹åŒ–ä» C++11 å¼€å§‹æ˜¯çº¿ç¨‹å®‰å…¨**ã€‚

### åŒæ£€é”ï¼ˆé”™è¯¯ï¼‰çº¿ç¨‹ä¸å®‰å…¨ï¼Ÿï¼Ÿï¼Ÿ

[C++ æ™ºèƒ½æŒ‡é’ˆæœ€ä½³å®è·µ&æºç åˆ†æ-è…¾è®¯äº‘å¼€å‘è€…ç¤¾åŒº-è…¾è®¯äº‘ï¼Ÿï¼Ÿï¼Ÿ](https://cloud.tencent.com/developer/article/1922161)

[#å•ä¾‹æ¨¡å¼](../C++å…«è‚¡æ–‡/C++å­¦ä¹ éš¾ç‚¹.md#å•ä¾‹æ¨¡å¼çš„çº¿ç¨‹å®‰å…¨é—®é¢˜)

[ç”±std::once_call å¼•å‘çš„å•ä¾‹æ¨¡å¼çš„å†æ¬¡æ€»ç»“ï¼ŒåŸºäºC++11 - çƒŸæ³¢--é’“å¾’ - åšå®¢å›­](https://www.cnblogs.com/xuhuajie/p/11647164.html)

å½“ç„¶ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå•ä¾‹å¯¹è±¡æ˜¯ä¸ªæŒ‡é’ˆï¼Œä½†å®é™…ä¸Šæˆ‘ä»¬ä¸€èˆ¬ç”¨æ™ºèƒ½æŒ‡é’ˆæ”¹è¿›å•ä¾‹æ¨¡å¼

```c++
// ä¸é‡è¦
class Singleton {
private:
    static shared_ptr<Singleton> m_spSingle;
    static mutex m_mtx;
public:
    //GetInstance
    static shared_ptr<Singleton> GetInstance() {
        if (m_spSingle == nullptr) {	// æœªè¢«é”ä¿æŠ¤çš„è¯»å–æ“ä½œï¼Œå­˜åœ¨æ½œåœ¨çš„æ¡ä»¶ç«äº‰
            m_mtx.lock();
            if (m_spSingle == nullptr) {
                m_spSingle = make_shared<Singleton>();
            }
            m_mtx.unlock();
        }
        return m_spSingle;
    }
};
shared_ptr<Singleton> Singleton::m_spSingle = nullptr;
mutex Singleton::m_mtx;
```

è§£é‡Šï¼š

- `make_shared<Type>()`ä¸`new Type()`çš„åŒºåˆ«ï¼š

  - `make_shared<Type>()`
    1. å®ƒå¯ä»¥åœ¨å•ä¸€çš„[å†…å­˜åˆ†é…](https://zhida.zhihu.com/search?content_id=240244745&content_type=Article&match_order=1&q=å†…å­˜åˆ†é…&zhida_source=entity)ä¸­åŒæ—¶åˆ†é…å¯¹è±¡çš„å­˜å‚¨ç©ºé—´å’Œ[å¼•ç”¨è®¡æ•°](https://zhida.zhihu.com/search?content_id=240244745&content_type=Article&match_order=1&q=å¼•ç”¨è®¡æ•°&zhida_source=entity)æ§åˆ¶å—ï¼Œä»è€Œæé«˜å†…å­˜åˆ†é…æ•ˆç‡å¹¶å‡å°‘å†…å­˜å ç”¨ã€‚
    2. å®ƒæ˜¯å¼‚å¸¸å®‰å…¨çš„ï¼Œå› ä¸ºåœ¨æ„é€ å¯¹è±¡æ—¶ï¼Œå¦‚æœæŠ›å‡ºå¼‚å¸¸ï¼Œä¸ä¼šç•™ä¸‹æœªè¢«åˆ é™¤çš„å¼•ç”¨è®¡æ•°æ§åˆ¶å—ã€‚
    3. ä½¿ç”¨ `std::make_shared` ç®€åŒ–äº†ä»£ç ï¼Œé¿å…äº†ç›´æ¥ä½¿ç”¨ `new` æ“ä½œç¬¦ã€‚
  - `new Type()`
    1. è¿™ç§æ–¹æ³•æ¶‰åŠä¸¤æ¬¡å†…å­˜åˆ†é…ï¼šä¸€æ¬¡ç”¨äºå¯¹è±¡ï¼Œä¸€æ¬¡ç”¨äºå¼•ç”¨è®¡æ•°æ§åˆ¶å—ï¼Œè¿™æ¯” `std::make_shared` çš„å•æ¬¡å†…å­˜åˆ†é…æ•ˆç‡ä½ã€‚
    2. å¦‚æœåœ¨ `std::shared_ptr` æ„é€ å‡½æ•°å‚æ•°åˆ—è¡¨ä¸­åŒæ—¶åˆ›å»ºå¤šä¸ª `shared_ptr`ï¼Œå¹¶ä¸”å…¶ä¸­ä¸€ä¸ª `new` è¡¨è¾¾å¼æŠ›å‡ºå¼‚å¸¸ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…å­˜æ³„éœ²ã€‚

- ä½¿ç”¨åŒæ£€é”æ—¶ï¼Œä¸è®ºæ˜¯ä½¿ç”¨newåˆå§‹åŒ–ï¼Œæˆ–è€…æ™ºèƒ½æŒ‡é’ˆä¸­çš„resetåˆå§‹åŒ–ï¼Œéƒ½ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºnew/resetå¹¶éåŸå­æ“ä½œï¼Œå¯ä»¥è¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ï¼ˆå°½ç®¡`operator new()`æœ¬èº«çº¿ç¨‹å®‰å…¨ï¼Œä½†å¹¶ä¸ä»£è¡¨è¯¥å‡½æ•°æ˜¯åŸå­æ“ä½œï¼Œè¿™ç‚¹å¾ˆé‡è¦ï¼ï¼‰ï¼Œåˆ†æå¦‚ä¸‹ï¼ˆå»ºè®®ç»“åˆæ•™æ¡ˆé˜…è¯»ï¼‰ï¼š

  åœ¨å•ä¾‹è¿˜æœªè¢«åˆ›å»ºæ—¶ï¼Œçº¿ç¨‹Aå’Œçº¿ç¨‹BåŒæ—¶è°ƒç”¨GetInstance()ï¼Œå‡è®¾çº¿ç¨‹Aå…ˆè·å¾—æ—¶é—´ç‰‡ï¼Œæ—¶é—´ç‰‡åœ¨æ‰§è¡Œåˆ°resetä¸­ï¼Œåˆšå¥½ä¸ºå•ä¾‹æŒ‡é’ˆåˆ†é…å¥½å†…å­˜ç©ºé—´ï¼Œä½†æ˜¯æ²¡è°ƒç”¨æ„é€ å‡½æ•°åˆå§‹åŒ–æ—¶ï¼Œåˆšå¥½ç»“æŸï¼Œè½®åˆ°çº¿ç¨‹Bæ‰§è¡Œï¼Œå¯¹äºæ­¤æ—¶çš„çº¿ç¨‹Bè€Œè¨€ï¼Œå•ä¾‹æŒ‡é’ˆéç©ºï¼Œæ‰€ä»¥ç›´æ¥è¿”å›æŒ‡é’ˆã€‚æ˜æ˜¾åœ°ï¼Œçº¿ç¨‹Bä¸­çš„å•ä¾‹æŒ‡é’ˆåˆå§‹åŒ–å¹¶ä¸å®Œå…¨ï¼Œæ‰€ä»¥çº¿ç¨‹ä¸å®‰å…¨

  shared_ptr<>å¯ä»¥ï¼Œä½†ä¸æ˜¯æœ€å¥½çš„é€‰æ‹©ï¼Œæœ€å¥½ä½¿ç”¨unique_ptrï¼ŒåŒæ—¶GetInstanceçš„è¿”å›å€¼æ”¹ä¸ºSingleton&ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ä¼šå°‘å ç”¨ä¸€éƒ¨åˆ†ç©ºé—´

### call_onceé…åˆonce_flag

- ç¤ºä¾‹ï¼š

  ```c++
  // é‡è¦
  class Singleton {
  private:
      static shared_ptr<Singleton> m_spSingle;
      // once_flag ç”¨äºé˜²æ­¢å¤šæ¬¡åˆå§‹åŒ–
      static once_flag oneflg;
  public:
      static shared_ptr<Singleton> GetInstance() {
          // call_onceåªæ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªä¸ºonce_flagï¼Œç¬¬äºŒä¸ªä¸ºå¯è°ƒç”¨å¯¹è±¡
          call_once(oneflg, []() {
              m_spSingle = make_shared<Singleton>();
              cout << "call once" << endl;
          });
          return m_spSingle;
      }
  };
  ```

  è§£é‡Šï¼š

  - once_flagå¯ä»¥æ˜¯ç±»çš„é™æ€/æ™®é€šæˆå‘˜ï¼Œä¹Ÿå¯ä»¥æ˜¯å…¨å±€å˜é‡ï¼Œæˆ–è€…æ˜¯é™æ€å±€éƒ¨å˜é‡ï¼Œç”¨äºæ­é…call_onceä½¿ç”¨

  - call_onceåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨å®Œåï¼Œä¾¿ä¼šç»™oneflgä¸Šæ ‡è®°ï¼Œä¿è¯**åªè¿›è¡Œä¸€æ¬¡çº¿ç¨‹å®‰å…¨çš„åˆå§‹åŒ–**ã€‚

- æ³¨æ„äº‹é¡¹ï¼š

  â€œ**åˆå§‹åŒ–**â€ï¼Œé‚£è‡ªç„¶æ˜¯åªæœ‰**ä¸€æ¬¡**ã€‚ä½†æ˜¯ `std::call_once` ä¹Ÿæœ‰ä¸€äº›ä¾‹å¤–æƒ…å†µï¼ˆæ¯”å¦‚å¼‚å¸¸ï¼‰ä¼šè®©ä¼ å…¥çš„å¯è°ƒç”¨å¯¹è±¡è¢«å¤šæ¬¡è°ƒç”¨ï¼Œå³â€œ**å¤šæ¬¡**â€åˆå§‹åŒ–ï¼š

  ```c++
  // å»ºè®®è‡ªå·±æ‹¿å»ideè·‘ä¸€ä¸‹
  std::once_flag flag;
  int n = 0;
  
  void f(){
      std::call_once(flag, [] {
          ++n;
          std::cout << "ç¬¬" << n << "æ¬¡è°ƒç”¨\n";
          throw std::runtime_error("å¼‚å¸¸");
      });
  }
  
  int main(){
      try{
          f();
      }
      catch (std::exception&){}
      
      try{
          f();
      }
      catch (std::exception&){}
  }
  ```

  è§£é‡Šï¼š

  - ä¼šè°ƒç”¨ä¸¤æ¬¡call_onceï¼Œå¾ˆå¥½ç†è§£ï¼Œå› ä¸ºå¼‚å¸¸ä»£è¡¨æ“ä½œå¤±è´¥ï¼Œéœ€è¦è¿›è¡Œå›æº¯å’Œé‡ç½®çŠ¶æ€ï¼Œæ‰€ä»¥åœ¨call_onceä¼šå¤šæ¬¡è°ƒç”¨å¯è°ƒç”¨å¯¹è±¡

### é™æ€å±€éƒ¨å˜é‡

[å¿…çœ‹ï¼šå±€éƒ¨é™æ€å˜é‡](https://blog.csdn.net/weixin_44470443/article/details/104503759)

[å•ä¾‹--Meyers' Singleton-CSDNåšå®¢](https://blog.csdn.net/weixin_44048823/article/details/104080864)

> - é™æ€å±€éƒ¨å˜é‡åˆå§‹åŒ–åœ¨ C++11 æ˜¯çº¿ç¨‹å®‰å…¨
> - é™æ€å±€éƒ¨å˜é‡å­˜æ”¾åœ¨å†…å­˜çš„**å…¨å±€æ•°æ®åŒº**ã€‚
> - é™æ€å±€éƒ¨å˜é‡åœ¨**ç¼–è¯‘æœŸ**èµ‹åˆå€¼ï¼Œä¸”**åªèµ‹å€¼ä¸€æ¬¡**ã€‚å¦‚æœå˜é‡åœ¨åˆå§‹åŒ–æ—¶ï¼Œå¹¶å‘çº¿ç¨‹åŒæ—¶è¿›å…¥åˆ°staticå£°æ˜è¯­å¥ï¼Œå¹¶å‘çº¿ç¨‹ä¼šé˜»å¡ç­‰å¾…åˆå§‹åŒ–ç»“æŸï¼Œæ‰€ä»¥**é™æ€å±€éƒ¨å˜é‡å…·æœ‰çº¿ç¨‹å®‰å…¨æ€§**ã€‚
> - å‡½æ•°ç»“æŸæ—¶ï¼Œé™æ€å±€éƒ¨å˜é‡ä¸ä¼šæ¶ˆå¤±ï¼Œæ¯æ¬¡è¯¥å‡½æ•°è°ƒç”¨æ—¶ï¼Œä¹Ÿä¸ä¼šä¸ºå…¶é‡æ–°åˆ†é…ç©ºé—´ã€‚å®ƒå§‹ç»ˆé©»ç•™åœ¨å…¨å±€æ•°æ®åŒºï¼Œç›´åˆ°ç¨‹åºè¿è¡Œç»“æŸã€‚é™æ€å±€éƒ¨å˜é‡çš„åˆå§‹åŒ–ä¸å…¨å±€å˜é‡ç±»ä¼¼ï¼

- é™æ€å±€éƒ¨å˜é‡ç¤ºä¾‹ï¼š

  ```c++
  // å»ºè®®æ”¾åœ¨IDEé‡Œè·‘ä¸€è·‘
  class A {
  public:
      A(int _c) : c(_c){cout << "construct : " << c << endl;}
      static A& instance(int tmp) {
          static A a(tmp);
          return a;
      }
      int c;
  };
  
  int main() {
      int i = 1;
      A::instance(++i);
      A::instance(i++);
      A::instance(i);
      cout <<  A::instance(i).c << endl;
  }
  ```

  è§£é‡Šï¼š

  - æ˜æ˜¾çš„ï¼Œåªæœ‰åœ¨14è¡Œçš„ä»£ç é‡Œä¼šè¿›è¡Œåˆå§‹åŒ–ã€‚

- åœ¨å•ä¾‹æ¨¡å¼ä¸­çš„åº”ç”¨ï¼š

  ```c++
  class A {
  public:
      static A& instance() {
          static A a;
          return a;
      }
      int c;
  };
  ```

### çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼

- é¥¿æ±‰å¼

  ç¨‹åºå¼€å§‹æ—¶å°±è¦ã€‚

  ```c++
  class Singleton_Hungry
  {
  public:
      static Singleton_Hungry& Instance(){
          static Singleton_Hungry _instance;	//å¯¹è±¡åœ¨å…¨å±€é™æ€æ•°æ®åŒº
          //static Singleton_Hungry* p_instance = new Singleton_Hungry; å¯¹è±¡åœ°å€åœ¨å…¨å±€é™æ€æ•°æ®åŒºï¼Œå¯¹è±¡åœ¨å †æ•°æ®åŒºï¼Œè¿™ç§æ–¹å¼åˆ›å»ºå•ä¾‹ä¹Ÿæ˜¯å¯ä»¥çš„
          return _instance;
      }
  private:
      Singleton_Hungry() = default;
      Singleton_Hungry(const Singleton_Hungry&) = delete;
      Singleton_Hungry(Singleton_Hungry&&) = delete;
      Singleton_Hungry& operator=(const Singleton_Hungry&) = delete;
      ~Singleton_Hungry() = default;
  };
  ```

  è§£é‡Šï¼š

  - é™æ€å±€éƒ¨å˜é‡ä¼šåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶åˆå§‹åŒ–ï¼Œå¤šæ¬¡è°ƒç”¨è¢«ä¼šç¼–è¯‘å™¨å¿½ç•¥ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯ç¨‹åºçš„è¿è¡ŒåŒºé—´ï¼Œå¹¶ä¸”æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ã€‚
  - é™æ€å±€éƒ¨å˜é‡æ˜¯åˆ†é…åœ¨å…¨å±€é™æ€æ•°æ®åŒºï¼ˆä¸æ˜¯å †æˆ–è€…æ ˆï¼‰ï¼Œå†…å­˜ä¸€ç›´éƒ½åœ¨ï¼ˆé»˜è®¤å…¨éƒ¨å¡«0ï¼Œä½†ä¸å ç¨‹åºå¤§å°`bss`æ®µï¼‰ã€‚

- æ‡’æ±‰å¼

  ```c++
  // ç®€å•ç‰ˆæœ¬ï¼Œå»ºè®®æ‹¿åˆ°IDEä¸Šçœ‹
  class Singleton {
  private:
      static unique_ptr<Singleton, void(*)(Singleton*)> up;
  public:
      static Singleton& GetInstance() {
          static once_flag of;
          call_once(of, []() {
              up.reset(new Singleton);
              cout << "111" << endl;
          });
          return *up;
      }
  
      static void Destory(Singleton* p_sgl) {
          //p_sgl->~Singleton();  åˆ«çŠ¯è ¢ï¼ŒæŒ‡é’ˆçš„é‡Šæ”¾è¦ä½¿ç”¨deleteæ‰èƒ½é‡Šæ”¾å¹²å‡€ã€‚
          delete p_sgl;
          cout << "Destory" << endl;
      }
  
      void f(){ cout << "f" << endl;}
  private:
      Singleton() = default;
      Singleton(const Singleton&) = delete;
      Singleton(Singleton&&) = delete;
      Singleton& operator=(const Singleton&) = delete;
      ~Singleton(){ cout << "~Singleton" << endl;}
  };
  unique_ptr<Singleton, void(*)(Singleton*)> Singleton::up(nullptr, Singleton::Destory);
  ```

  è§£é‡Šï¼š

  - æ³¨æ„çœ‹16è¡Œçš„æ³¨é‡Š

  ```c++
  // å¤æ‚ç‰ˆæœ¬ï¼Œå»ºè®®æ”¾åˆ°IDEä¸­çœ‹
  
  // æ‡’æ±‰å¼å•ä¾‹çš„åŸºç±»
  template<typename T>    //T æ˜¯å­ç±»
  class Singleton_Lazy_Base {
  private:
      static unique_ptr<T, void(*)(T*)> up;
      static once_flag of;
  
      // åˆå§‹åŒ–å‡½æ•°ä¹Ÿè¦å†™æˆstaticï¼ï¼ï¼
      template<typename ...Args>
      static void init(Args&&... args) {
          up.reset(new T(forward<Args>(args)...));
          cout << "init_multiArgs" << endl;
      }
  
      static void Destory(T* p_sgl) {
          delete p_sgl;
      }
  public:
      template<typename ...Args>
      static T& GetInstance(Args&&... args) {
          // lambdaæ— æ³•ä½¿ç”¨ä¸‡èƒ½å¼•ç”¨ï¼ˆC++20å‰ï¼‰ï¼Œæ•…æ­¤å¤„ä½¿ç”¨æ¨¡æ¿å‡½æ•°å®Œæˆå®Œç¾è½¬å‘
          call_once(of, Singleton_Lazy_Base<T>::init<Args...>, forward<Args>(args)...);
          return *up;
      }
  
      static T& GetInstance() {
          call_once(of, []() {
              up.reset(new T);
              cout << "init" << endl;
          });
          return *up;
      }
      
  	Singleton_Lazy_Base(const Singleton_Lazy_Base&) = delete;
  	Singleton_Lazy_Base(Singleton_Lazy_Base&&) = delete;
  	Singleton_Lazy_Base& operator=(const Singleton_Lazy_Base&) = delete;
  
  protected:
       Singleton_Lazy_Base() = default;
      ~Singleton_Lazy_Base(){ cout << "~Singleton" << endl;}
  };
  template<typename T>
  unique_ptr<T, void(*)(T*)> Singleton_Lazy_Base<T>::up(nullptr, T::Destory);
  template<typename T>
  once_flag Singleton_Lazy_Base<T>::of;
  
  // å…·ä½“çš„å­ç±»ï¼Œä¸€å®šè¦æ³¨æ„åœ¨CRTPä¸­ï¼Œä¸åŒå­ç±»ç»§æ‰¿çš„çˆ¶ç±»æ˜¯ä¸åŒçš„çˆ¶ç±»ï¼Œæ‰€ä»¥staticå˜é‡ä¹Ÿæ˜¯äº’ä¸ç›¸é€šçš„ï¼Œä¸åŒå­ç±»ä¹‹é—´ä¸ä¼šå› ä¸ºè¿™äº›å˜é‡é€ æˆæ­»é”
  class Single_CRTP : public Singleton_Lazy_Base<Single_CRTP>
  {
      friend class Singleton_Lazy_Base<Single_CRTP>;
  private:
  
      
  public:
      void test(){
          std::cout << "hello word" << std::endl;
      }
      
      Single_CRTP(const Single_CRTP&) = delete;
      Single_CRTP(Single_CRTP&&) = delete;
      Single_CRTP& operator=(const Single_CRTP&) = delete;
  private:
      Single_CRTP() = default;
      ~Single_CRTP(){ cout << "~Single_CRTP" << endl; };
  };
  ```
  
  è§£é‡Šï¼š
  
  - `Singleton_Lazy_Base`é¡¾åæ€ä¹‰ï¼Œæ‡’æ±‰å¼å•ä¾‹çš„åŸºç±»ï¼Œæ˜¯ä¸ªæ¨¡æ¿ç±»ï¼›`Single_CRTP`æ˜¯å­ç±»ï¼Œç»§æ‰¿äºåŸºç±»ï¼Œæ³¨æ„ç»§æ‰¿æ—¶ä¼ ç»™åŸºç±»çš„æ¨¡æ¿å®å‚ï¼Œè¯´æ˜æ­¤å¤„ç”¨äº†CRTPæŠ€æœ¯ã€‚
  - ä¸ºäº†é˜²æ­¢ç”¨æˆ·ç›´æ¥ä½¿ç”¨å­ç±»/åŸºç±»åˆ›å»ºå¯¹è±¡ï¼Œæ­¤å¤„åº”å°†å­ç±»çš„æ„é€ /ææ„å‡½æ•°éƒ½è®¾ä¸º`private`ï¼ŒåŸºç±»çš„æ„é€ /ææ„å‡½æ•°è®¾ä¸º`protected`ï¼Œå¹¶å°†åŸºç±»è®¾ä¸ºå­ç±»çš„å‹å…ƒç±»
  - ç”±äºææ„å‡½æ•°ä¹Ÿä¸ºç§æœ‰ï¼Œæ‰€ä»¥`unique_ptr`åœ¨é‡Šæ”¾çš„æ—¶å€™æ— æ³•ç›´æ¥è®¿é—®ï¼Œéœ€è¦è‡ªå®šä¹‰ä¸€ä¸ªé™æ€çš„åˆ é™¤å‡½æ•°ï¼Œå¹¶åœ¨æ„é€ `unique_ptr`çš„æ—¶å€™æ˜¾å¼æŒ‡æ˜åˆ é™¤å™¨
  - å¦‚æœæƒ³é€šè¿‡`GetInstance`æ¥è°ƒç”¨CRTPç±»çš„å¤šå‚æ•°æ„é€ å‡½æ•°ï¼Œåˆ™éœ€è¦é‡è½½`GetInstance`å¹¶é…åˆå®Œç¾è½¬å‘å’Œ`call_once`ä¸€èµ·ä½¿ç”¨ã€‚ä¸è¿‡lambdaå‡½æ•°ä¸æ”¯æŒä¸‡èƒ½å¼•ç”¨ï¼ˆC++20å‰ï¼‰ï¼Œæ‰€ä»¥éœ€è¦é¢å¤–å®ç°ä¸€ä¸ªæ–°çš„é™æ€çš„initå‡½æ•°ã€‚
  - ç”±äºå•ä¾‹ç‰¹æ€§ï¼Œèµ‹å€¼ï¼Œæ‹·è´ï¼Œç§»åŠ¨åº”å½“è¢«åˆ é™¤ã€‚

## ä¿æŠ¤ä¸å¸¸æ›´æ–°çš„æ•°æ®ç»“æ„

> - è§£å†³æ–¹å¼æ˜¯ä½¿ç”¨è¯»å†™é”ï¼Œè¯»å†™é”æœ‰ä¸¤ç§å½¢å¼ï¼š`std::shared_timed_mutex`ï¼ˆC++14ï¼‰ï¼Œ`std::shared_mutex`ï¼ˆC++17ï¼‰ï¼Œä¸¤è€…å‡ ä¹æ²¡åŒºåˆ«ã€‚
>
> - å½“éœ€è¦è¯»æ•°æ®æ—¶ï¼Œåº”è¯¥ä½¿ç”¨è¯»å†™é”ä¸­çš„`lock_shared()`å’Œ`unlock_shared()`ï¼Œæˆ–è€…ä½¿ç”¨è¯»é”çš„RAIIç®¡ç†ç±»æ¨¡æ¿`shared_lock<>`æ¥å°è£…è¯»å†™é”å¯¹è±¡ã€‚
>
>   å½“éœ€è¦å†™æ•°æ®æ—¶ï¼Œå’Œmutexä¸€æ ·ï¼Œä½¿ç”¨`lock()`å’Œ`unlock()`ï¼Œæˆ–è€…ä½¿ç”¨å†™é”çš„RAIIç®¡ç†ç±»æ¨¡æ¿`lock_guard<>`ã€`unique_lock<>`æ¥å°è£…è¯»å†™é”å¯¹è±¡ã€‚

- mutableï¼Œconstï¼Œvolatileçš„åŒºåˆ«

  [C++æ·±å…¥ç†è§£mutableå’Œvolatileå…³é”®å­— - å‚é£æ— æ„ - åšå®¢å›­](https://www.cnblogs.com/depend-wind/articles/12159971.html)

- å‰è¨€ï¼š

  è¯•æƒ³ä¸€ä¸‹ï¼Œä½ æœ‰ä¸€ä¸ªæ•°æ®ç»“æ„å­˜å‚¨äº†ç”¨æˆ·çš„è®¾ç½®ä¿¡æ¯ï¼Œæ¯æ¬¡ç”¨æˆ·æ‰“å¼€ç¨‹åºçš„æ—¶å€™ï¼Œéƒ½è¦è¿›è¡Œè¯»å–ï¼Œä¸”è¿è¡Œæ—¶å¾ˆå¤šåœ°æ–¹éƒ½ä¾èµ–è¿™ä¸ªæ•°æ®ç»“æ„éœ€è¦è¯»å–ï¼Œæ‰€ä»¥ä¸ºäº†æ•ˆç‡ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†å¤šçº¿ç¨‹è¯»å†™ã€‚è¿™ä¸ªæ•°æ®ç»“æ„å¾ˆå°‘è¿›è¡Œæ”¹å˜ï¼Œè€Œæˆ‘ä»¬çŸ¥é“ï¼Œå¤šçº¿ç¨‹è¯»å–ï¼Œæ˜¯æ²¡æœ‰æ•°æ®ç«äº‰çš„ï¼Œæ˜¯å®‰å…¨çš„ï¼Œä½†æ˜¯æœ‰äº›æ—¶å€™åˆä¸å¯é¿å…çš„æœ‰ä¿®æ”¹å’Œè¯»å–éƒ½è¦å·¥ä½œçš„æ—¶å€™ï¼Œæ‰€ä»¥ä¾ç„¶å¿…é¡»å¾—ä½¿ç”¨äº’æ–¥é‡è¿›è¡Œä¿æŠ¤ã€‚

  ç„¶è€Œä½¿ç”¨ `std::mutex` çš„å¼€é”€æ˜¯è¿‡å¤§çš„ï¼Œå®ƒä¸ç®¡æœ‰æ²¡æœ‰å‘ç”Ÿæ•°æ®ç«äº‰ï¼ˆä¹Ÿå°±æ˜¯å°±ç®—å…¨æ˜¯è¯»çš„æƒ…å†µï¼‰ä¹Ÿå¿…é¡»æ˜¯è€è€å®å®ä¸Šé”è§£é”ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿è¡Œã€‚å¦‚æœä½ å­¦è¿‡å…¶å®ƒè¯­è¨€æˆ–è€…æ“ä½œç³»ç»Ÿï¼Œç›¸ä¿¡è¿™ä¸ªæ—¶å€™å°±å·²ç»æƒ³åˆ°äº†ï¼šâ€œ[***è¯»å†™é”***](https://zh.wikipedia.org/wiki/è¯»å†™é”)â€ã€‚

- è¯»å†™é”ä»‹ç»

  C++ æ ‡å‡†åº“è‡ªç„¶ä¸ºæˆ‘ä»¬æä¾›äº†ï¼š [`std::shared_timed_mutex`](https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex)ï¼ˆC++14ï¼‰ã€ [`std::shared_mutex`](https://zh.cppreference.com/w/cpp/thread/shared_mutex)ï¼ˆC++17ï¼‰ã€‚å®ƒä»¬çš„åŒºåˆ«ç®€å•æ¥è¯´ï¼Œå‰è€…æ”¯æŒæ›´å¤šçš„æ“ä½œæ–¹å¼ï¼Œåè€…æœ‰æ›´é«˜çš„æ€§èƒ½ä¼˜åŠ¿ã€‚

  `std::shared_mutex` åŒæ ·æ”¯æŒ `std::lock_guard`ã€`std::unique_lock`ã€‚å’Œ `std::mutex` åšçš„ä¸€æ ·ï¼Œä¿è¯*å†™çº¿ç¨‹*çš„ç‹¬å è®¿é—®ã€‚**è€Œé‚£äº›æ— éœ€ä¿®æ”¹æ•°æ®ç»“æ„çš„*è¯»çº¿ç¨‹*ï¼Œå¯ä»¥ä½¿ç”¨ [`std::shared_lock`](https://zh.cppreference.com/w/cpp/thread/shared_lock) è·å–è®¿é—®æƒ**ï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥ä¸€èµ·è¯»å–ã€‚

  ```c++
  class Settings {
  private:
      std::map<std::string, std::string> data_;
      //mutex_ é€šå¸¸ä¸ç®—åšç±»çŠ¶æ€ï¼ˆåªè¯»/å¯è¯»å¯å†™ï¼‰çš„ä¸€éƒ¨åˆ†ï¼Œæ‰€ä»¥é€šå¸¸éœ€è¦åŠ ä¸Šmutable
      mutable std::shared_mutex mutex_; // â€œM&M è§„åˆ™â€ï¼šmutable ä¸ mutex ä¸€èµ·å‡ºç°
  
  public:
      void set(const std::string& key, const std::string& value) {
          std::lock_guard<std::shared_mutex> lock{ mutex_ };
          data_[key] = value;
      }
  
      std::string get(const std::string& key) const {	// mutex_ åªè¯»å‡½æ•°ä¸­ä¹Ÿå¯ä¿®æ”¹
          // ä¸ç”¨shared_lockï¼Œç”¨mutex.lock_shared()å’Œmutex_.unlock_shared()éƒ½å¯ä»¥
          std::shared_lock<std::shared_mutex> lock(mutex_);
          auto it = data_.find(key);
          return (it != data_.end()) ? it->second : ""; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°é”®è¿”å›ç©ºå­—ç¬¦ä¸²
      }
  };
  ```

  `std::shared_timed_mutex` å…·æœ‰ `std::shared_mutex` çš„æ‰€æœ‰åŠŸèƒ½ï¼Œå¹¶ä¸”é¢å¤–æ”¯æŒè¶…æ—¶åŠŸèƒ½ã€‚æ‰€ä»¥ä»¥ä¸Šä»£ç å¯ä»¥éšæ„æ›´æ¢è¿™ä¸¤ä¸ªäº’æ–¥é‡ã€‚

## std::recursive_mutex

> - recursiveï¼šé€’å½’çš„
> - å¯¹äº`std::mutex`è€Œè¨€ï¼Œåœ¨åŒä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡è°ƒç”¨åŒä¸€ä¸ªäº’æ–¥é‡çš„`lock()`å‡½æ•°æ—¶ï¼Œæ˜¯æœªå®šä¹‰è¡Œä¸ºï¼›åªå…è®¸åœ¨ä¸åŒçº¿ç¨‹ä¸­å¯¹åŒä¸€ä¸ªäº’æ–¥é‡çš„é”å®šã€‚
> - å¯¹äº`std::recursive_mutex`è€Œè¨€ï¼Œå…è®¸åœ¨åŒä¸€ä¸ªçº¿ç¨‹å¤šæ¬¡è°ƒç”¨åŒä¸€ä¸ªäº’æ–¥é‡çš„`lock()`å‡½æ•°ï¼Œå½“**è§£é”ä¸é”å®šæ¬¡æ•°ç›¸åŒ¹é…æ—¶ï¼Œäº’æ–¥é‡æ‰ä¼šçœŸæ­£é‡Šæ”¾**ï¼›ä½†åŒæ—¶ä¸å½±å“ä¸åŒçº¿ç¨‹å¯¹åŒä¸€ä¸ªäº’æ–¥é‡è¿›è¡Œé”å®šçš„æƒ…å†µã€‚
> - å¯ä»¥ç”¨äºé€’å½’å‡½æ•°ä¸­

- å®šä¹‰ï¼š

  `std::recursive_mutex` æ˜¯ C++ æ ‡å‡†åº“æä¾›çš„ä¸€ç§äº’æ–¥é‡ç±»å‹ï¼Œå®ƒå…è®¸åŒä¸€çº¿ç¨‹å¤šæ¬¡é”å®šåŒä¸€ä¸ªäº’æ–¥é‡ï¼Œè€Œä¸ä¼šé€ æˆæ­»é”ã€‚å½“åŒä¸€çº¿ç¨‹å¤šæ¬¡å¯¹åŒä¸€ä¸ª `std::recursive_mutex` è¿›è¡Œé”å®šæ—¶ï¼Œ**åªæœ‰åœ¨è§£é”ä¸é”å®šæ¬¡æ•°ç›¸åŒ¹é…æ—¶ï¼Œäº’æ–¥é‡æ‰ä¼šçœŸæ­£é‡Šæ”¾**ã€‚ä½†å®ƒå¹¶ä¸å½±å“ä¸åŒçº¿ç¨‹å¯¹åŒä¸€ä¸ªäº’æ–¥é‡è¿›è¡Œé”å®šçš„æƒ…å†µã€‚ä¸åŒçº¿ç¨‹å¯¹åŒä¸€ä¸ªäº’æ–¥é‡è¿›è¡Œé”å®šæ—¶ï¼Œä¼šæŒ‰ç…§äº’æ–¥é‡çš„è§„åˆ™**è¿›è¡Œé˜»å¡**

  ```c++
  // å»ºè®®æ‹¿åˆ°IDEä¸Šè‡ªå·±è·‘ä¸€ä¸‹
  std::recursive_mutex mtx;
  
  void recursive_function(int count) {
      // é€’å½’å‡½æ•°ï¼Œæ¯æ¬¡é€’å½’éƒ½ä¼šé”å®šäº’æ–¥é‡
      mtx.lock();
      std::cout << "Locked by thread: " << std::this_thread::get_id() << ", count: " << count << std::endl;
      if (count > 0) {
          recursive_function(count - 1); // é€’å½’è°ƒç”¨
      }
      mtx.unlock(); // è§£é”äº’æ–¥é‡
  }
  int main() {
      std::thread t1(recursive_function, 3);
      std::thread t2(recursive_function, 2);
  
      t1.join();
      t2.join();
  }
  ```

  è§£é‡Šï¼š

  - æ ¹æ®è§„åˆ™ï¼Œå¦‚æœt1çº¿ç¨‹å…ˆæ‰§è¡Œï¼Œåˆ™t2çº¿ç¨‹ä¼šé˜»å¡ï¼›å¦‚æœt2çº¿ç¨‹å…ˆæ‰§è¡Œï¼Œåˆ™t1çº¿ç¨‹ä¼šé˜»å¡ã€‚
  -  `unlock` å¿…é¡»å’Œ `lock` çš„è°ƒç”¨æ¬¡æ•°ä¸€æ ·ï¼Œæ‰ä¼šçœŸæ­£è§£é”äº’æ–¥é‡ã€‚

- æ›´åŠ æ˜“è¯»çš„åšæ³•ï¼š

  åŒæ ·çš„ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ `std::lock_guard`ã€`std::unique_lock` å¸®æˆ‘ä»¬ç®¡ç† `std::recursive_mutex`ï¼Œè€Œéæ˜¾å¼è°ƒç”¨ `lock` ä¸ `unlock`ï¼š

  ```c++
  void recursive_function(int count) {
      std::lock_guard<std::recursive_mutex> lc{ mtx };
      std::cout << "Locked by thread: " << std::this_thread::get_id() << ", count: " << count << std::endl;
      if (count > 0) {
          recursive_function(count - 1);
      }
  }
  ```

## newï¼Œdeleteçš„çº¿ç¨‹å®‰å…¨æ€§ï¼Ÿï¼Ÿï¼Ÿ

[C++ ä¸­ new æ“ä½œç¬¦å†…å¹•ï¼šnew operatorã€operator newã€placement new - slgkaifa - åšå®¢å›­ï¼Ÿï¼Ÿï¼Ÿ](https://www.cnblogs.com/slgkaifa/p/6887887.html)

[operator new, operator new[] - cppreference.comï¼Ÿï¼Ÿï¼Ÿ](https://zh.cppreference.com/w/cpp/memory/new/operator_new)

[new è¡¨è¾¾å¼ - cppreference.com](https://zh.cppreference.com/w/cpp/language/new)

> - å¯¹äº`int* a = new int();`è€Œè¨€ï¼Œ`new int()`å«åšnewè¡¨è¾¾å¼ï¼Œåœ¨æ‰§è¡Œnewè¡¨è¾¾å¼çš„æ—¶å€™ï¼Œä¼šå…ˆè°ƒç”¨`operator new`å†³å®šéœ€è¦åˆ†é…çš„å†…å­˜å¤§å°ï¼Œå†è°ƒç”¨å¯¹åº”çš„æ„é€ å‡½æ•°**ï¼ˆé‡è¦ï¼ï¼ï¼ï¼‰**ã€‚
>
> - åªæœ‰C++11ä»¥ä¸Šçš„åº“å‡½æ•°ç‰ˆæœ¬çš„newï¼Œdeleteç­‰åˆ†é…/é‡Šæ”¾å†…å­˜ç›¸å…³çš„åº“å‡½æ•°æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†ä»–ä»¬å¹¶éåŸå­æ“ä½œï¼Œæ˜¯å¯ä»¥è¢«æ‰“æ–­çš„ã€‚
>
> - ä½†æ˜¯åœ¨æˆ‘ä»¬è°ƒç”¨new/deleteæ—¶ï¼Œæ¶‰åŠåˆ°çš„ä¸ä»…ä»…åªæœ‰è°ƒç”¨åº“å‡½æ•°è¿™ä¸€ä¸ªæ­¥éª¤ï¼Œæ‰€ä»¥æ˜¯å¦çº¿ç¨‹å®‰å…¨åº”è¯¥è€ƒè™‘ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š
>
>   1. `new` è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è¦è€ƒè™‘ä¸‰æ–¹é¢ï¼š`operator new`ã€æ„é€ å‡½æ•°ã€ä¿®æ”¹æŒ‡é’ˆã€‚
>
>   2. `delete` è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è€ƒè™‘ä¸¤æ–¹é¢ï¼š`operator delete`ã€ææ„å‡½æ•°ã€‚
>
>   3. C++ åªä¿è¯äº† `operator new`ã€`operator delete` è¿™ä¸¤ä¸ªæ–¹é¢çš„çº¿ç¨‹å®‰å…¨ï¼ˆä¸åŒ…æ‹¬ç”¨æˆ·å®šä¹‰çš„ï¼‰ï¼Œå…¶å®ƒæ–¹é¢å°±å¾—è‡ªå·±ä¿è¯äº†ã€‚å‰é¢çš„å†…å®¹ä¹Ÿéƒ½æåˆ°äº†ã€‚
>
> - ç»¼ä¸Šï¼Œ**æ˜¯å¦çº¿ç¨‹å®‰å…¨ä¸èƒ½ä»…ä»…åªçœ‹æ˜¯å¦ä½¿ç”¨new/deleteï¼Œè¿˜å¾—çœ‹æœ‰æ²¡æœ‰æ¶‰åŠåˆ°æ•°æ®ç«äº‰ï¼Œå…±äº«å˜é‡**ï¼Œè¦æ ¹æ®è¿™äº›æƒ…å†µè¿›è¡Œç»¼åˆåˆ¤å®š
>
> - **æ›´åŠ å®Œå–„çš„å›ç­”**ï¼šé¦–å…ˆéœ€è¦çŸ¥é“ï¼šå¯¹äºnewè¡¨è¾¾å¼è€Œè¨€ï¼Œä¼šå…ˆè°ƒç”¨`operator new`å†³å®šéœ€è¦åˆ†é…çš„å†…å­˜å¤§å°ï¼Œå†è°ƒç”¨å¯¹åº”çš„æ„é€ å‡½æ•°ï¼Œæœ€åè¿”å›æ„é€ å¥½çš„å¯¹è±¡çš„åœ°å€å¹¶èµ‹å€¼ç»™å¯¹åº”çš„æŒ‡é’ˆï¼ˆ`int* a = new int();`ï¼‰ã€‚
>
>   æ‰€ä»¥è¿™é‡Œå…¶å®æœ‰ä¸‰æ–¹é¢éœ€è¦è€ƒè™‘ï¼š1. `operator new`çš„åº“å‡½æ•°ç‰ˆæœ¬çº¿ç¨‹å®‰å…¨ã€‚2. æ„é€ å‡½æ•°ä¸ä¸€å®šçº¿ç¨‹å®‰å…¨ã€‚3. èµ‹å€¼æ“ä½œä¸ä¸€å®šçº¿ç¨‹å®‰å…¨ã€‚
>
> - è¡¥å……çŸ¥è¯†ï¼šå¯¹äºnew/deleteè¡¨è¾¾å¼è€Œè¨€ï¼Œç”³è¯·å’Œåˆ é™¤å†…å­˜æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸ºæ“ä½œç³»ç»Ÿå…¨å±€æœ‰ä¸€æŠŠå¤§é”ï¼ŒåŸºæœ¬å„è¯­è¨€å’Œè§„å®šä¹Ÿèƒ½ä¿è¯ã€‚

- å‰è¨€ï¼š

  å¦‚æœä½ çš„æ ‡å‡†è¾¾åˆ° **C++11**ï¼Œè¦æ±‚ä¸‹åˆ—**å‡½æ•°**æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼š

  - [`new` è¿ç®—ç¬¦](https://zh.cppreference.com/w/cpp/memory/new/operator_new)å’Œ [`delete` è¿ç®—ç¬¦](https://zh.cppreference.com/w/cpp/memory/new/operator_delete)çš„**åº“**ç‰ˆæœ¬
  - å…¨å±€ `new` è¿ç®—ç¬¦å’Œ `delete` è¿ç®—ç¬¦çš„ç”¨æˆ·æ›¿æ¢ç‰ˆæœ¬
  - [`std::calloc`](https://zh.cppreference.com/w/cpp/memory/c/calloc)ã€[`std::malloc`](https://zh.cppreference.com/w/cpp/memory/c/malloc)ã€[`std::realloc`](https://zh.cppreference.com/w/cpp/memory/c/realloc)ã€[`std::aligned_alloc`](https://zh.cppreference.com/w/cpp/memory/c/aligned_alloc) (C++17 èµ·)ã€[`std::free`](https://zh.cppreference.com/w/cpp/memory/c/free)

- å¯¹å±€éƒ¨å˜é‡ä½¿ç”¨new/deleteï¼š

  ```c++
  void f(){
      T* p = new T{};
      delete p;
  }
  ```

  è§£é‡Šï¼š

  - è¯¥ä»£ç åœ¨å¤šçº¿ç¨‹æ‰§è¡Œ`f()`æ—¶å¦‚æœæ„é€ å’Œææ„ä¸æ¶‰åŠå…±äº«èµ„æºï¼Œåˆ™æ˜¾ç„¶çº¿ç¨‹å®‰å…¨
  - `::operator new`å’Œ`::operator delete`æ˜¾ç„¶çº¿ç¨‹å®‰å…¨ï¼›å±€éƒ¨å¯¹è±¡ `p` å¯¹äºæ¯ä¸ªçº¿ç¨‹æ¥è¯´æ˜¯ç‹¬ç«‹çš„ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰å…¶è‡ªå·±çš„ `p` å¯¹è±¡å®ä¾‹ï¼Œå®ƒä»¬ä¸ä¼šå…±äº«åŒä¸€ä¸ªå¯¹è±¡ï¼Œæ²¡æœ‰æ•°æ®ç«äº‰ï¼›å¦‚æœæ„é€ å’Œææ„ä¸æ¶‰åŠå…±äº«èµ„æºï¼Œåˆ™æ˜æ˜¾çº¿ç¨‹å®‰å…¨

- å¯¹å…¨å±€å˜é‡ä½¿ç”¨new/deleteï¼š

  å¦‚æœ `p` æ˜¯å…¨å±€å¯¹è±¡ï¼ˆæˆ–è€…å¤–éƒ¨çš„ï¼Œåªè¦å¯è¢«å¤šä¸ªçº¿ç¨‹è¯»å†™ï¼‰ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹å…¶è¿›è¡Œè®¿é—®å’Œä¿®æ”¹æ—¶ï¼Œå°±å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«äº‰å’Œæœªå®šä¹‰è¡Œä¸ºã€‚å› æ­¤ï¼Œç¡®ä¿å…¨å±€å¯¹è±¡çš„çº¿ç¨‹å®‰å…¨è®¿é—®é€šå¸¸éœ€è¦é¢å¤–çš„åŒæ­¥æªæ–½ï¼Œæ¯”å¦‚äº’æ–¥é‡æˆ–åŸå­æ“ä½œã€‚

  ```c++
  T* p = nullptr;
  void f(){
      p = new T{}; // å­˜åœ¨æ•°æ®ç«äº‰
      delete p;
  }
  ```

  è§£é‡Šï¼š

  - æ˜¾ç„¶çº¿ç¨‹ä¸å®‰å…¨ï¼Œnewæ“ä½œç¬¦ç»“æŸä¹‹åï¼Œç»™pèµ‹å€¼æ—¶ï¼Œæ¶‰åŠåˆ°æ•°æ®ç«äº‰ï¼Œçº¿ç¨‹ä¸å®‰å…¨

- new/deleteæ—¶æ¶‰åŠåˆ°çš„æ„é€ /ææ„å‡½æ•°æœ‰è¯»å†™å…±äº«æ•°æ®

  å³ä½¿ `p` æ˜¯å±€éƒ¨å¯¹è±¡ï¼Œå¦‚æœæ„é€ å‡½æ•°ï¼ˆææ„åŒç†ï¼‰æ¶‰åŠè¯»å†™å…±äº«èµ„æºï¼Œé‚£ä¹ˆä¸€æ ·å­˜åœ¨æ•°æ®ç«äº‰ï¼Œéœ€è¦è¿›è¡Œé¢å¤–çš„åŒæ­¥æªæ–½è¿›è¡Œä¿æŠ¤ã€‚

  ```c++
  int n = 1;
  
  struct X{
      X(int v){
          ::n += v;
      }
  };
  
  void f(){
      X* p = new X{ 1 }; // å­˜åœ¨æ•°æ®ç«äº‰
      delete p;
  }
  ```

  è§£é‡Šï¼š

  - è¿™æ˜¯ç¬¬ä¸€ç§æƒ…å†µç§çš„å˜ä½“ç‰ˆæœ¬ï¼Œåœ¨æ„é€ å‡½æ•°ä¸­è¯»å†™å…±äº«å˜é‡ï¼Œæ˜¾ç„¶çº¿ç¨‹ä¸å®‰å…¨

- è‡ªå®šä¹‰çš„operator new/operator delete

  å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæ˜¯è‡ªå·±é‡è½½ `operator new`ã€`operator delete` æ›¿æ¢äº†åº“çš„**å…¨å±€**ç‰ˆæœ¬ï¼Œé‚£ä¹ˆå®ƒçš„çº¿ç¨‹å®‰å…¨å°±è¦æˆ‘ä»¬æ¥ä¿è¯ã€‚

  ```c++
  // å…¨å±€çš„ new è¿ç®—ç¬¦ï¼Œæ›¿æ¢äº†åº“çš„ç‰ˆæœ¬
  void* operator new  (std::size_t count){
      return ::operator new(count); 
  }
  ```

  ä»¥ä¸Šä»£ç æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå› ä¸º C++11 ä¿è¯äº† new è¿ç®—ç¬¦çš„åº“ç‰ˆæœ¬ï¼Œå³ `::operator new` æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæˆ‘ä»¬ç›´æ¥è°ƒç”¨å®ƒè‡ªç„¶ä¸æˆé—®é¢˜ã€‚å¦‚æœä½ éœ€è¦æ›´å¤šçš„æ“ä½œï¼Œå°±å¾—ä½¿ç”¨äº’æ–¥é‡ä¹‹ç±»çš„æ–¹å¼ä¿æŠ¤äº†ã€‚

- æ€»ç»“ï¼š

  æ€»è€Œè¨€ä¹‹ï¼Œ`new` è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è¦è€ƒè™‘ä¸‰æ–¹é¢ï¼š`operator new`ã€æ„é€ å‡½æ•°ã€ä¿®æ”¹æŒ‡é’ˆã€‚

  `delete` è¡¨è¾¾å¼çº¿ç¨‹å®‰å…¨è€ƒè™‘ä¸¤æ–¹é¢ï¼š`operator delete`ã€ææ„å‡½æ•°ã€‚

  C++ åªä¿è¯äº† `operator new`ã€`operator delete` è¿™ä¸¤ä¸ªæ–¹é¢çš„çº¿ç¨‹å®‰å…¨ï¼ˆä¸åŒ…æ‹¬ç”¨æˆ·å®šä¹‰çš„ï¼‰ï¼Œå…¶å®ƒæ–¹é¢å°±å¾—è‡ªå·±ä¿è¯äº†ã€‚å‰é¢çš„å†…å®¹ä¹Ÿéƒ½æåˆ°äº†ã€‚

## å­˜å‚¨ç±»è¯´æ˜ç¬¦

[å¿…çœ‹ï¼šå­˜å‚¨ç±»è¯´æ˜ç¬¦ - cppreference.com](https://zh.cppreference.com/w/cpp/language/storage_duration)

ä»¥ä¸‹å…³é”®è¯æ˜¯*å­˜å‚¨ç±»è¯´æ˜ç¬¦*â€Šï»¿ï¼š

```c++
auto			// (C++11 å‰) 
register		// (C++17 å‰) 
static
thread_local	// (C++11 èµ·) 
extern
mutable
```

*å£°æ˜è¯´æ˜ç¬¦åºåˆ—*â€Šï»¿ä¸­åªèƒ½å‡ºç°ä¸€ä¸ªå­˜å‚¨ç±»è¯´æ˜ç¬¦ï¼Œä½† thread_local å¯ä»¥ä¸ static æˆ– extern ä¸€èµ·å‡ºç°(C++11 èµ·)ã€‚

mutable ä¸ä¼šå½±å“å­˜å‚¨æœŸã€‚å®ƒçš„ç”¨æ³•å‚è€ƒ [const/volatile](https://zh.cppreference.com/w/cpp/language/cv)ã€‚

å…¶ä»–å­˜å‚¨ç±»è¯´æ˜ç¬¦å¯ä»¥åœ¨ä»¥ä¸‹å£°æ˜çš„*å£°æ˜è¯´æ˜ç¬¦åºåˆ—*â€Šï»¿ä¸­å‡ºç°ï¼š

![image-20250109150822541](assets/image-20250109150822541.png)

ç”±ä¸Šï¼Œthread_localå¯ä»¥ä¿®é¥°ï¼š1. é™æ€æˆå‘˜ã€‚2. æ™®é€š/é™æ€å…¨å±€å˜é‡ã€‚3. æ™®é€š/é™æ€å±€éƒ¨å˜é‡

## çº¿ç¨‹å­˜å‚¨æœŸ

[å¿…çœ‹ï¼šC++11ä¸­thread_localçš„ä½¿ç”¨](https://blog.csdn.net/fengbingchun/article/details/108691986)

> - å…¶å®å¯ä»¥æŠŠçº¿ç¨‹å­˜å‚¨æœŸçš„å˜é‡å’Œå…¨å±€å­˜å‚¨æœŸçš„å˜é‡è¿›è¡Œå¯¹æ¯”ï¼Œä¼šå‘ç°å…¶å®ä¸¤è€…éƒ½å·®ä¸å¤šï¼Œåªæœ‰åœ¨å­˜å‚¨æœŸä¸Šæœ‰å·®åˆ«ã€‚
> - `thread_local` åªå¯¹å£°æ˜äºå‘½åç©ºé—´ä½œç”¨åŸŸçš„å¯¹è±¡ã€å£°æ˜äºå—ä½œç”¨åŸŸçš„å¯¹è±¡ä»¥åŠé™æ€æ•°æ®æˆå‘˜å…è®¸ã€‚å®ƒæŒ‡ç¤ºå¯¹è±¡æ‹¥æœ‰**çº¿ç¨‹å­˜å‚¨æœŸ**ã€‚å®ƒèƒ½ä¸ `static` æˆ– `extern` ç»“åˆï¼Œä»¥åˆ†åˆ«æŒ‡å®šå†…éƒ¨æˆ–å¤–éƒ¨é“¾æ¥ï¼ˆé™¤äº†é™æ€æ•°æ®æˆå‘˜å§‹ç»ˆæ‹¥æœ‰å¤–éƒ¨é“¾æ¥ï¼‰ï¼Œä½†é™„åŠ çš„ `static` ä¸å½±å“å­˜å‚¨æœŸã€‚
> - **çº¿ç¨‹å­˜å‚¨æœŸ**ï¼šå¯¹è±¡çš„å­˜å‚¨åœ¨çº¿ç¨‹å¼€å§‹æ—¶åˆ†é…ï¼Œè€Œåœ¨çº¿ç¨‹ç»“æŸæ—¶è§£åˆ†é…ã€‚æ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰å…¶è‡ªèº«çš„å¯¹è±¡å®ä¾‹ã€‚å”¯æœ‰å£°æ˜ä¸º `thread_local` çš„å¯¹è±¡æ‹¥æœ‰æ­¤å­˜å‚¨æœŸã€‚ `thread_local` èƒ½ä¸ `static` æˆ– `extern` ä¸€åŒå‡ºç°ï¼Œä»¥è°ƒæ•´é“¾æ¥ã€‚
> - **çº¿ç¨‹å˜é‡åˆå§‹åŒ–æ—¶æœŸ**ï¼š
>   - éå±€éƒ¨å˜é‡ï¼ˆå…¨å±€å˜é‡ï¼Œç±»ä¸­çš„é™æ€æˆå‘˜å˜é‡ï¼‰ï¼šæ‰€æœ‰å…·æœ‰çº¿ç¨‹å±€éƒ¨å­˜å‚¨æœŸçš„éå±€éƒ¨å˜é‡çš„åˆå§‹åŒ–ï¼Œä¼š**ä½œä¸ºçº¿ç¨‹å¯åŠ¨çš„ä¸€éƒ¨åˆ†è¿›è¡Œ**ï¼Œå¹¶æŒ‰é¡ºåºæ—©äºçº¿ç¨‹å‡½æ•°çš„æ‰§è¡Œå¼€å§‹ã€‚
>   - é™æ€å±€éƒ¨å˜é‡[[4]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote4)ï¼ˆåŒ…æ‹¬æ™®é€šé™æ€å±€éƒ¨å˜é‡ä»¥åŠ`thread_local`ä¿®é¥°çš„é™æ€å±€éƒ¨å˜é‡ï¼‰ï¼šæ§åˆ¶æµé¦–æ¬¡**ç»è¿‡å®ƒçš„å£°æ˜**æ—¶æ‰ä¼šè¢«åˆå§‹åŒ–ï¼ˆé™¤éå®ƒè¢«[é›¶åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/zero_initialization)æˆ–[å¸¸é‡åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/constant_initialization)ï¼‰ã€‚åœ¨å…¶åæ‰€æœ‰çš„è°ƒç”¨ä¸­ï¼Œå£°æ˜éƒ½ä¼šè¢«è·³è¿‡ã€‚

- å®šä¹‰ï¼š

  **çº¿ç¨‹æœ¬åœ°å­˜å‚¨ (TLS)**æ˜¯ C++ 11 ä¸­å¼•å…¥çš„ä¸€é¡¹åŠŸèƒ½ï¼Œå…è®¸å¤šçº¿ç¨‹ç¨‹åºä¸­çš„æ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰è‡ªå·±å•ç‹¬çš„å˜é‡å®ä¾‹ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å¯ä»¥è¯´æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥æœ‰è‡ªå·±ç‹¬ç«‹çš„å˜é‡å®ä¾‹ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥è®¿é—®å’Œä¿®æ”¹è‡ªå·±çš„å˜é‡å‰¯æœ¬ï¼Œè€Œä¸ä¼šå¹²æ‰°å…¶ä»–çº¿ç¨‹ã€‚

- çº¿ç¨‹æœ¬åœ°å­˜å‚¨ (TLS) çš„å±æ€§

  - **ç”Ÿå‘½å‘¨æœŸï¼š** TLS å˜é‡çš„ç”Ÿå‘½å‘¨æœŸä»åˆå§‹åŒ–æ—¶å¼€å§‹ï¼Œåˆ°çº¿ç¨‹ç»ˆæ­¢æ—¶ç»“æŸã€‚
  - **å¯è§æ€§ï¼š** TLS å˜é‡åœ¨çº¿ç¨‹çº§åˆ«å…·æœ‰å¯è§æ€§ã€‚
  - **ä½œç”¨åŸŸï¼š**thread_localåªæ”¹å˜äº†å˜é‡çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¸ä¼šæ”¹å˜å˜é‡ä½œç”¨åŸŸã€‚ï¼ˆstaticä¹Ÿä¸€æ ·ï¼Œä¹Ÿå°±æ˜¯è¯´çº¿ç¨‹å±€éƒ¨å˜é‡åªèƒ½åœ¨å½“å‰ä½œç”¨åŸŸä¸­è®¿é—®ï¼Œä¸èƒ½åœ¨å…¶ä»–çš„ä½œç”¨åŸŸæˆ–è€…å…¶ä»–å‡½æ•°ä¸­è®¿é—®è¯¥å±€éƒ¨å˜é‡ï¼‰
  
- å®é™…æ•ˆæœ

  - å¯¹äºå…¨å±€ä¸­å®šä¹‰çš„`thread_local`å˜é‡è€Œè¨€ï¼Œå°±æ˜¯å°†å…¨å±€å˜é‡åœ¨å„ä¸ªçº¿ç¨‹éƒ½copyä¸€ä»½ï¼Œäº’ä¸å¹²æ‰°ç‹¬ç«‹ä½¿ç”¨ã€‚
  - å¯¹äºç±»ä¸­å®šä¹‰çš„`thread_local`æˆå‘˜å˜é‡è€Œè¨€ï¼Œå¿…é¡»ç”¨`static`ä¿®é¥°ï¼Œä¸”åŒä¸€ä¸ªçº¿ç¨‹å†…çš„è¯¥ç±»çš„å¤šä¸ªå¯¹è±¡éƒ½ä¼šå…±äº«ä¸€ä¸ªå˜é‡å®ä¾‹ï¼Œå¹¶ä¸”åªä¼šåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿™ä¸ªæˆå‘˜å‡½æ•°æ—¶åˆå§‹åŒ–è¿™ä¸ªå˜é‡å®ä¾‹ï¼Œè¿™ä¸€ç‚¹æ˜¯è·Ÿç±»çš„é™æ€æˆå‘˜å˜é‡ç±»ä¼¼çš„ï¼Œ**ä¸è¿‡é™æ€æˆå‘˜å˜é‡å…·æœ‰å…¨å±€å­˜å‚¨æœŸï¼Œ`thread_local`é™æ€æˆå‘˜å˜é‡å…·æœ‰çº¿ç¨‹å­˜å‚¨æœŸ**
  - å¯¹äºç±»çš„æˆå‘˜å‡½æ•°/æ™®é€šå‡½æ•°ä¸­å®šä¹‰çš„`thread_local`å˜é‡è€Œè¨€ï¼Œ**é»˜è®¤æ˜¯é™æ€çš„**ï¼Œä¸”åŒä¸€ä¸ªçº¿ç¨‹å†…çš„è¯¥ç±»çš„å¤šä¸ªå¯¹è±¡éƒ½ä¼šå…±äº«ä¸€ä¸ªå˜é‡å®ä¾‹ï¼Œå¹¶ä¸”åªä¼šåœ¨ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿™ä¸ªæˆå‘˜å‡½æ•°æ—¶åˆå§‹åŒ–è¿™ä¸ªå˜é‡å®ä¾‹ï¼Œè¿™ä¸€ç‚¹æ˜¯è·Ÿå±€éƒ¨é™æ€æˆå‘˜å˜é‡ç±»ä¼¼çš„ï¼Œ**ä¸è¿‡å±€éƒ¨é™æ€å˜é‡å…·æœ‰å…¨å±€å­˜å‚¨æœŸï¼Œ`thread_local`å±€éƒ¨é™æ€å˜é‡å…·æœ‰çº¿ç¨‹å­˜å‚¨æœŸ**

- ä»£ç æ¼”ç¤ºï¼š

  ```c++
  class A {
  public:
      static thread_local int tmp1;
      void operator()() {
          static thread_local int tmp2 = 0;
          cout << this_thread::get_id() << " tmp1: " << tmp1++ << endl;
          cout << "  tmp2: " << tmp2++ << endl;
      }
  };
  thread_local int A::tmp1 = 0;
  
  // a, bæ˜¯å…¨å±€å˜é‡ï¼Œå¯¹äºçº¿ç¨‹æ¥è¯´ï¼Œä¹Ÿå°±æ˜¯å…±äº«æ•°æ®ï¼Œä»¥æ­¤è§‚æµ‹thread_localå˜é‡åœ¨ä¸åŒçº¿ç¨‹ï¼Œä»¥åŠåŒä¸€ä¸ªçº¿ç¨‹ä¸åŒå¯¹è±¡ä¸­çš„è¡¨ç°
  A a;
  A b;
  void f() {	// åˆ†åˆ«è°ƒç”¨operator()
      a();
      b();
  }
  
  int main() {
      thread(f).join();
      thread(f).join();
      f();
  }
  ```

  ç»“æœï¼š

  ```c++
  19220 tmp1: 0
    tmp2: 0
  19220 tmp1: 1
    tmp2: 1
  27608 tmp1: 0
    tmp2: 0
  27608 tmp1: 1
    tmp2: 1
  25908 tmp1: 0
    tmp2: 0
  25908 tmp1: 1
    tmp2: 1
  ```

  è‡³äº`thread_local`ä¿®é¥°çš„å˜é‡åœ¨ä½•æ—¶åˆå§‹åŒ–ï¼Œçœ‹[#è¿™é‡Œ](#å±€éƒ¨ï¼Œå…¨å±€ï¼Œçº¿ç¨‹ï¼ŒCPU å˜é‡å¯¹æ¯”ä¸ä½¿ç”¨)ï¼š

  ```c++
  class A {
  public:
      static thread_local int tmp1;	// çº¿ç¨‹é™æ€æˆå‘˜å˜é‡
      void operator()() {
          cout << "function" << endl;
          static thread_local int tmp2 = (puts("init1"),0);	// çº¿ç¨‹é™æ€å±€éƒ¨å˜é‡
      }
  };
  thread_local int A::tmp1 = (puts("init"),0);
  
  // a, bæ˜¯å…¨å±€å˜é‡ï¼Œå¯¹äºçº¿ç¨‹æ¥è¯´ï¼Œä¹Ÿå°±æ˜¯å…±äº«æ•°æ®ï¼Œä»¥æ­¤è§‚æµ‹thread_localå˜é‡åœ¨ä¸åŒçº¿ç¨‹ï¼Œä»¥åŠåŒä¸€ä¸ªçº¿ç¨‹ä¸åŒå¯¹è±¡ä¸­çš„è¡¨ç°
  A a;
  A a1;
  void f() {	// åˆ†åˆ«è°ƒç”¨operator()
      a();
      a1();
  }
  
  int main() {
      cout << "main" << endl;
      f();
  }
  /************MSVC************/
  // init
  // main
  // function
  // init1
  // function
  /************g++************/
  // main
  // function
  // init1
  // function
  ```

  è§£é‡Šï¼š

  1. å¯¹äºç±»ä¸­çš„thread_localé™æ€æˆå‘˜å˜é‡è€Œè¨€ï¼Œä¸thread_localé™æ€å…¨å±€å˜é‡ç±»ä¼¼ï¼Œä¼šåœ¨çº¿ç¨‹å‡½æ•°æ‰§è¡Œå‰åˆå§‹åŒ–ï¼ˆä¸è®ºæ˜¯å¦åˆ›å»ºAçš„å¯¹è±¡ï¼Œéƒ½ä¼šå¦‚æ­¤ï¼Œä¹Ÿå¾ˆå¥½ç†è§£ï¼‰ï¼Œä½†g++æœ‰ä¼˜åŒ–ï¼š**g++ä¼šåœ¨é¦–æ¬¡ä½¿ç”¨çº¿ç¨‹å…¨å±€é™æ€å˜é‡çš„åœ°æ–¹æŒ‰é¡ºåºåˆå§‹åŒ–æ‰€æœ‰çš„çº¿ç¨‹å…¨å±€é™æ€å˜é‡ï¼Œè€Œæ™®é€šçš„å…¨å±€é™æ€å˜é‡åˆ™å’ŒMSVCä¸€æ ·ï¼Œåœ¨ä¸»çº¿ç¨‹å‡½æ•°æ‰§è¡Œå‰å°±åˆå§‹åŒ–**ã€‚

     ```c++
     thread_local static int aaa = (puts("aaa"), 0);
     thread_local static int bbb = (puts("bbb"), 1);
     int main() {
         cout << "main" << endl;
         cout << "---: " << bbb << endl;
     }
     // main
     // ---: aaa
     // bbb
     // 1
     ```

  2. å¯¹äºç±»ä¸­æˆå‘˜å‡½æ•°çš„thread_localé™æ€å±€éƒ¨å˜é‡è€Œè¨€ï¼Œä¸thread_localé™æ€å±€éƒ¨å˜é‡ç±»ä¼¼ï¼Œä¼šåœ¨æ§åˆ¶æµé¦–æ¬¡ç»è¿‡å£°æ˜æ—¶è¿›è¡Œä¸€æ¬¡ä¹Ÿæ˜¯å”¯ä¸€ä¸€æ¬¡çš„åˆå§‹åŒ–ã€‚

- åº”ç”¨åœºæ™¯ï¼š

  1. **çº¿ç¨‹ç‰¹å®šæ•°æ®**ï¼šæœ‰æ—¶ï¼Œä½ å¯èƒ½éœ€è¦ä¸ºæ¯ä¸ªçº¿ç¨‹å­˜å‚¨ä¸€äº›ç‰¹å®šçš„æ•°æ®ï¼Œä¾‹å¦‚çº¿ç¨‹çš„ IDã€çŠ¶æ€æˆ–å…¶ä»–ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ä½ å¯ä»¥ä½¿ç”¨ TLS æ¥å­˜å‚¨è¿™äº›æ•°æ®ã€‚

  2. **é¿å…å…¨å±€å˜é‡**ï¼šå…¨å±€å˜é‡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­å¯èƒ½ä¼šå¼•å‘æ•°æ®ç«äº‰å’ŒåŒæ­¥é—®é¢˜ã€‚ä½ å¯ä»¥ä½¿ç”¨ TLS æ¥æ›¿ä»£å…¨å±€å˜é‡ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„å˜é‡å‰¯æœ¬ï¼Œä»è€Œé¿å…è¿™äº›é—®é¢˜ã€‚

  3. **æ€§èƒ½ä¼˜åŒ–**ï¼šåœ¨ä¸€äº›æƒ…å†µä¸‹ï¼Œä½¿ç”¨ TLS å¯ä»¥æé«˜æ€§èƒ½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°éœ€è¦ä¸€ä¸ªå¤§çš„ç¼“å†²åŒºï¼Œè€Œè¿™ä¸ªå‡½æ•°åœ¨å¤šä¸ªçº¿ç¨‹ä¸­éƒ½è¢«é¢‘ç¹è°ƒç”¨ï¼Œé‚£ä¹ˆæ¯æ¬¡è°ƒç”¨éƒ½åˆ†é…å’Œé‡Šæ”¾ç¼“å†²åŒºå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚ä½ å¯ä»¥ä½¿ç”¨ TLS æ¥ä¸ºæ¯ä¸ªçº¿ç¨‹åˆ†é…ä¸€ä¸ªç¼“å†²åŒºï¼Œç„¶ååœ¨å¤šæ¬¡è°ƒç”¨ä¹‹é—´é‡ç”¨è¿™ä¸ªç¼“å†²åŒºã€‚

  4. **é”™è¯¯å¤„ç†**ï¼šåœ¨ä¸€äº›ç¼–ç¨‹ç¯å¢ƒä¸­ï¼Œä¾‹å¦‚ Cï¼Œé”™è¯¯ä¿¡æ¯é€šå¸¸é€šè¿‡å…¨å±€å˜é‡æ¥ä¼ é€’ã€‚è¿™åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­å¯èƒ½ä¼šå¼•å‘é—®é¢˜ï¼Œå› ä¸ºä¸€ä¸ªçº¿ç¨‹çš„é”™è¯¯å¯èƒ½ä¼šè¦†ç›–å¦ä¸€ä¸ªçº¿ç¨‹çš„é”™è¯¯ã€‚ä½ å¯ä»¥ä½¿ç”¨ TLS æ¥ä¸ºæ¯ä¸ªçº¿ç¨‹å­˜å‚¨é”™è¯¯ä¿¡æ¯ï¼Œä»è€Œé¿å…è¿™ä¸ªé—®é¢˜ã€‚
  
- [#æ€»ç»“](#çº¿ç¨‹å­˜å‚¨æœŸ)

## CPUå˜é‡

CPU å˜é‡çš„æ¦‚å¿µå¾ˆå¥½ç†è§£ã€‚å°±åƒçº¿ç¨‹å˜é‡ä¸ºæ¯ä¸ªçº¿ç¨‹æä¾›ç‹¬ç«‹çš„å¯¹è±¡å®ä¾‹ï¼Œäº’ä¸å¹²æ‰°ä¸€æ ·ï¼ŒCPU å˜é‡ä¹Ÿæ˜¯å¦‚æ­¤ã€‚åœ¨åˆ›å»º CPU å˜é‡æ—¶ï¼Œç³»ç»Ÿä¸Šçš„æ¯ä¸ª CPU [[2\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote2) éƒ½ä¼šè·å¾—è¯¥å˜é‡çš„ä¸€ä¸ªå‰¯æœ¬ï¼ˆæ¯”å¦‚4æ ¸å¿ƒ8çº¿ç¨‹çš„cpuï¼Œå°±ä¼šè·å¾—8ä¸ªå‰¯æœ¬ï¼‰ã€‚

åœ¨ Linux å†…æ ¸ä¸­ï¼Œä» 2.6[[3\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote3) ç‰ˆæœ¬å¼€å§‹å¼•å…¥äº† **Per-CPU** å˜é‡ï¼ˆPer-CPU variablesï¼‰åŠŸèƒ½ã€‚Per-CPU å˜é‡æ˜¯ä¸ºæ¯ä¸ªå¤„ç†å™¨å•ç‹¬åˆ†é…çš„å˜é‡å‰¯æœ¬ï¼Œæ—¨åœ¨å‡å°‘å¤šå¤„ç†å™¨è®¿é—®å…±äº«æ•°æ®æ—¶çš„åŒæ­¥å¼€é”€ï¼Œæå‡æ€§èƒ½ã€‚æ¯ä¸ªå¤„ç†å™¨åªè®¿é—®è‡ªå·±çš„å˜é‡å‰¯æœ¬ï¼Œä¸éœ€è¦è¿›è¡ŒåŒæ­¥æ“ä½œï¼Œé¿å…äº†æ•°æ®ç«äº‰ï¼Œå¢å¼ºäº†å¹¶è¡Œå¤„ç†èƒ½åŠ›ã€‚

åœ¨ Windows å†…æ ¸ä¸­ï¼Œæ²¡æœ‰ç›´æ¥å¯¹åº”çš„ Per-CPU å˜é‡æœºåˆ¶ã€‚

æœ¬èŠ‚æ˜¯åå‘æ¦‚å¿µçš„è®¤è¯†ï¼Œè€Œéå®é™…è¿›è¡Œå†…æ ¸ç¼–ç¨‹ï¼ŒC++ è¯­è¨€å±‚é¢ä¹Ÿå¹¶æœªæä¾›æ­¤æŠ½è±¡ã€‚ç†è§£ CPU å˜é‡çš„æ¦‚å¿µå¯¹äºç³»ç»Ÿç¼–ç¨‹å’Œå†…æ ¸å¼€å‘éå¸¸é‡è¦ã€‚è¿™äº›æ¦‚å¿µåœ¨é¢è¯•å’ŒæŠ€æœ¯è®¨è®ºä¸­å¸¸å¸¸å‡ºç°ï¼ŒæŒæ¡è¿™äº›çŸ¥è¯†ä¸ä»…æœ‰åŠ©äºåº”å¯¹é¢è¯•é—®é¢˜ï¼Œä¹Ÿèƒ½æå‡å¯¹å¤šå¤„ç†å™¨ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–çš„ç†è§£ã€‚

## å±€éƒ¨ï¼Œå…¨å±€ï¼Œçº¿ç¨‹ï¼ŒCPU å˜é‡å¯¹æ¯”ä¸ä½¿ç”¨ï¼Ÿï¼Ÿï¼Ÿ

åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œä¸åŒçš„å˜é‡æœ‰ä¸åŒçš„ä½¿ç”¨åœºæ™¯å’Œç‰¹ç‚¹ã€‚ä»¥ä¸‹æ˜¯å±€éƒ¨å˜é‡ã€å…¨å±€å˜é‡ã€çº¿ç¨‹å˜é‡ã€CPUå˜é‡çš„å¯¹æ¯”ï¼š

- å±€éƒ¨å˜é‡ï¼ˆä¸è€ƒè™‘é™æ€å±€éƒ¨ï¼‰

  - å®ƒæ‹¥æœ‰è‡ªåŠ¨å­˜å‚¨æœŸï¼Œéšä½œç”¨åŸŸå¼€å§‹åˆ†é…ï¼Œç»“æŸæ—¶é‡Šæ”¾ã€‚æ¯ä¸ªçº¿ç¨‹ã€æ¯æ¬¡è°ƒç”¨éƒ½æœ‰ç‹¬ç«‹å®ä¾‹ï¼Œå®Œå…¨ç‹¬ç«‹ï¼Œå‡ ä¹æ— éœ€åŒæ­¥ã€‚

- å…¨å±€å˜é‡

  - æ‹¥æœ‰ ***é™æ€ï¼ˆstaticï¼‰*** [å­˜å‚¨æœŸ](https://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F)ï¼Œå®ƒçš„å­˜å‚¨åœ¨**ç¨‹åº**å¼€å§‹æ—¶åˆ†é…ï¼Œå¹¶åœ¨ç¨‹åºç»“æŸæ—¶è§£åˆ†é…ï¼›ä¸”å®ƒåœ¨ä¸»å‡½æ•°æ‰§è¡Œä¹‹å‰è¿›è¡Œ[åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/initialization#.E9.9D.9E.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F)ã€‚

- çº¿ç¨‹å˜é‡

  - æ‹¥æœ‰**çº¿ç¨‹ï¼ˆthreadï¼‰**å­˜å‚¨æœŸã€‚å®ƒçš„å­˜å‚¨åœ¨çº¿ç¨‹å¼€å§‹æ—¶åˆ†é…ï¼Œå¹¶åœ¨çº¿ç¨‹ç»“æŸæ—¶è§£åˆ†é…ã€‚æ¯ä¸ªçº¿ç¨‹æ‹¥æœ‰å®ƒè‡ªèº«çš„å¯¹è±¡å®ä¾‹ã€‚åªæœ‰å£°æ˜ä¸º thread_local çš„å¯¹è±¡æ‹¥æœ‰æ­¤å­˜å‚¨æœŸï¼ˆä¸è€ƒè™‘éæ ‡å‡†ç”¨æ³•ï¼‰ã€‚å®ƒçš„**åˆå§‹åŒ–**éœ€è¦è€ƒè™‘å±€éƒ¨ä¸éå±€éƒ¨ä¸¤ç§æƒ…å†µï¼š

    - éå±€éƒ¨å˜é‡ï¼ˆå…¨å±€å˜é‡ï¼Œç±»ä¸­çš„é™æ€æˆå‘˜å˜é‡ï¼‰ï¼šæ‰€æœ‰å…·æœ‰çº¿ç¨‹å±€éƒ¨å­˜å‚¨æœŸçš„éå±€éƒ¨å˜é‡çš„åˆå§‹åŒ–ï¼Œä¼š**ä½œä¸ºçº¿ç¨‹å¯åŠ¨çš„ä¸€éƒ¨åˆ†è¿›è¡Œ**ï¼Œå¹¶æŒ‰é¡ºåºæ—©äºçº¿ç¨‹å‡½æ•°çš„æ‰§è¡Œå¼€å§‹ã€‚
    - é™æ€å±€éƒ¨å˜é‡[[4]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote4)ï¼ˆåŒ…æ‹¬æ™®é€šé™æ€å±€éƒ¨å˜é‡ä»¥åŠ`thread_local`ä¿®é¥°çš„é™æ€å±€éƒ¨å˜é‡ï¼‰ï¼šæ§åˆ¶æµé¦–æ¬¡**ç»è¿‡å®ƒçš„å£°æ˜**æ—¶æ‰ä¼šè¢«åˆå§‹åŒ–ï¼ˆé™¤éå®ƒè¢«[é›¶åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/zero_initialization)æˆ–[å¸¸é‡åˆå§‹åŒ–](https://zh.cppreference.com/w/cpp/language/constant_initialization)ï¼‰ã€‚åœ¨å…¶åæ‰€æœ‰çš„è°ƒç”¨ä¸­ï¼Œå£°æ˜éƒ½ä¼šè¢«è·³è¿‡ã€‚

  - ç¤ºä¾‹ï¼š

    ```c++
    thread_local int n = (puts("init n"), 0);
    
    void f() {
    	puts("thread f");
    }
    
    void f2() {
    	cout << "f2" << endl;
    	thread_local static int n = (puts("init f2 n"), 0);
    }
    
    int main() {
    	cout << "main" << endl;	// ä¸»çº¿ç¨‹ä¸­çš„thread_localéå±€éƒ¨å˜é‡åˆå§‹åŒ–æ—¶æœŸ
    	cout << endl;
    
    	thread{f}.join();		// å­çº¿ç¨‹ä¸­çš„thread_localéå±€éƒ¨å˜é‡åˆå§‹åŒ–æ—¶æœŸ
    	cout << endl;
    
    	f2();					// ä¸»çº¿ç¨‹ä¸­thread_localé™æ€å±€éƒ¨å˜é‡åˆå§‹åŒ–æ—¶æœŸ
    	f2();
    }
    ```
    
    è§£é‡Šï¼š
    
    - å…¶ä¸­`f()`ç”¨äºè§‚æµ‹thread_localå…¨å±€é™æ€å˜é‡çš„åˆå§‹åŒ–æ—¶æœŸï¼Œ`f2()`ç”¨äºè§‚æµ‹thread_localå±€éƒ¨é™æ€å˜é‡çš„åˆå§‹åŒ–æ—¶æœŸã€‚
    
    è¾“å‡ºï¼š
    
    ```c++
    init n
    main
        
    init n
    thread f
        
    f2
    init f2 n
    f2
    ```
    
    è§£é‡Šï¼š
    
    - å¯¹äºthread_localå…¨å±€é™æ€å˜é‡è€Œè¨€ï¼šå˜é‡çš„åˆå§‹åŒ–ä¼š**ä½œä¸ºçº¿ç¨‹å¯åŠ¨çš„ä¸€éƒ¨åˆ†**ï¼Œåˆå§‹åŒ–æ—¶æœŸæ—©äºçº¿ç¨‹å‡½æ•°è¿è¡Œæ—¶æœŸï¼ˆä»¥ä¸Šæ˜¯msvcçš„å®ç°ï¼Œå¯¹äºg++è€Œè¨€ï¼Œåªæœ‰åœ¨é¦–æ¬¡ä½¿ç”¨çº¿ç¨‹å…¨å±€é™æ€å˜é‡çš„åœ°æ–¹æŒ‰é¡ºåºåˆå§‹åŒ–æ‰€æœ‰çš„çº¿ç¨‹å…¨å±€é™æ€å˜é‡ï¼‰
    - å¯¹äºthread_localå±€éƒ¨é™æ€å˜é‡è€Œè¨€ï¼šæ§åˆ¶æµé¦–æ¬¡**ç»è¿‡å®ƒçš„å£°æ˜**æ—¶æ‰ä¼šè¢«åˆå§‹åŒ–

- CPU å˜é‡

  - å®ƒåœ¨æ ‡å‡† C++ ä¸­æ— å¯¹åº”æŠ½è±¡å®ç°ï¼Œæ˜¯æ“ä½œç³»ç»Ÿå†…æ ¸åŠŸèƒ½ã€‚å®ƒä¸»è¦ä¾èµ–äºå½“å‰ç³»ç»Ÿå†…æ ¸æ¥è¿›è¡Œä½¿ç”¨ï¼Œä¹Ÿæ— æ³•è·¨å¹³å°ã€‚åŸºæœ¬æ¦‚å¿µä¸çº¿ç¨‹å˜é‡ç±»ä¼¼ï¼šCPU å˜é‡æ˜¯ä¸ºæ¯ä¸ªå¤„ç†å™¨å•ç‹¬åˆ†é…çš„å˜é‡å‰¯æœ¬ã€‚

- æ€»ç»“

  - å±€éƒ¨å˜é‡é€‚åˆä¸´æ—¶æ•°æ®ï¼Œä½œç”¨åŸŸç»“æŸè‡ªåŠ¨é‡Šæ”¾ï¼Œå‡ ä¹[[çœ‹è¿™é‡Œ]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote5)æ— éœ€åŒæ­¥ã€‚

  - å…¨å±€å˜é‡é€‚åˆæ•´ä¸ªç¨‹åºçš„å…±äº«çŠ¶æ€ï¼Œä½†éœ€è¦ä½¿ç”¨åŒæ­¥è®¾æ–½è¿›è¡Œä¿æŠ¤ã€‚

  - çº¿ç¨‹å˜é‡é€‚åˆçº¿ç¨‹çš„ç‹¬ç«‹çŠ¶æ€ï¼Œé€šå¸¸[[çœ‹è¿™é‡Œ]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/03å…±äº«æ•°æ®.html#footnote6)æ— éœ€åŒæ­¥ã€‚

    ```c++
    // åœ¨è¿™ç§æƒ…å†µä¸‹éœ€è¦åŒæ­¥ï¼Œä¸è¿‡åŸºæœ¬æ²¡äººè¿™ä¹ˆåšï¼Œæ‰€ä»¥è¯´é€šå¸¸
    thread_local static int aaa = 0;
    int* paaa = &aaa;
    void f() {
        *paaa = 11;
        cout << this_thread::get_id() << " " << *paaa << endl;
    }
    int main() {
        thread{f}.join();
        cout << this_thread::get_id() << " " << *paaa << endl;
    }
    // 2 11
    // 1 11
    ```

  - CPU å˜é‡çš„ä½¿ç”¨æ˜¯å°‘è§çš„ï¼Œä¸»è¦ç”¨äºå†…æ ¸å¼€å‘å’Œè¿½æ±‚æè‡´æ€§èƒ½çš„é«˜å¹¶å‘åœºæ™¯ï¼Œå‡å°‘ CPU åŒæ­¥å¼€é”€ã€‚

  æ€»è€Œè¨€ä¹‹ï¼Œç»“åˆå®é™…ä½¿ç”¨å³å¯ï¼ŒæŠŠè¿™å››ç§å˜é‡æ‹¿å‡ºæ¥è¿›è¡Œå¯¹æ¯”ï¼Œå¢è¿›ç†è§£ï¼ŒåŠ æ·±å°è±¡

## æ€»ç»“

æœ¬ç« è®¨è®ºäº†å¤šçº¿ç¨‹çš„å…±äº«æ•°æ®å¼•å‘çš„æ¶æ€§æ¡ä»¶ç«äº‰ä¼šå¸¦æ¥çš„é—®é¢˜ã€‚å¹¶è¯´æ˜äº†å¯ä»¥ä½¿ç”¨äº’æ–¥é‡ï¼ˆ`std::mutex`ï¼‰ä¿æŠ¤å…±äº«æ•°æ®ï¼Œå¹¶ä¸”è¦æ³¨æ„äº’æ–¥é‡ä¸Šé”çš„â€œ**ç²’åº¦**â€ã€‚C++æ ‡å‡†åº“æä¾›äº†å¾ˆå¤šå·¥å…·ï¼ŒåŒ…æ‹¬ç®¡ç†äº’æ–¥é‡çš„ç®¡ç†ç±»ï¼ˆ`std::lock_guard`ï¼‰ï¼Œä½†æ˜¯äº’æ–¥é‡åªèƒ½è§£å†³å®ƒèƒ½è§£å†³çš„é—®é¢˜ï¼Œå¹¶ä¸”å®ƒæœ‰è‡ªå·±çš„é—®é¢˜ï¼ˆ**æ­»é”**ï¼‰ã€‚åŒæ—¶æˆ‘ä»¬è®²è¿°äº†ä¸€äº›é¿å…æ­»é”çš„æ–¹æ³•å’ŒæŠ€æœ¯ã€‚è¿˜è®²äº†ä¸€ä¸‹äº’æ–¥é‡æ‰€æœ‰æƒè½¬ç§»ã€‚ç„¶åè®¨è®ºäº†é¢å¯¹ä¸åŒæƒ…å†µä¿æŠ¤å…±äº«æ•°æ®çš„ä¸åŒæ–¹å¼ï¼Œä½¿ç”¨ `std::call_once()` ä¿æŠ¤å…±äº«æ•°æ®çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œä½¿ç”¨è¯»å†™é”ï¼ˆ`std::shared_mutex`ï¼‰ä¿æŠ¤ä¸å¸¸æ›´æ–°çš„æ•°æ®ç»“æ„ã€‚ä»¥åŠç‰¹æ®Šæƒ…å†µå¯èƒ½ç”¨åˆ°çš„äº’æ–¥é‡ `recursive_mutex`ï¼Œæœ‰äº›äººå¯èƒ½å–œæ¬¢ç§°ä½œï¼š**é€’å½’é”**ã€‚ç„¶åèŠäº†ä¸€ä¸‹ `new`ã€`delete` è¿ç®—ç¬¦çš„åº“å‡½æ•°å®é™…æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚æœ€åä»‹ç»äº†ä¸€ä¸‹çº¿ç¨‹å­˜å‚¨æœŸã€CPU å˜é‡ï¼Œå’Œå„ç§å˜é‡è¿›è¡Œäº†ä¸€ä¸ªå¯¹æ¯”ã€‚

ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†å¼€å§‹è®²è¿°åŒæ­¥æ“ä½œï¼Œä¼šä½¿ç”¨åˆ° [**Futures**](https://zh.cppreference.com/w/cpp/thread#.E6.9C.AA.E6.9D.A5.E4.BD.93)ã€[**æ¡ä»¶å˜é‡**](https://zh.cppreference.com/w/cpp/thread#.E6.9D.A1.E4.BB.B6.E5.8F.98.E9.87.8F)ç­‰è®¾æ–½ã€‚

# åŒæ­¥æ“ä½œ

> - äº’æ–¥é‡ç”¨æ¥é˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å†™åŒä¸€ä¸ªå…±äº«èµ„æº
> - ä¿¡å·é‡ç”¨æ¥æ§åˆ¶ä¸¤ä¸ªæˆ–å¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåºã€‚

"åŒæ­¥æ“ä½œ"æ˜¯æŒ‡åœ¨è®¡ç®—æœºç§‘å­¦å’Œä¿¡æ¯æŠ€æœ¯ä¸­çš„ä¸€ç§æ“ä½œæ–¹å¼ï¼Œå…¶ä¸­ä¸åŒçš„ä»»åŠ¡æˆ–æ“ä½œæŒ‰é¡ºåºæ‰§è¡Œï¼Œä¸€ä¸ªæ“ä½œå®Œæˆåæ‰èƒ½å¼€å§‹ä¸‹ä¸€ä¸ªæ“ä½œã€‚åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œå„ä¸ªä»»åŠ¡é€šå¸¸éœ€è¦é€šè¿‡**åŒæ­¥è®¾æ–½**ï¼ˆå³äº’æ–¥é‡ï¼Œä»¥åŠæ¡ä»¶å˜é‡ï¼‰è¿›è¡Œç›¸äº’**åè°ƒå’Œç­‰å¾…**ï¼Œç¡®ä¿æˆ‘ä»¬çš„æ“ä½œæ˜¯åŒæ­¥æ“ä½œï¼Œä»è€Œç¡®ä¿æ•°æ®çš„**ä¸€è‡´æ€§**å’Œ**æ­£ç¡®æ€§**ã€‚

æœ¬ç« çš„ä¸»è¦å†…å®¹æœ‰ï¼š

- æ¡ä»¶å˜é‡
- `std::future` ç­‰å¾…å¼‚æ­¥ä»»åŠ¡
- åœ¨è§„å®šæ—¶é—´å†…ç­‰å¾…
- Qt å®ç°å¼‚æ­¥ä»»åŠ¡çš„ç¤ºä¾‹
- å…¶å®ƒ C++20 åŒæ­¥è®¾æ–½ï¼šä¿¡å·é‡ã€é—©ä¸å±éšœ

æœ¬ç« å°†è®¨è®ºå¦‚ä½•ä½¿ç”¨æ¡ä»¶å˜é‡ç­‰å¾…äº‹ä»¶ï¼Œä»‹ç» future ç­‰æ ‡å‡†åº“è®¾æ–½ç”¨ä½œåŒæ­¥æ“ä½œï¼Œä½¿ç”¨Qt+CMake æ„å»ºä¸€ä¸ªé¡¹ç›®å±•ç¤ºå¤šçº¿ç¨‹çš„å¿…è¦æ€§ï¼Œä»‹ç» C++20 å¼•å…¥çš„æ–°çš„åŒæ­¥è®¾æ–½ã€‚

## ç­‰å¾…äº‹ä»¶æˆ–æ¡ä»¶

- æƒ…å¢ƒå¼•å…¥

  å‡è®¾ä½ æ­£åœ¨ä¸€è¾†å¤œé—´è¿è¡Œçš„åœ°é“ä¸Šï¼Œé‚£ä¹ˆä½ è¦å¦‚ä½•åœ¨æ­£ç¡®çš„ç«™ç‚¹ä¸‹è½¦å‘¢ï¼Ÿ

  1. ä¸€ç›´ä¸ä¼‘æ¯ï¼Œæ¯ä¸€ç«™éƒ½èƒ½çŸ¥é“ï¼Œè¿™æ ·å°±ä¸ä¼šé”™è¿‡ä½ è¦ä¸‹è½¦çš„ç«™ç‚¹ï¼Œä½†æ˜¯è¿™ä¼šå¾ˆç–²æƒ«ã€‚

     è¿™ä¸ªå«â€[å¿™ç­‰å¾…](https://zh.wikipedia.org/wiki/å¿™ç¢Œç­‰å¾…)ï¼ˆbusy waitingï¼‰â€ä¹Ÿç§°â€œ**è‡ªæ—‹**â€œã€‚

     ```c++
     bool flag = false;
     std::mutex m;
     
     void wait_for_flag(){
         std::unique_lock<std::mutex> lk{ m };
         // å¿™ç­‰å¾…ç›´åˆ° flag å˜ä¸º true
         while (!flag){
             lk.unlock();
             // å¿™ç­‰å¾…å¾ªç¯ä½“é€šå¸¸ä¸ºç©ºæˆ–è€…æ‰§è¡Œéé˜»å¡æ“ä½œ
             lk.lock();
         }
     }
     ```

     æ³¨æ„ï¼š

     - ä¸€ç›´å¿™ç­‰å¾…ä¼šé€ æˆçº¿ç¨‹æ—¶åˆ»å¤„äºåˆ¤æ–­`flag`ï¼Œæ‰§è¡Œå¾ªç¯ä½“ä¸­ä»£ç çš„çŠ¶æ€ï¼Œè¿™ä¼šå¯¼è‡´å ç”¨è¿‡å¤šçš„cpuèµ„æºï¼Œå¯¼è‡´èµ„æºçš„æµªè´¹ï¼Œæ‰€ä»¥åº”è¯¥å°½é‡é¿å…ä¸€ç›´å¤„äºå¿™ç­‰å¾…ã€‚
     - ä¹‹æ‰€ä»¥åœ¨`while`å¾ªç¯ä¸­è¦è§£é”ï¼Œæ˜¯å› ä¸º`flag`æ˜¯ä¸ªå…±äº«å˜é‡ï¼Œæ‰€ä»¥`m`å…¶å®å’Œ`flag`æ˜¯â€œç»‘å®šâ€çš„ï¼Œæ‰€ä»¥è§£é”æ“ä½œå…¶å®æ˜¯åœ¨æœŸå¾…æœ‰å…¶ä»–çš„çº¿ç¨‹å¯ä»¥å°†`flag`ç½®ä¸º`true`ã€‚
     - è‡³äºåé¢åˆé‡æ–°ä¸Šé”ï¼ŒåŸå› ä¹Ÿå¾ˆç®€å•ï¼Œä¸ºäº†é˜²æ­¢å…¶ä»–çº¿ç¨‹éšæ„çº‚æ”¹`flag`çš„å€¼æˆ–è€…å…¶ä»–å’Œ`flag`åœ¨ä¸€èµ·çš„å…±äº«å˜é‡

  2. å¯ä»¥çœ‹ä¸€ä¸‹æ—¶é—´ï¼Œä¼°ç®—ä¸€ä¸‹åœ°é“åˆ°è¾¾ç›®çš„åœ°çš„æ—¶é—´ï¼Œç„¶åè®¾ç½®ä¸€ä¸ªç¨æ—©çš„é—¹é’Ÿï¼Œå°±ä¼‘æ¯ã€‚è¿™ä¸ªæ–¹æ³•å¬èµ·æ¥è¿˜è¡Œï¼Œä½†æ˜¯ä½ å¯èƒ½è¢«è¿‡æ—©çš„å«é†’ï¼Œç”šè‡³ä¼°ç®—é”™è¯¯å¯¼è‡´åè¿‡ç«™ï¼Œåˆæˆ–è€…é—¹é’Ÿæ²¡ç”µäº†ç¡è¿‡ç«™ã€‚

     ```c++
     void wait_for_flag(){
         std::unique_lock<std::mutex> lk{ m };
         while (!flag){
             lk.unlock();    // 1 è§£é”äº’æ–¥é‡
             std::this_thread::sleep_for(50ms); // 2 ä¼‘çœ 
             lk.lock();      // 3 ä¸Šé”äº’æ–¥é‡
         }
     }
     ```

     - è§£é‡Šï¼š
       - è¿™ç§æ–¹æ³•ä¼šä½¿å¾—çº¿ç¨‹æ— æ„ä¹‰çš„å¾ªç¯æ¬¡æ•°å¤§å¹…å‡å°‘ï¼Œå‡å°‘æ¶ˆè€—çš„cpuèµ„æºï¼Œæ¯”ç¬¬ä¸€ç§ç¨å¾®å¥½ä¸€ç‚¹
       - æ³¨æ„ï¼Œè°ƒç”¨ `sleep_for()` æ—¶ï¼Œå½“å‰çº¿ç¨‹å°†è¿›å…¥ä¼‘çœ æ€ï¼Œç›´åˆ°50msæ—¶é—´è¿‡å»ã€‚è¿™ä¸ªæ“ä½œä¼šå¯¼è‡´çº¿ç¨‹é‡Šæ”¾cpuèµ„æºï¼Œç»™å…¶ä»–çº¿ç¨‹è¿è¡Œçš„æœºä¼šï¼Œæ‰€ä»¥ä¼šå‡å°‘æ¶ˆè€—çš„cpuèµ„æºã€‚

  3. äº‹å®ä¸Šæœ€ç®€å•çš„æ–¹å¼æ˜¯ï¼Œåˆ°ç«™çš„æ—¶å€™æœ‰äººæˆ–è€…å…¶å®ƒä¸œè¥¿èƒ½å°†ä½ å«é†’ï¼ˆæ¯”å¦‚æ‰‹æœºçš„åœ°å›¾ï¼Œåˆ°è¾¾è®¾ç½®çš„ä½ç½®å°±æé†’ï¼‰ã€‚

     è¿™ä¸ªå°±æ˜¯ä¿¡å·é‡ï¼Œè¯·çœ‹ä¸‹é¢ã€‚

- å®šä¹‰

  æ¡ä»¶å˜é‡ï¼ˆCondition Variableï¼‰æ˜¯ä¸€ç§ç”¨äºçº¿ç¨‹åŒæ­¥çš„æœºåˆ¶ï¼Œé€šå¸¸ä¸äº’æ–¥é”ï¼ˆ`Mutex`ï¼‰ä¸€èµ·ä½¿ç”¨ã€‚æ¡ä»¶å˜é‡æä¾›äº†ä¸€ç§çº¿ç¨‹é—´çš„é€šä¿¡æœºåˆ¶ï¼Œå…è®¸ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…å¦ä¸€ä¸ªçº¿ç¨‹æ»¡è¶³æŸä¸ªæ¡ä»¶åå†ç»§ç»­æ‰§è¡Œã€‚

  **æ³¨æ„**ï¼šåœ¨ä½¿ç”¨æ¡ä»¶å˜é‡æ—¶ï¼Œ**å¿…é¡»ç¡®ä¿ä¸äº’æ–¥é”ä¸€èµ·ä½¿ç”¨ï¼Œä»¥é¿å…ç«æ€æ¡ä»¶çš„å‘ç”Ÿ**ã€‚

  C++ æ ‡å‡†åº“å¯¹æ¡ä»¶å˜é‡æœ‰ä¸¤å¥—å®ç°ï¼š[`std::condition_variable`](https://zh.cppreference.com/w/cpp/thread/condition_variable) å’Œ [`std::condition_variable_any`](https://zh.cppreference.com/w/cpp/thread/condition_variable_any)ï¼Œè¿™ä¸¤ä¸ªå®ç°éƒ½åŒ…å«åœ¨ [`<condition_variable>`](https://zh.cppreference.com/w/cpp/header/condition_variable) å¤´æ–‡ä»¶ä¸­ã€‚

  `condition_variable_any` ç±»æ˜¯ `std::condition_variable` çš„æ³›åŒ–ã€‚ç›¸å¯¹äºåªåœ¨ `std::unique_lock<std::mutex>` ä¸Šå·¥ä½œçš„ `std::condition_variable`ï¼Œ`condition_variable_any` èƒ½åœ¨ä»»ä½•æ»¡è¶³[`å¯åŸºæœ¬é”å®š(BasicLockable)`](https://zh.cppreference.com/w/cpp/named_req/BasicLockable)è¦æ±‚çš„é”ä¸Šå·¥ä½œï¼Œæ‰€ä»¥å¢åŠ äº† `_any` åç¼€ã€‚æ˜¾è€Œæ˜“è§ï¼Œè¿™ç§åŒºåˆ†å¿…ç„¶æ˜¯ `any` ç‰ˆ**æ›´åŠ é€šç”¨ä½†æ˜¯å´æœ‰æ›´å¤šçš„æ€§èƒ½å¼€é”€**ã€‚æ‰€ä»¥é€šå¸¸**é¦–é€‰** `std::condition_variable`ã€‚æœ‰ç‰¹æ®Šéœ€æ±‚ï¼Œæ‰ä¼šè€ƒè™‘ `std::condition_variable_any`ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  // ä»¥ä¸‹ä¸‰ä¸ªå˜é‡å¿…é¡»æ”¾åœ¨ä¸€èµ·ï¼Œè®©ä¸åŒçº¿ç¨‹éƒ½èƒ½è®¿é—®ã€‚
  std::mutex mtx; // äº’æ–¥é‡
  std::condition_variable cv; // æ¡ä»¶å˜é‡ï¼Œå¿…é¡»å’Œäº’æ–¥é‡æ”¾åœ¨ä¸€èµ·ä½¿ç”¨
  bool arrived = false;	// çŠ¶æ€ï¼Œè¡¨ç¤ºæ˜¯å¦åˆ°è¾¾ç›®çš„åœ°
  
  // æ­¤å‡½æ•°ç”¨äºæ¨¡æ‹Ÿâ€œåœ°é“ä¸Šç¡ç€çš„æˆ‘â€ï¼Œâ€œæˆ‘â€æœŸå¾…ç€åœ°é“åˆ°ç«™åèƒ½æœ‰äººæŠŠæˆ‘å–Šé†’
  void wait_for_arrival() {
      std::unique_lock<std::mutex> lck(mtx);          // ä¸Šé”ï¼Œä¸”å¿…é¡»ç”¨unique_lockåŒ…è£…mtx
      cv.wait(lck, [] { return arrived; });
      std::cout << "åˆ°è¾¾ç›®çš„åœ°ï¼Œå¯ä»¥ä¸‹è½¦äº†ï¼" << std::endl;
  }
  
  // æ­¤å‡½æ•°ç”¨äºæ¨¡æ‹Ÿâ€œæ‰‹æœºä¸Šçš„åœ°å›¾â€ï¼Œåœ°å›¾åœ¨åˆ°ç«™åä¼šå”¤é†’æˆ‘ï¼Œå¹¶é€šçŸ¥æˆ‘åœ°é“å·²ç»åˆ°ç«™ã€‚
  void simulate_arrival() {
      std::this_thread::sleep_for(5ms); // æ¨¡æ‹Ÿåœ°é“åˆ°ç«™ï¼Œå‡è®¾5ç§’ååˆ°è¾¾ç›®çš„åœ°
      {
          std::lock_guard<std::mutex> lck(mtx);
          arrived = true; // è®¾ç½®æ¡ä»¶å˜é‡ä¸º trueï¼Œè¡¨ç¤ºåˆ°è¾¾ç›®çš„åœ°
      }
      cv.notify_one(); // é€šçŸ¥ç­‰å¾…çš„çº¿ç¨‹
  }
  int main(){
      thread t1(wait_for_arrival);
      thread t2(simulate_arrival);
      t1.join();
      t2.join();
  }
  ```

  è§£é‡Šï¼š

  - æ˜¾ç„¶ï¼Œæˆ‘ä»¬æœ‰æ¡ä»¶å˜é‡`cv`ï¼ŒçŠ¶æ€ä½`flag`ä¸¤ä¸ªå…±äº«å˜é‡ï¼Œæ‰€ä»¥éœ€è¦ä¹Ÿå¿…é¡»è¦æ·»åŠ ä¸€ä¸ªäº’æ–¥é‡ã€‚

  - æ¡ä»¶å˜é‡ç”¨äºå†³å®šçº¿ç¨‹æ‰§è¡Œçš„å…ˆåé¡ºåºï¼Œå¯¹äºæœ¬ä¾‹è€Œè¨€ï¼Œå…ˆæ‰§è¡Œçš„çº¿ç¨‹æ˜¯t2ï¼Œåæ‰§è¡Œçš„çº¿ç¨‹æ˜¯t1ã€‚

  - åœ¨t2çš„`simulate_arrival()`ä¸­ï¼š

    - ä¸ºäº†é€šçŸ¥æˆ‘åœ°é“å·²ç»åˆ°ç«™ï¼Œéœ€è¦åšå¥½ä»¥ä¸‹ä¸¤ä»¶äº‹ï¼š
      1. å°†å…±äº«çš„æ ‡å¿—ä½`arrived`è®¾ä¸º`true`ï¼ˆéœ€è¦ç”¨`mtx`è¿›è¡Œä¿æŠ¤ï¼‰
      2. ä½¿ç”¨å…±äº«çš„æ¡ä»¶å˜é‡`cv`å”¤é†’æˆ‘

  - åœ¨t1çš„`wait_for_arrival()`ä¸­ï¼š

    - ä¸ºäº†èƒ½åœ¨åœ°é“åˆ°ç«™æ—¶æˆ‘èƒ½è¢«æ­£å¸¸å”¤é†’ï¼Œè¾“å‡ºåˆ°ç«™ä¿¡æ¯ï¼Œéœ€è¦åšå¥½ä»¥ä¸‹ä¸¤ä»¶äº‹ï¼š
      1. å°†å…±äº«çš„äº’æ–¥é”`mtx`ç”¨`unique_lock`å°è£…èµ·æ¥ï¼ˆå°è£…å`mtx`ä¸º`lock`çŠ¶æ€ï¼‰
      2. è°ƒç”¨`cv.wait()`ï¼Œè¿›å…¥é˜»å¡æ€ï¼Œç›´è‡³æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š**1.è¢«t2å”¤é†’ï¼ˆåŒ…æ‹¬è™šå‡å”¤é†’ï¼‰ 2.è°“è¯è¿”å›true**

  - `cv.wait(lck, [] { return arrived; });`

    - å‰ç½®çŸ¥è¯†ï¼š
      - è¿”å›boolç±»å‹çš„`ä»¿å‡½æ•°`ç§°ä¸º**è°“è¯**
      - å¦‚æœoperator()æ¥å—ä¸€ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆå«åš`ä¸€å…ƒè°“è¯`
      - å¦‚æœoperator()æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œé‚£ä¹ˆå«åš`äºŒå…ƒè°“è¯`
      - æ˜¾ç„¶ä¸€å…ƒ/äºŒå…ƒè°“è¯é€šè¿‡`bind()`å¯ä»¥è½¬æ¢ä¸ºè°“è¯

    - æºç å®ç°ï¼š

      ```c++
      void wait(unique_lock<mutex>& _Lck) noexcept {
          _Cnd_wait(_Mycnd(), _Lck.mutex()->_Mymtx());
      }
      
      template <class _Predicate>
      void wait(unique_lock<mutex>& _Lck, _Predicate _Pred) {
          while (!_Pred()) {
              wait(_Lck);
          }
      }
      ```

      æ˜¾ç„¶æˆ‘ä»¬è°ƒç”¨çš„æ˜¯ç¬¬äºŒä¸ª`wait()`ï¼Œä»–æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼š`unique_lock`çš„å¯¹è±¡å’Œè°“è¯

      ç¬¬äºŒä¸ªç‰ˆæœ¬åªæ˜¯å¯¹ç¬¬ä¸€ä¸ªç‰ˆæœ¬çš„**åŒ…è£…**ï¼Œç­‰å¾…å¹¶åˆ¤æ–­è°“è¯ï¼Œä¼šè°ƒç”¨ç¬¬ä¸€ä¸ªç‰ˆæœ¬çš„é‡è½½ã€‚è¿™å¯ä»¥é¿å…â€œ[è™šå‡å”¤é†’ï¼ˆspurious wakeupï¼‰](https://en.wikipedia.org/wiki/Spurious_wakeup)â€ã€‚

      > æ¡ä»¶å˜é‡è™šå‡å”¤é†’æ˜¯æŒ‡åœ¨ä½¿ç”¨æ¡ä»¶å˜é‡è¿›è¡Œçº¿ç¨‹åŒæ­¥æ—¶ï¼Œæœ‰æ—¶å€™çº¿ç¨‹å¯èƒ½ä¼šåœ¨æ²¡æœ‰æ”¶åˆ°é€šçŸ¥çš„æƒ…å†µä¸‹è¢«å”¤é†’ã€‚é—®é¢˜å–å†³äºç¨‹åºå’Œç³»ç»Ÿçš„å…·ä½“å®ç°ã€‚è§£å†³æ–¹æ³•å¾ˆç®€å•ï¼Œåœ¨å¾ªç¯ä¸­ç­‰å¾…å¹¶åˆ¤æ–­æ¡ä»¶å¯ä¸€å¹¶è§£å†³ã€‚ä½¿ç”¨ C++ æ ‡å‡†åº“åˆ™æ²¡æœ‰è¿™ä¸ªçƒ¦æ¼äº†ã€‚

    - **`wait()`å‡½æ•°åŠŸèƒ½è§£æï¼š**

      1. è°“è¯è¿”å›`true`æ—¶ï¼Œå•¥ä¹Ÿä¸åšï¼Œç›´æ¥è¿”å›

      2. è°“è¯è¿”å›`false`æ—¶ï¼Œè§£é”`lck`ï¼Œæ–¹ä¾¿å…¶ä»–çº¿ç¨‹ä¿®æ”¹å…±äº«çŠ¶æ€`arrived`ï¼Œå¹¶è¿›å…¥é˜»å¡æ€ï¼›æ­¤æ—¶å¯ä»¥é€šè¿‡è™šå‡å”¤é†’ï¼Œæˆ–è€…`cv.notify_one();`æ¥å”¤é†’è¯¥çº¿ç¨‹ï¼›å”¤é†’è¯¥çº¿ç¨‹ä¹‹åï¼Œä¼šå…ˆä¸Šé”ï¼Œç„¶åæ£€æŸ¥è°“è¯æ˜¯å¦è¿”å›`true`ï¼Œå¦‚æœè°“è¯ä¾ç„¶è¿”å›`false`ï¼Œåˆ™ä¼šå†æ¬¡è§£é”`lck`ï¼Œå¹¶è¿›å…¥é˜»å¡æ€ï¼Œå¦‚æ­¤å¾ªç¯ç›´è‡³è°“è¯ä¸º`true`ã€‚æ­¤æ—¶ä¼šé€€å‡ºwhileå¾ªç¯ï¼Œæ‰§è¡Œåç»­ä»£ç ã€‚

         ï¼ˆå½“ç„¶è¿™ä¸ªåªæ˜¯æˆ‘æ ¹æ®æºç å’Œå®é™…è¡Œä¸ºçŒœçš„æµç¨‹ï¼Œå› ä¸ºè°“è¯çš„æ£€æŸ¥è‚¯å®šéœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œæ‰€ä»¥åœ¨ç¬¬ä¸€æ¬¡ï¼Œä»¥åŠåç»­çš„åˆ¤æ–­ä¸­`lck`å¿…é¡»å¤„äºä¸Šé”çŠ¶æ€ã€‚è€Œå¦‚æœæƒ³è¦å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿä¿®æ”¹æ ‡å¿—ä½ï¼Œé‚£ä¹ˆåœ¨è¿›å…¥é˜»å¡ä¹‹å‰å¿…é¡»å°†`lck`è§£é”ï¼Œå› æ­¤æ¨æ–­ç¬¬ä¸€ä¸ª`wait()`ç‰ˆæœ¬ä¸€å®šæœ‰ä¸€ä¸ª è§£é”->é˜»å¡->å”¤é†’->ä¸Šé” çš„è¿‡ç¨‹ã€‚

      3. æ˜¾ç„¶ä¼ ç»™`wait`çš„è°“è¯ä¸­å¿…é¡»è¦æœ‰ä¸€ä¸ªå…¨å±€å˜é‡ï¼ˆæ ‡å¿—ä½ï¼‰ï¼Œå› ä¸ºå…¶ä»–çº¿ç¨‹åªèƒ½é€šè¿‡ä¿®æ”¹å…¨å±€å˜é‡æ¥ä¿®æ”¹è°“è¯è¿”å›çš„å€¼

## çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—

```c++
// å»ºè®®å¤åˆ¶åˆ°IDEä¸­æŸ¥çœ‹
template<typename T>
class threadsafe_queue {
    mutable std::mutex mtx;              // M&MåŸåˆ™ï¼Œäº’æ–¥é‡ï¼Œç”¨äºä¿æŠ¤é˜Ÿåˆ—æ“ä½œçš„ç‹¬å è®¿é—®
    std::condition_variable data_cond; // æ¡ä»¶å˜é‡ï¼Œç”¨äºåœ¨é˜Ÿåˆ—ä¸ºç©ºæ—¶ç­‰å¾…
    std::queue<T> data_queue;          // å®é™…å­˜å‚¨æ•°æ®çš„é˜Ÿåˆ—
public:
    threadsafe_queue() = default;
    // ä¸è®ºä»€ä¹ˆæƒ…å†µï¼Œpushï¼Œpopï¼Œemptyè¿™ä¸‰ä¸ªå‡½æ•°åœ¨åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªå‡½æ•°èƒ½æ‰§è¡Œ
    void push(T new_value) {
        std::unique_lock<std::mutex> lk{mtx};
        data_cond.wait(lk, [this]() {
            return data_queue.size() < QUEUE_MAXSIZE;   // æ³¨æ„è¿™é‡Œå¿…é¡»æ˜¯<ï¼Œä¸èƒ½æ˜¯<=
        });
        data_queue.push(new_value);
        data_cond.notify_one();
    }
    // ä»é˜Ÿåˆ—ä¸­å¼¹å‡ºå…ƒç´ ï¼ˆé˜»å¡ç›´åˆ°é˜Ÿåˆ—ä¸ä¸ºç©ºï¼‰
     T pop() {
        std::unique_lock<std::mutex> lk{ mtx };
        data_cond.wait(lk, [this] {
            return !data_queue.empty();
        });
        T value = data_queue.front();
        data_queue.pop();
        data_cond.notify_one();
        return value;
    }
    bool empty()const {
        std::lock_guard<std::mutex> lk (mtx);
        return data_queue.empty();
    }
};

```

è§£é‡Šï¼š

- é˜Ÿåˆ—æ»¡æ—¶ï¼Œåº”è¯¥å…ˆ`pop()`å`push()`ï¼›

  é˜Ÿåˆ—ç©ºæ—¶ï¼Œåº”è¯¥å…ˆ`push()`å`pop()`ã€‚

- æ‰§è¡Œ`push()`ï¼Œ`pop()`ï¼Œ`empty()`ä¸èƒ½åŒæ—¶æ‰§è¡Œã€‚

## ä½¿ç”¨æ¡ä»¶å˜é‡å®ç°åå°æç¤ºéŸ³æ’­æ”¾

[çœ‹è¿™é‡Œå°±å¥½ï¼šä½¿ç”¨æ¡ä»¶å˜é‡å®ç°åå°æç¤ºéŸ³æ’­æ”¾](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#ä½¿ç”¨æ¡ä»¶å˜é‡å®ç°åå°æç¤ºéŸ³æ’­æ”¾)

## ä½¿ç”¨futureï¼Ÿï¼Ÿï¼Ÿ

[ï¼ˆåŸåˆ›ï¼‰ç”¨C++11çš„std::asyncä»£æ›¿çº¿ç¨‹çš„åˆ›å»º - å—å“¥çš„å¤©ä¸‹ - åšå®¢å›­ï¼Ÿï¼Ÿï¼Ÿ](https://www.cnblogs.com/leijiangtao/p/12076251.html)

> - `std::async`ç”¨äºæ‰§è¡Œæœ‰è¿”å›å€¼çš„çº¿ç¨‹ä»»åŠ¡ï¼Œä¸threadç±»ä¼¼ã€‚

### ä½¿ç”¨asyncåˆ›å»ºå¼‚æ­¥ä»»åŠ¡è·å–è¿”å›å€¼

[å»ºè®®å…ˆçœ‹æ ‡å‡†æ–‡æ¡£ï¼šstd::async - cppreference.com](https://zh.cppreference.com/w/cpp/thread/async)

[å»ºè®®å…ˆçœ‹æ ‡å‡†æ–‡æ¡£std::async - C++ä¸­æ–‡ - APIå‚è€ƒæ–‡æ¡£](https://www.apiref.com/cpp-zh/cpp/thread/async.html)

> - `std::future`ï¼š
>
>   - æ˜¯ç±»æ¨¡æ¿ï¼Œè¯¥ç±»ä»…èƒ½ç§»åŠ¨ï¼Œä¸å¯å¤åˆ¶
>
>   - ç”¨äºè®¿é—®`std::async`æ‰§è¡Œåçš„ç»“æœï¼Œ`std::async`æ‰§è¡Œå¹¶ä¸ä»£è¡¨æŒ‡å®šçš„å‡½æ•°ä¼šæ‰§è¡Œï¼ŒæŒ‡å®šçš„å‡½æ•°æ˜¯å¦æ‰§è¡Œç”± æ‰§è¡Œç­–ç•¥ å’Œ æ“ä½œç³»ç»Ÿ å†³å®šã€‚
>   - **`std::future`ä¸­æœ‰ä¸€ä¸ªå…±äº«çŠ¶æ€ï¼Œè¯¥å…±äº«çŠ¶æ€å­˜å‚¨äº†[å¾…è°ƒç”¨çš„å‡½æ•° å’Œ å‚æ•°]ï¼ˆè¿›è¡Œæƒ°æ€§æ±‚å€¼æ—¶ï¼‰ä»¥åŠ å‡½æ•°è¿”å›çš„ç»“æœæˆ–è€…æŠ›å‡ºçš„å¼‚å¸¸**
>
> - æ‰§è¡Œç­–ç•¥ï¼š
>
>   - `std::launch::deferred`
>
>     æ­¤æ ‡å¿—è¡¨ç¤ºï¼šæƒ°æ€§æ±‚å€¼ï¼ŒåŒæ­¥ï¼Œåœ¨ `async` æ‰€è¿”å›çš„ `std::future` ä¸Šé¦–æ¬¡è°ƒç”¨éå®šæ—¶ç­‰å¾…å‡½æ•°çš„çº¿ç¨‹ä¸­æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°
>
>     ä¸Šé¢è¿™è¡Œçš„æ„æ€å°±æ˜¯è¯´ï¼š**å“ªä¸ªçº¿ç¨‹è°ƒç”¨äº†futureå¯¹è±¡çš„`wait()`/`get()`ï¼Œé‚£ä¹ˆå…±äº«çŠ¶æ€ä¸­å­˜å‚¨çš„å‡½æ•°å°±ä¼šåœ¨å¯¹åº”çš„çº¿ç¨‹ä¸­ï¼Œåœ¨è°ƒç”¨äº†`wait()`/`get()`çš„åœ°æ–¹åŸåœ°æ‰§è¡Œï¼Œä¸ä¸€å®šåœ¨æœ€åˆè°ƒç”¨ `std::async` çš„çº¿ç¨‹ä¸­æ‰§è¡Œ**ã€‚
>
>   - `std::launch::async`
>
>     - libstdc++
>
>       å’Œ`std::thread`ä¸€æ ·ï¼Œç«‹åˆ»åˆ›å»ºçº¿ç¨‹ï¼Œå¼‚æ­¥è°ƒç”¨
>
>     - MSVC STL
>
>       å¾®è½¯pplå¹¶è¡Œåº“æœ‰ä¸ªçº¿ç¨‹æ± ï¼Œå…ˆæ£€æŸ¥è¯¥çº¿ç¨‹æ± é‡Œæœ‰æ²¡æœ‰å¯ç”¨çš„çº¿ç¨‹ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ç”¨çº¿ç¨‹æ± é‡Œçš„çº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™é€šè¿‡pplï¼ˆasyncå¹¶æ²¡æœ‰åˆ›å»ºçº¿ç¨‹ï¼‰æ¥åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹æ‰§è¡Œ
>
>   - `std::launch::async | std::launch::deferred`
>
>     - libstdc++
>
>       æ­¤ç­–ç•¥è¡¨ç¤ºç”±å®ç°é€‰æ‹©åˆ°åº•æ˜¯å¦åˆ›å»ºçº¿ç¨‹æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ã€‚å…¸å‹æƒ…å†µæ˜¯ï¼Œå¦‚æœç³»ç»Ÿèµ„æºå……è¶³ï¼Œå¹¶ä¸”å¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œä¸ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ï¼Œé‚£ä¹ˆç³»ç»Ÿå¯èƒ½ä¼šé€‰æ‹©åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡ã€‚ä½†æ˜¯ï¼Œå¦‚æœç³»ç»Ÿèµ„æºæœ‰é™ï¼Œæˆ–è€…å»¶è¿Ÿæ‰§è¡Œå¯ä»¥æé«˜æ€§èƒ½æˆ–èŠ‚çœèµ„æºï¼Œé‚£ä¹ˆç³»ç»Ÿå¯èƒ½ä¼šé€‰æ‹©å»¶è¿Ÿæ‰§è¡Œã€‚
>
>     - MSVC STL
>
>       æ­¤ç­–ç•¥ä¸ `launch::async` æ‰§è¡Œç­–ç•¥æ¯«æ— åŒºåˆ«ï¼Œ
>
> - `std::async`ä¸`std::thread`çš„å¼‚åŒï¼š
>
>   - å¼‚ï¼š
>
>     1. `std::async`æ˜¯å‡½æ•°æ¨¡æ¿ï¼Œ`std::thread`æ˜¯ç±»æ¨¡æ¿ã€‚
>
>     2. asyncæ—¢å¯ä»¥æ‰§è¡Œ`è¿”å›å€¼ä¸ºvoid`çš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ‰§è¡Œ`è¿”å›å€¼ä¸ºévoid`çš„å‡½æ•°ï¼ˆå¯ç”¨é€šè¿‡futureç±»å¯¹è±¡ç§»åŠ¨æ¥æ”¶asyncçš„è¿”å›å€¼ï¼Œä¸”futureç±»å¯¹è±¡ä¸­æœ‰ä¸€ä¸ªå…±äº«çŠ¶æ€ï¼Œç”¨äºå­˜å‚¨ å¾…è°ƒç”¨çš„å‡½æ•°ï¼ˆè¿›è¡Œæƒ°æ€§æ±‚å€¼æ—¶ï¼‰ï¼Œå‡½æ•°è¿”å›çš„ç»“æœæˆ–è€…æŠ›å‡ºçš„å¼‚å¸¸ ï¼‰
>
>        threadæ—¢å¯ä»¥æ‰§è¡Œ`è¿”å›å€¼ä¸ºvoid`çš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥æ‰§è¡Œ`è¿”å›å€¼ä¸ºévoid`çš„å‡½æ•°ï¼ˆä½†æ˜¯æ— æ³•æ¥æ”¶è¯¥å‡½æ•°çš„è¿”å›å€¼ï¼‰
>
>     3. asyncæ—¢å¯ä»¥é€‰æ‹©[*å¼‚æ­¥ï¼Œåœ¨ä¸åŒçº¿ç¨‹ä¸­*]æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©[*æƒ°æ€§æ±‚å€¼ï¼ŒåŒæ­¥ï¼Œåœ¨ `async` æ‰€è¿”å›çš„ `std::future` ä¸Šé¦–æ¬¡è°ƒç”¨éå®šæ—¶ç­‰å¾…å‡½æ•°çš„çº¿ç¨‹ï¼ˆä¸å¿…æ˜¯æœ€åˆè°ƒç”¨ `std::async` çš„çº¿ç¨‹ï¼‰ä¸­*]æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°ï¼›
>
>        threadåªèƒ½é€‰æ‹©[*å¼‚æ­¥ï¼Œåœ¨ä¸åŒçº¿ç¨‹ä¸­*]æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°ã€‚
>
>   - åŒï¼š
>
>     1. åœ¨ä¼ é€’å‡½æ•°/å‡½æ•°å‚æ•°æ—¶ï¼Œä¸¤è€…ä¼ é€’çš„éƒ½æ˜¯å‚æ•°é€€åŒ–åçš„å³å€¼å‰¯æœ¬ï¼Œæ‰€ä»¥å¦‚æœæƒ³ä¼ å¼•ç”¨çš„è¯ï¼Œå¿…é¡»ä½¿ç”¨`ref()`ã€‚

- å‰è¨€ï¼š

  å‡è®¾éœ€è¦æ‰§è¡Œä¸€ä¸ªè€—æ—¶ä»»åŠ¡å¹¶è·å–å…¶è¿”å›å€¼ï¼Œä½†æ˜¯å¹¶ä¸æ€¥åˆ‡çš„éœ€è¦å®ƒã€‚é‚£ä¹ˆå°±å¯ä»¥å¯åŠ¨æ–°çº¿ç¨‹è®¡ç®—ï¼Œç„¶è€Œ `std::thread` æ²¡æä¾›ç›´æ¥ä»çº¿ç¨‹è·å–è¿”å›å€¼çš„æœºåˆ¶ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ [`std::async`](https://zh.cppreference.com/w/cpp/thread/async) å‡½æ•°æ¨¡æ¿ã€‚

- `std::async`åŸºæœ¬ä½¿ç”¨ï¼š

  ä½¿ç”¨ `std::async` å¯åŠ¨ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª `std::future` å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡å’Œä»»åŠ¡å…³è”ï¼Œå°†æŒæœ‰æœ€ç»ˆè®¡ç®—å‡ºæ¥çš„ç»“æœã€‚å½“éœ€è¦ä»»åŠ¡æ‰§è¡Œå®Œçš„ç»“æœçš„æ—¶å€™ï¼Œåªéœ€è¦è°ƒç”¨ [`get()`](https://zh.cppreference.com/w/cpp/thread/future/get) æˆå‘˜å‡½æ•°ï¼Œå°±ä¼šé˜»å¡ç›´åˆ° `future` ä¸ºå°±ç»ªä¸ºæ­¢ï¼ˆå³ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼‰ï¼Œè¿”å›æ‰§è¡Œç»“æœã€‚**[`valid()`](https://zh.cppreference.com/w/cpp/thread/future/valid) æˆå‘˜å‡½æ•°æ£€æŸ¥ future å½“å‰æ˜¯å¦å…³è”å…±äº«çŠ¶æ€ï¼Œå³æ˜¯å¦å½“å‰å…³è”ä»»åŠ¡ã€‚è¿˜æœªå…³è”ï¼Œæˆ–è€…ä»»åŠ¡å·²ç»æ‰§è¡Œå®Œï¼ˆè°ƒç”¨äº† get()ã€set()ï¼‰ï¼Œéƒ½ä¼šè¿”å› `false`ã€‚**

  ```c++
  #include <iostream>
  #include <thread>
  #include <future> // å¼•å…¥ future å¤´æ–‡ä»¶
  
  int task(int n) {
      std::cout << "å¼‚æ­¥ä»»åŠ¡ ID: " << std::this_thread::get_id() << '\n';
      return n * n;
  }
  
  int main() {
      std::future<int> future = std::async(task, 10);
      std::cout << "main: " << std::this_thread::get_id() << '\n';
      std::cout << std::boolalpha << future.valid() << '\n'; // trueã€‚æ˜¾ç„¶ï¼Œå¦‚æœæŒ‡å®šasyncæ‰§è¡Œç­–ç•¥ä¸º`std::launch::deferred`ï¼Œä¹Ÿä¾ç„¶ä¼šæ˜¯true
      std::cout << future.get() << '\n';
      std::cout << std::boolalpha << future.valid() << '\n'; // false
  }
  ```
  
- `std::async`å‚æ•°ä¼ é€’ï¼š

  ä¸ `std::thread` ä¸€æ ·ï¼Œ`std::async` æ”¯æŒä»»æ„[å¯è°ƒç”¨(Callable)](https://zh.cppreference.com/w/cpp/named_req/Callable)å¯¹è±¡ï¼Œä»¥åŠä¼ é€’è°ƒç”¨å‚æ•°ã€‚åŒ…æ‹¬æ”¯æŒä½¿ç”¨ `std::ref` ï¼Œä»¥åŠ**æ”¯æŒåªèƒ½ç§»åŠ¨çš„ç±»å‹**ã€‚è¯¦æƒ…è§[threadæºç è§£æ](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/è¯¦ç»†åˆ†æ/01threadçš„æ„é€ ä¸æºç è§£æ.html)ï¼Œåœ¨å‚æ•°ä¼ é€’ä¸Šä¸¤è€…å…¶å®éƒ½å·®ä¸å¤š

  ```c++
  struct X{
      int operator()(int n)const{
          return n * n;
      }
  };
  struct Y{
      int f(int n)const{
          return n * n;
      }
  };
  void f(int& p) { std::cout << &p << '\n'; }
  
  int main(){
      Y y;
      int n = 0;
      auto t1 = std::async(X{}, 10);
      auto t2 = std::async(&Y::f,&y,10);
      auto t3 = std::async([] {});         
      auto t4 = std::async(f, std::ref(n));
      std::cout << &n << '\n';
  }
  ```

- `std::async`æ‰§è¡Œç­–ç•¥ï¼š

  - `std::launch::deferred`

    æ­¤æ ‡å¿—è¡¨ç¤ºï¼šæƒ°æ€§æ±‚å€¼ï¼ŒåŒæ­¥ï¼Œåœ¨ `async` æ‰€è¿”å›çš„ `std::future` ä¸Šé¦–æ¬¡è°ƒç”¨éå®šæ—¶ç­‰å¾…å‡½æ•°çš„çº¿ç¨‹ä¸­æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°

    ä¸Šé¢è¿™è¡Œçš„æ„æ€å°±æ˜¯è¯´ï¼š**å“ªä¸ªçº¿ç¨‹è°ƒç”¨äº†futureå¯¹è±¡çš„`wait()`/`get()`ï¼Œé‚£ä¹ˆå…±äº«çŠ¶æ€ä¸­å­˜å‚¨çš„å‡½æ•°å°±ä¼šåœ¨å¯¹åº”çš„çº¿ç¨‹ä¸­ï¼Œåœ¨è°ƒç”¨äº†`wait()`/`get()`çš„åœ°æ–¹åŸåœ°æ‰§è¡Œï¼Œä¸ä¸€å®šåœ¨æœ€åˆè°ƒç”¨ `std::async` çš„çº¿ç¨‹ä¸­æ‰§è¡Œ**ã€‚

  - `std::launch::async`

    - libstdc++

      å’Œ`std::thread`ä¸€æ ·ï¼Œç«‹åˆ»åˆ›å»ºçº¿ç¨‹ï¼Œå¼‚æ­¥è°ƒç”¨

    - MSVC STL

      å¾®è½¯pplå¹¶è¡Œåº“æœ‰ä¸ªçº¿ç¨‹æ± ï¼Œå…ˆæ£€æŸ¥è¯¥çº¿ç¨‹æ± é‡Œæœ‰æ²¡æœ‰å¯ç”¨çš„çº¿ç¨‹ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ç”¨çº¿ç¨‹æ± é‡Œçš„çº¿ç¨‹ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™é€šè¿‡pplï¼ˆasyncå¹¶æ²¡æœ‰åˆ›å»ºçº¿ç¨‹ï¼‰æ¥åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹æ‰§è¡Œ

  - `std::launch::async | std::launch::deferred`

    - libstdc++

      æ­¤ç­–ç•¥è¡¨ç¤ºç”±å®ç°é€‰æ‹©åˆ°åº•æ˜¯å¦åˆ›å»ºçº¿ç¨‹æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡ã€‚å…¸å‹æƒ…å†µæ˜¯ï¼Œå¦‚æœç³»ç»Ÿèµ„æºå……è¶³ï¼Œå¹¶ä¸”å¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œä¸ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ï¼Œé‚£ä¹ˆç³»ç»Ÿå¯èƒ½ä¼šé€‰æ‹©åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡ã€‚ä½†æ˜¯ï¼Œå¦‚æœç³»ç»Ÿèµ„æºæœ‰é™ï¼Œæˆ–è€…å»¶è¿Ÿæ‰§è¡Œå¯ä»¥æé«˜æ€§èƒ½æˆ–èŠ‚çœèµ„æºï¼Œé‚£ä¹ˆç³»ç»Ÿå¯èƒ½ä¼šé€‰æ‹©å»¶è¿Ÿæ‰§è¡Œã€‚

      ```c++
      auto future = std::async(func);        // ä½¿ç”¨é»˜è®¤å‘å°„æ¨¡å¼æ‰§è¡Œfunc
      ```

      ä½†æ˜¯è¿™ä¸ªç­–ç•¥è¦æ…ç”¨ï¼Œå› ä¸ºï¼š

      [c++ - std::asyncçš„ä½¿ç”¨æ€»ç»“](https://segmentfault.com/a/1190000039083151)

      1. è¿™ç§è°ƒåº¦ç­–ç•¥æˆ‘ä»¬æ²¡æœ‰åŠæ³•é¢„çŸ¥å‡½æ•°`func`æ˜¯å¦ä¼šåœ¨å“ªä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œç”šè‡³æ— æ³•é¢„çŸ¥ä¼šä¸ä¼šè¢«æ‰§è¡Œï¼Œå› ä¸º`func`å¯èƒ½ä¼šè¢«è°ƒåº¦ä¸ºæ¨è¿Ÿæ‰§è¡Œï¼Œå³è°ƒç”¨`get`æˆ–`wait`çš„æ—¶å€™æ‰§è¡Œï¼Œè€Œ`get`æˆ–`wait`æ˜¯å¦ä¼šè¢«æ‰§è¡Œæˆ–è€…åœ¨å“ªä¸ªçº¿ç¨‹æ‰§è¡Œéƒ½æ— æ³•é¢„çŸ¥ã€‚

      2. åŒæ—¶è¿™ç§è°ƒåº¦ç­–ç•¥çš„çµæ´»æ€§è¿˜ä¼šæ··æ·†ä½¿ç”¨`thread_local`å˜é‡ï¼Œè¿™æ„å‘³ç€å¦‚æœfuncå†™æˆ–è¯»è¿™ç§çº¿ç¨‹æœ¬åœ°å­˜å‚¨(Thread Local Storageï¼ŒTLS)ï¼Œé¢„çŸ¥å–åˆ°å“ªä¸ªçº¿ç¨‹çš„æœ¬åœ°å˜é‡æ˜¯ä¸å¯èƒ½çš„ã€‚

      3. å®ƒä¹Ÿå½±å“äº†åŸºäºwaitå¾ªç¯ä¸­çš„è¶…æ—¶æƒ…å†µï¼Œå› ä¸ºè°ƒåº¦ç­–ç•¥å¯èƒ½ä¸º`deferred`çš„ï¼Œè°ƒç”¨`wait_for`æˆ–è€…`wait_until`ä¼šè¿”å›å€¼`std::launch::deferred`ã€‚è¿™æ„å‘³ç€ä¸‹é¢çš„å¾ªç¯ï¼Œçœ‹èµ·æ¥æœ€ç»ˆä¼šåœæ­¢ï¼Œä½†æ˜¯ï¼Œå®é™…ä¸Šå¯èƒ½ä¼šä¸€ç›´è¿è¡Œï¼š

         ```c++
         void func()           // fç¡çœ 1ç§’åè¿”å›
         {
             std::this_thread::sleep_for(1);
         }
         auto future = std::async(func);      // ï¼ˆæ¦‚å¿µä¸Šï¼‰å¼‚æ­¥æ‰§è¡Œf
         while(fut.wait_for(100ms) !=         // å¾ªç¯ç›´åˆ°fæ‰§è¡Œç»“æŸ
               std::future_status::ready)     // ä½†è¿™å¯èƒ½æ°¸è¿œä¸ä¼šå‘ç”Ÿ
         {
             ...
         }
         ```

         ä¸ºé¿å…é™·å…¥æ­»å¾ªç¯ï¼Œæˆ‘ä»¬å¿…é¡»æ£€æŸ¥futureæ˜¯å¦æŠŠä»»åŠ¡æ¨è¿Ÿï¼Œç„¶è€Œfutureæ— æ³•è·çŸ¥ä»»åŠ¡æ˜¯å¦è¢«æ¨è¿Ÿï¼Œä¸€ä¸ªå¥½çš„æŠ€å·§å°±æ˜¯é€šè¿‡`wait_for(0)`æ¥è·å–`future_status`æ˜¯å¦æ˜¯`deferred`ï¼š

         ```c++
             auto fut = std::async(func);      // ï¼ˆæ¦‚å¿µä¸Šï¼‰å¼‚æ­¥æ‰§è¡Œf
             if (fut.wait_for(0s) == std::future_status::deferred){  // å¦‚æœä»»åŠ¡è¢«æ¨è¿Ÿ
                 // futä½¿ç”¨getæˆ–waitæ¥åŒæ­¥è°ƒç”¨f
             } else {            // ä»»åŠ¡æ²¡æœ‰è¢«æ¨è¿Ÿ
                 while(fut.wait_for(100ms) != std::future_status::ready) { // ä¸å¯èƒ½æ— é™å¾ªç¯
                     // ä»»åŠ¡æ²¡æœ‰è¢«æ¨è¿Ÿ(deferred)ä¹Ÿæ²¡æœ‰å°±ç»ª(ready)ï¼Œæ‰€ä»¥åšä¸€äº›å¹¶å‘çš„äº‹æƒ…ç›´åˆ°ä»»åŠ¡å°±ç»ª
                   }
                 cout << fut.get() << endl;        // å½“funcæ‰§è¡Œå®Œæ¯•ä¸”æœªè¢«get()/wait()æ—¶ï¼Œfutå°±ç»ª
             }
         ```

    - MSVC STL

      æ­¤ç­–ç•¥ä¸ `launch::async` æ‰§è¡Œç­–ç•¥æ¯«æ— åŒºåˆ«ï¼Œå› ä¸ºæºç å¦‚ä¸‹ï¼š

      ```c++
      template <class _Ret, class _Fty>
      _Associated_state<typename _P_arg_type<_Ret>::type>* _Get_associated_state(launch _Psync, _Fty&& _Fnarg) {
           // construct associated asynchronous state object for the launch type
           switch (_Psync) { // select launch type
           case launch::deferred:
                 return new _Deferred_async_state<_Ret>(_STD forward<_Fty>(_Fnarg));
           case launch::async: // TRANSITION, fixed in vMajorNext, should create a new thread here
           default:
                 return new _Task_async_state<_Ret>(_STD forward<_Fty>(_Fnarg));
           }
      }
      ```

      æ˜¾ç„¶ï¼Œé™¤äº†`std::launch::deferred`ä»¥å¤–ï¼Œå…¶ä»–ç­–ç•¥éƒ½æ˜¯ç«‹åˆ»æ‰§è¡Œã€‚

      ä¸” `_Task_async_state` ä¼šé€šè¿‡ [`::Concurrency::create_task`](https://github.com/microsoft/STL/blob/f54203f/stl/inc/future#L663-L665)[[1\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#footnote1) ä»å¾®è½¯pplå¹¶è¡Œåº“çš„çº¿ç¨‹æ± ä¸­è·å–çº¿ç¨‹å¹¶æ‰§è¡Œä»»åŠ¡è¿”å›åŒ…è£…å¯¹è±¡ã€‚

      ç®€è€Œè¨€ä¹‹ï¼Œä½¿ç”¨ `std::async`ï¼Œåªè¦ä¸æ˜¯ `launch::deferred` ç­–ç•¥ï¼Œé‚£ä¹ˆ MSVC STL å®ç°ä¸­éƒ½æ˜¯å¿…ç„¶åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡ã€‚å› ä¸ºæ˜¯çº¿ç¨‹æ± ï¼Œæ‰€ä»¥æ‰§è¡Œæ–°ä»»åŠ¡æ˜¯å¦åˆ›å»ºæ–°çº¿ç¨‹ï¼Œä»»åŠ¡æ‰§è¡Œå®Œæ¯•çº¿ç¨‹æ˜¯å¦ç«‹å³é”€æ¯ï¼Œ***ä¸ç¡®å®š***ã€‚

- `std::async`å…¶ä»–æ³¨æ„äº‹é¡¹ï¼š

  1. å¦‚æœä» `std::async` è·å¾—çš„ [`std::future`](https://zh.cppreference.com/w/cpp/thread/future) æ²¡æœ‰è¢«ç§»åŠ¨æˆ–ç»‘å®šåˆ°å¼•ç”¨ï¼Œé‚£ä¹ˆåœ¨å®Œæ•´è¡¨è¾¾å¼ç»“å°¾ï¼Œ `std::future` çš„**[ææ„å‡½æ•°](https://zh.cppreference.com/w/cpp/thread/future/~future)å°†é˜»å¡ï¼Œç›´åˆ°åˆ°å¼‚æ­¥ä»»åŠ¡å®Œæˆ**ã€‚å› ä¸ºä¸´æ—¶å¯¹è±¡çš„ç”Ÿå­˜æœŸå°±åœ¨è¿™ä¸€è¡Œï¼Œè€Œå¯¹è±¡ç”Ÿå­˜æœŸç»“æŸå°±ä¼šè°ƒç”¨è°ƒç”¨ææ„å‡½æ•°ã€‚

     ```c++
     std::async(std::launch::async, []{ f(); }); // ä¸´æ—¶é‡çš„ææ„å‡½æ•°ç­‰å¾… f()
     std::async(std::launch::async, []{ g(); }); // f() å®Œæˆå‰ä¸å¼€å§‹
     ```

     è§£é‡Šï¼š

     - ç¬¬ä¸€ä¸ª`std::async`ï¼Œä¼šè¿”å›ä¸€ä¸ªä¸´æ—¶çš„`future`å¯¹è±¡ï¼Œç”±äºæ˜¯ä¸´æ—¶å¯¹è±¡ï¼Œæ‰€ä»¥åœ¨åœ¨ä¸€è¡Œç»“æŸåä¼šç«‹åˆ»è°ƒç”¨ææ„å‡½æ•°é‡Šæ”¾ï¼Œè€Œ`future`çš„ææ„å‡½æ•°ä¸­ï¼Œä¼šè°ƒç”¨å‡½æ•°é˜»å¡ç­‰å¾…å¼‚æ­¥ä»»åŠ¡å®Œæˆï¼Œæ‰€ä»¥è¿™ä¸ªå…¶å®å°±æ˜¯åŒæ­¥ã€‚

  2. è¢«ç§»åŠ¨çš„ `std::future` æ²¡æœ‰æ‰€æœ‰æƒï¼Œå¤±å»å…±äº«çŠ¶æ€ï¼Œä¸èƒ½è°ƒç”¨ `get`ã€`wait` æˆå‘˜å‡½æ•°ã€‚

     ```c++
     auto t = std::async([] {});
     std::future<void> fut{ std::move(t) };
     t.wait();   // Error! æŠ›å‡ºå¼‚å¸¸
     fut.wait()	// OK!
     ```

     å¦‚åŒæ²¡æœ‰çº¿ç¨‹èµ„æºæ‰€æœ‰æƒçš„ `std::thread` å¯¹è±¡è°ƒç”¨ `join()` ä¸€æ ·é”™è¯¯ï¼Œè¿™æ˜¯ç§»åŠ¨è¯­ä¹‰çš„åŸºæœ¬è¯­ä¹‰é€»è¾‘ã€‚
  
- [#æ€»ç»“](#ä½¿ç”¨asyncåˆ›å»ºå¼‚æ­¥ä»»åŠ¡è·å–è¿”å›å€¼)

### ä½¿ç”¨std::packaged_taskï¼Ÿï¼Ÿï¼Ÿ

[ï¼ˆåŸåˆ›ï¼‰ç”¨C++11çš„std::asyncä»£æ›¿çº¿ç¨‹çš„åˆ›å»º - å—å“¥çš„å¤©ä¸‹ - åšå®¢å›­](https://www.cnblogs.com/leijiangtao/p/12076251.html)

- å®šä¹‰ï¼š

  ç±»æ¨¡æ¿ [`std::packaged_task`](https://zh.cppreference.com/w/cpp/thread/packaged_task) åŒ…è£…ä»»ä½•`å¯è°ƒç”¨(Callable)`ç›®æ ‡ï¼ˆå‡½æ•°ã€lambda è¡¨è¾¾å¼ã€bind è¡¨è¾¾å¼æˆ–å…¶å®ƒå‡½æ•°å¯¹è±¡ï¼‰ï¼Œä½¿å¾—èƒ½**å¼‚æ­¥**è°ƒç”¨å®ƒã€‚å…¶è¿”å›å€¼æˆ–æ‰€æŠ›å¼‚å¸¸è¢«å­˜å‚¨äºèƒ½é€šè¿‡ `std::future` å¯¹è±¡è®¿é—®çš„å…±äº«çŠ¶æ€ä¸­ã€‚

  **ç±»æ¨¡æ¿ï¼›åªèƒ½æ¥æ”¶å¯è°ƒç”¨å¯¹è±¡å’Œå‚æ•°è¿›è¡Œæ„é€ ï¼›è¯¥ç±»æ¨¡æ¿çš„å¯¹è±¡æ˜¯å‡½æ•°å¯¹è±¡ï¼›åªèƒ½ç§»åŠ¨ï¼Œä¸å¯å¤åˆ¶ã€‚**

- ä½œç”¨ï¼š

  **è¯¥ç±»æ¨¡æ¿ä¼šå°†å¯è°ƒç”¨å¯¹è±¡å’Œå‚æ•°è¿›è¡Œå°è£…ï¼Œæ–¹ä¾¿å¼‚æ­¥è°ƒç”¨ï¼Œåœ¨è°ƒç”¨å®Œæˆåï¼Œä¼šå°†å‡½æ•°è¿”å›ç»“æœå’ŒæŠ›å‡ºçš„å¼‚å¸¸å­˜å‚¨åœ¨èƒ½é€šè¿‡ `std::future` å¯¹è±¡è®¿é—®çš„å…±äº«çŠ¶æ€ä¸­ã€‚**

- ç¤ºä¾‹ï¼š

  - ç®€å•ä½¿ç”¨ï¼ˆæ— æ³•è·å–è¿”å›å€¼ï¼‰ï¼š

    ```c++
    std::packaged_task<double(int, int)> task([](int a, int b){
        return std::pow(a, b);
    });
    task(10, 2); // æ‰§è¡Œä¼ é€’çš„ lambdaï¼Œä½†æ— æ³•è·å–è¿”å›å€¼
    ```

    å®ƒæœ‰ [`operator()`](https://zh.cppreference.com/w/cpp/thread/packaged_task/operator()) çš„é‡è½½ï¼Œå®ƒä¼šæ‰§è¡Œæˆ‘ä»¬ä¼ é€’çš„[*å¯è°ƒç”¨(Callable)*](https://zh.cppreference.com/w/cpp/named_req/Callable)å¯¹è±¡ï¼Œä¸è¿‡è¿™ä¸ªé‡è½½çš„è¿”å›ç±»å‹æ˜¯ `void` **æ²¡åŠæ³•è·å–è¿”å›å€¼**ã€‚

  - å’Œ `std::future` é…åˆä½¿ç”¨ï¼ˆé€šè¿‡futureè·å–è¿”å›å€¼ï¼‰ï¼š

    ```c++
    std::packaged_task<double(int, int)> task([](int a, int b){
        return std::pow(a, b);
    });
    // å°†taskä¸­çš„å…±äº«çŠ¶æ€ä¸futè¿›è¡Œç»‘å®šï¼Œå½“ç„¶ä¹Ÿå¯ä»¥å…ˆæ‰§è¡Œtask(10,2)å†ç»‘å®š
    std::future<double>fut = task.get_future();	
    task(10, 2); // æ­¤å¤„æ‰§è¡Œä»»åŠ¡
    std::cout << fut.get() << '\n'; // ä¸é˜»å¡ï¼Œæ­¤å¤„è·å–è¿”å›å€¼
    ```

    ï¼Ÿï¼Ÿï¼Ÿé—®é¢˜ï¼šæŠŠ`future.get()`æ”¾åœ¨`task(10, 2)`å‰é¢ä¸ºä»€ä¹ˆä¸ä¼šåƒasyncé‚£æ ·æ‰§è¡Œå‘¢ï¼Œ`future.get()`åªä¼šç­‰å¾…å¯¹åº”å‡½æ•°æ‰§è¡Œå—ï¼Ÿ

  - å¼‚æ­¥è°ƒç”¨`packaged_task`ç±»çš„å‡½æ•°å¯¹è±¡

    ```c++
    std::packaged_task<double(int, int)> task([](int a, int b){
        return std::pow(a, b);
    });
    std::future<double> future = task.get_future();
    std::thread t{ std::move(task),10,2 }; // ä»»åŠ¡åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œå…¶ä¸­taskåªèƒ½ç§»åŠ¨
    // todo.. å¹»æƒ³è¿˜æœ‰è®¸å¤šè€—æ—¶çš„ä»£ç 
    t.join();
    
    std::cout << future.get() << '\n'; // å¹¶ä¸é˜»å¡ï¼Œè·å–ä»»åŠ¡è¿”å›å€¼ç½¢äº†
    ```

    å› ä¸º `task` æœ¬èº«æ˜¯é‡è½½äº† `operator()` çš„ï¼Œæ˜¯å¯è°ƒç”¨å¯¹è±¡ï¼Œè‡ªç„¶å¯ä»¥ä¼ é€’ç»™ `std::thread` æ‰§è¡Œï¼Œä»¥åŠä¼ é€’è°ƒç”¨å‚æ•°ã€‚å”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯æˆ‘ä»¬ä½¿ç”¨äº† `std::move` ï¼Œ**è¿™æ˜¯å› ä¸º `std::packaged_task` åªèƒ½ç§»åŠ¨ï¼Œä¸èƒ½å¤åˆ¶ã€‚**

- ï¼ˆå°æŠ€å·§ï¼‰è§„å®šç±»æ¨¡æ¿åªèƒ½ä½¿ç”¨å‡½æ•°åˆå§‹åŒ–ï¼š

  ![image-20241129110320070](assets/image-20241129110320070.png)

  å¦‚æœå†™è¿™æ ·çš„ä»£ç ï¼š

  ```c++
  packaged_task<int(int)> pt1;
  pt1.get_future();
  ```

  åˆ™ç¬¬ä¸€è¡Œèƒ½è¿‡ç¼–è¯‘ï¼Œç¬¬äºŒè¡Œæ˜¾ç„¶ä¼šæŠ¥é”™ï¼ˆè¿è¡Œæ—¶æŠ¥é”™ï¼Œä¸æ˜¯ç¼–è¯‘æ—¶æŠ¥é”™ï¼Œå¾ˆå¥‡æ€ªï¼‰ã€‚

### ä½¿ç”¨std::promise

- æ¦‚å¿µï¼š

  ç±»æ¨¡æ¿ [`std::promise`](https://zh.cppreference.com/w/cpp/thread/promise) ç”¨äºå­˜å‚¨ä¸€ä¸ªå€¼æˆ–ä¸€ä¸ªå¼‚å¸¸ï¼Œä¹‹åé€šè¿‡ `std::promise` å¯¹è±¡æ‰€åˆ›å»ºçš„ [std::future](https://zh.cppreference.com/w/cpp/thread/future) å¯¹è±¡å¼‚æ­¥è·å¾—ã€‚

- ç¤ºä¾‹ï¼š

  - `set_value()`çš„ä½¿ç”¨

    ```c++
    // è®¡ç®—å‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªæ•´æ•°å¹¶è¿”å›å®ƒçš„å¹³æ–¹
    void calculate_square(std::promise<int> promiseObj, int num) {
        // æ¨¡æ‹Ÿä¸€äº›è®¡ç®—
        std::this_thread::sleep_for(1s);
    
        // è®¡ç®—å¹³æ–¹å¹¶è®¾ç½®å€¼åˆ° promise ä¸­
        promiseObj.set_value(num * num);
        
        // æ¨¡æ‹Ÿåç»­çš„ä¸€äº›è®¡ç®—
        std::this_thread::sleep_for(2s);
    }
    
    // åˆ›å»ºä¸€ä¸ª promise å¯¹è±¡ï¼Œç”¨äºå­˜å‚¨è®¡ç®—ç»“æœ
    std::promise<int> promise;
    
    // ä» promise è·å– future å¯¹è±¡è¿›è¡Œå…³è”
    std::future<int> future = promise.get_future();
    
    // å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹è¿›è¡Œè®¡ç®—
    int num = 5;
    std::thread t(calculate_square, std::move(promise), num);
    
    // é˜»å¡ï¼Œç›´åˆ°ç»“æœå¯ç”¨
    int result = future.get();
    std::cout << num << " çš„å¹³æ–¹æ˜¯ï¼š" << result << std::endl;
    
    t.join();
    ```

    è§£é‡Šï¼š

    - `promiseObj.set_value()`ç”¨äºç»™å…±äº«çŠ¶æ€è®¾ç½®å€¼ã€‚

    - `std::promise` **åªèƒ½ç§»åŠ¨**ï¼Œä¸å¯å¤åˆ¶ï¼Œæ‰€ä»¥ä½¿ç”¨ `std::move` è¿›è¡Œä¼ é€’ã€‚
    - æ³¨æ„ç”¨è¯ï¼š`future.get()`ä¼šé˜»å¡ï¼Œç›´åˆ°ç»“æœå¯ç”¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨`promiseObj.set_value(num * num);`ç»“æŸåï¼Œ`future.get()`çš„é˜»å¡å°±ä¼šç«‹åˆ»ç»“æŸï¼Œå¹¶è¿”å›ç»“æœï¼Œä¸ä¼šç­‰åˆ°`this_thread::sleep_for(2s);`æ‰§è¡Œå®Œæ‰ç»“æŸé˜»å¡ã€‚
    - è¯¥å‡½æ•°å†…éƒ¨**é€šè¿‡æ¡ä»¶å˜é‡å®ç°é˜»å¡**çš„ï¼Œå»ºè®®çœ‹çœ‹æºç ã€‚

  - `set_exception()`çš„ä½¿ç”¨

    ```c++
    void throw_function(std::promise<int> prom) {
        try {
            throw std::runtime_error("ä¸€ä¸ªå¼‚å¸¸");
        }
        catch (...) {
            // ç»™promiseè®¾ç½®äº†ä¸€ä¸ªå¼‚å¸¸
            prom.set_exception(std::current_exception());
        }
    }
    
    int main() {
        std::promise<int> prom;
        std::future<int> fut = prom.get_future();
    
        std::thread t(throw_function, std::move(prom));
    
        try {
            std::cout << "ç­‰å¾…çº¿ç¨‹æ‰§è¡Œï¼ŒæŠ›å‡ºå¼‚å¸¸å¹¶è®¾ç½®\n";
            // futureé€šè¿‡get()æ”¶åˆ°äº†è¯¥å¼‚å¸¸ï¼Œå¹¶ç»§ç»­æŠ›å‡ºã€‚
            fut.get();
        }
        catch (std::exception& e) {
            std::cerr << "æ¥è‡ªçº¿ç¨‹çš„å¼‚å¸¸: " << e.what() << '\n';
        }
        t.join();
    }
    ```

    è§£é‡Šï¼š

    - `prom.set_exception()` ç”¨äºç»™å…±äº«çŠ¶æ€è®¾ç½®å¼‚å¸¸ã€‚
    - è¯¥å‡½æ•°æ¥å—ä¸€ä¸ª [`std::exception_ptr`](https://zh.cppreference.com/w/cpp/error/exception_ptr) ç±»å‹çš„å‚æ•°ï¼Œè¿™ä¸ªå‚æ•°é€šå¸¸é€šè¿‡ [`std::current_exception()`](https://zh.cppreference.com/w/cpp/error/current_exception) è·å–ï¼Œç”¨äºæŒ‡ç¤ºå½“å‰çº¿ç¨‹ä¸­æŠ›å‡ºçš„å¼‚å¸¸ã€‚ç„¶åï¼Œ`std::future` å¯¹è±¡é€šè¿‡ `get()` å‡½æ•°è·å–è¿™ä¸ªå¼‚å¸¸ï¼Œå¦‚æœ `promise` æ‰€åœ¨çš„å‡½æ•°æœ‰å¼‚å¸¸è¢«æŠ›å‡ºï¼Œåˆ™ `std::future` å¯¹è±¡ä¼šé‡æ–°æŠ›å‡ºè¿™ä¸ªå¼‚å¸¸ï¼Œä»è€Œå…è®¸ä¸»çº¿ç¨‹æ•è·å¹¶å¤„ç†å®ƒã€‚
    - æ³¨æ„`set_exception()`å’Œ`set_value()`ä¸èƒ½åŒæ—¶ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´**å…±äº«çŠ¶æ€ä¸­è¦ä¹ˆå­˜å‚¨å‡½æ•°è¿”å›å€¼ï¼Œè¦ä¹ˆå­˜å‚¨æŠ›å‡ºçš„å¼‚å¸¸**ï¼Œè¿™å¾ˆç¬¦åˆå¸¸ç†ï¼Œæ¯•ç«Ÿå‡½æ•°æ‰§è¡Œä¹‹åè¦ä¹ˆæŠ›å‡ºå¼‚å¸¸ï¼Œè¦ä¹ˆè¿”å›ç»“æœã€‚

### futureï¼Œpackaged_taskï¼Œpromiseæ€»ç»“

`future`ï¼ˆ`_State_manager<>`çš„å­ç±»ï¼‰ï¼Œ`packaged_task`ï¼Œ`promise`åªèƒ½é€šè¿‡ä»–ä»¬è‡ªå·±çš„ç±»æˆå‘˜ï¼ˆ`_Promise`å¯¹è±¡ï¼‰è®¿é—®å…±äº«çŠ¶æ€ï¼Œä¸”ä»–ä»¬å‡åªèƒ½ç§»åŠ¨ï¼Œä¸å¯å¤åˆ¶ã€‚å…¶ä¸­ï¼š

- `_Associated_state<>`æ˜¯ä¸€ä¸ªç±»ï¼Œè¿™ä¸ªç±»å°±å«å…±äº«çŠ¶æ€ã€‚

- `_State_manager<>`ç±»ç›´æ¥æŒæœ‰å…±äº«çŠ¶æ€ï¼Œå¯ä»¥ç›´æ¥è¯»ï¼Œå†™å…±äº«çŠ¶æ€ã€‚

- `_Promise<>`ç±»ä½¿ç”¨`_State_manager<>`å¯¹è±¡ä½œä¸ºç±»æˆå‘˜ï¼Œé—´æ¥æŒæœ‰å…±äº«çŠ¶æ€ã€‚è¯¥ç±»ï¼š**â‘ æ— æ³•ä¿®æ”¹å…±äº«çŠ¶æ€ï¼Œâ‘¡åªèƒ½å¯¹`_State_manager<>`è¿›è¡Œè¯»æ“ä½œã€‚**

  ```c++
  // _Promise<>ä¸­çš„æŸä¸ªæˆå‘˜å‡½æ•°ï¼Œå…¶ä»–æˆå‘˜å‡½æ•°ä¹Ÿä¸è¿™ä¸ªç±»ä¼¼
  _State_manager<_Ty>& _Get_state_for_set() {
          if (!this._State.valid()) {
              _Throw_future_error2(future_errc::no_state);
          }
  
          return this._State;	//_State_manager<>ç±»å¯¹è±¡
      }
  ```

- `future<>`ç±»æ˜¯`_State_manager<>`çš„å­ç±»ï¼Œç›´æ¥æŒæœ‰å…±äº«çŠ¶æ€ã€‚è¯¥ç±»ï¼š**â‘ æ— æ³•ä¿®æ”¹å…±äº«çŠ¶æ€ï¼›â‘¡åªèƒ½å¯¹å…±äº«çŠ¶æ€ä¸­å­˜å‚¨çš„å‡½æ•°è¿”å›å€¼/æŠ›å‡ºçš„å¼‚å¸¸è¿›è¡Œè¯»æ“ä½œã€‚**

  ```c++
  _Ty get() {
      // block until ready then return the stored result or throw the stored exception
      future _Local{_STD move(*this)};
      return _STD move(_Local._Get_value());
  }
  ```

- `promise<>`ç±»ä½¿ç”¨`_Promise<>`ç±»å¯¹è±¡ä½œä¸ºç±»æˆå‘˜ï¼Œé—´æ¥æŒæœ‰å…±äº«çŠ¶æ€ã€‚è¯¥ç±»ï¼š**â‘ å¯ä»¥ä½¿ç”¨`future<>`ç±»å¯¹è±¡ä¸é—´æ¥æŒæœ‰çš„å…±äº«çŠ¶æ€è¿›è¡Œç»‘å®šï¼Œâ‘¡å¯ä»¥å¯¹é—´æ¥æŒæœ‰çš„å…±äº«çŠ¶æ€è¿›è¡Œå†™æ“ä½œã€‚**

  ```c++
  // è¿”å›ä¸€ä¸ª future<> å¯¹è±¡ï¼Œé€šè¿‡ _MyPromise å¯¹ _State_manager<> è¿›è¡Œè¯»æ“ä½œ
  future<_Ty> get_future() {
  	return future<_Ty>(_From_raw_state_tag{}, _MyPromise._Get_state_for_future());
  }
  
  // é€šè¿‡ _MyPromise å¯¹ _State_manager<> è¿›è¡Œå†™æ“ä½œ
  void set_value(const _Ty& _Val) {
      _MyPromise._Get_state_for_set()._Set_value(_Val, false);
  }
  ```

- `packaged_task<>`ç±»ä½¿ç”¨`_Promise`å¯¹è±¡ä½œä¸ºç±»æˆå‘˜ï¼Œé—´æ¥æŒæœ‰å…±äº«çŠ¶æ€ã€‚è¯¥ç±»ï¼š**â‘ å¯ä»¥ä½¿ç”¨`future<>`ç±»å¯¹è±¡ä¸é—´æ¥æŒæœ‰çš„å…±äº«çŠ¶æ€è¿›è¡Œç»‘å®šï¼Œâ‘¡å¯ä»¥æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°ï¼Œå¹¶å°†å‡½æ•°çš„è¿”å›å€¼/æŠ›å‡ºçš„å¼‚å¸¸å­˜å‚¨äºå…±äº«çŠ¶æ€ä¸­ã€‚**

  ```c++
  future<_Ret> get_future() {
      return future<_Ret>(_From_raw_state_tag{}, _MyPromise._Get_state_for_future());
  }
  
  void operator()(_ArgTypes... _Args) {
      _State_manager<_Ptype>& _State = _MyPromise._Get_state_for_set();
      _MyStateType* _Ptr          = static_cast<_MyStateType*>(_State._Ptr());
      // è¿™é‡Œå°±æ˜¯é€šè¿‡_Ptræ‰§è¡Œäº†æŒ‡å®šçš„å‡½æ•°ï¼Œå¹¶å°†æ‰§è¡Œç»“æœå­˜å‚¨äºå…±äº«çŠ¶æ€ä¸­ã€‚
      _Ptr->_Call_immediate(_STD forward<_ArgTypes>(_Args)...);
  }
  ```

### futureçš„çŠ¶æ€å˜åŒ–

- å‰è¨€ï¼š

  éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ**future æ˜¯ä¸€æ¬¡æ€§çš„**ï¼Œæ‰€ä»¥ä½ éœ€è¦æ³¨æ„ç§»åŠ¨ã€‚å¹¶ä¸”ï¼Œè°ƒç”¨ `get` å‡½æ•°åï¼Œfuture å¯¹è±¡ä¹Ÿä¼š**å¤±å»å…±äº«çŠ¶æ€**ã€‚

  - **ç§»åŠ¨è¯­ä¹‰**ï¼šè¿™ä¸€ç‚¹å¾ˆå¥½ç†è§£å¹¶ä¸”å¸¸è§ï¼Œå› ä¸º**ç§»åŠ¨æ“ä½œæ ‡å¿—ç€æ‰€æœ‰æƒçš„è½¬ç§»**ï¼Œæ„å‘³ç€ `future` ä¸å†æ‹¥æœ‰å…±äº«çŠ¶æ€ï¼ˆå¦‚ä¹‹å‰æ‰€æåˆ°ï¼‰ã€‚`get` å’Œ `wait` å‡½æ•°è¦æ±‚ `future` å¯¹è±¡æ‹¥æœ‰å…±äº«çŠ¶æ€ï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
  - **å…±äº«çŠ¶æ€å¤±æ•ˆ**ï¼šè°ƒç”¨ `get` æˆå‘˜å‡½æ•°æ—¶ï¼Œ`future` å¯¹è±¡å¿…é¡»æ‹¥æœ‰å…±äº«çŠ¶æ€ï¼Œä½†è°ƒç”¨å®Œæˆåï¼Œå®ƒå°±ä¼š**å¤±å»å…±äº«çŠ¶æ€**ï¼Œä¸èƒ½å†æ¬¡è°ƒç”¨ `get`ã€‚è¿™æ˜¯æˆ‘ä»¬åœ¨æœ¬èŠ‚éœ€è¦ç‰¹åˆ«è®¨è®ºçš„å†…å®¹ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  std::future<void>future = std::async([] {});
  std::cout << std::boolalpha << future.valid() << '\n'; // true
  future.get();
  std::cout << std::boolalpha << future.valid() << '\n'; // false
  try {
      future.get(); // æŠ›å‡º future_errc::no_state å¼‚å¸¸
  }
  catch (std::exception& e) {
      std::cerr << e.what() << '\n';
  }
  ```

- `get()`æºç 

  ```c++
  // std::future<void>
  void get() {
      // block until ready then return or throw the stored exception
      future _Local{_STD move(*this)};
      _Local._Get_value();
  }
  // std::future<T>
  _Ty get() {
      // block until ready then return the stored result or throw the stored exception
      future _Local{_STD move(*this)};
      return _STD move(_Local._Get_value());
  }
  // std::future<T&>
  _Ty& get() {
      // block until ready then return the stored result or throw the stored exception
      future _Local{_STD move(*this)};
      return *_Local._Get_value();
  }
  ```

  è§£é‡Šï¼š

  - `future _Local{_STD move(*this)};` å°†å½“å‰å¯¹è±¡çš„å…±äº«çŠ¶æ€è½¬ç§»ç»™äº†è¿™ä¸ªå±€éƒ¨å¯¹è±¡ï¼Œè€Œå±€éƒ¨å¯¹è±¡åœ¨å‡½æ•°ç»“æŸæ—¶ææ„ã€‚è¿™æ„å‘³ç€**`get()`ç»“æŸåå½“å‰å¯¹è±¡å¤±å»å…±äº«çŠ¶æ€ï¼Œå¹¶ä¸”çŠ¶æ€è¢«å®Œå…¨é”€æ¯**ã€‚
  - `std::future<_Ty>` è¿™ä¸ªç‰¹åŒ–ï¼Œå®ƒ `return std::move` æ˜¯ä¸ºäº†**æ”¯æŒåªèƒ½ç§»åŠ¨çš„ç±»å‹**èƒ½å¤Ÿä½¿ç”¨ `get` è¿”å›å€¼ï¼Œå‚è§å‰æ–‡çš„ `move_only` ç±»å‹ã€‚

### å¤šä¸ªçº¿ç¨‹çš„ç­‰å¾…`std::shared_future`ï¼Ÿï¼Ÿï¼Ÿ

> - `shared_future<>`å¯è¿›è¡Œå¤åˆ¶æ„é€ ï¼Œä½†æ˜¯æ‰€æŒæœ‰çš„å…±äº«çŠ¶æ€éƒ½åªæœ‰ä¸€ä»½ï¼Œå› ä¸ºå…±äº«çŠ¶æ€ä»¥æŒ‡é’ˆçš„å½¢å¼å­˜å‚¨çš„ã€‚
> - æ˜¾ç„¶`std::future` ä¸ `std::shared_future` çš„åŒºåˆ«å°±å¦‚åŒ `std::unique_ptr`ã€`std::shared_ptr` ä¸€æ ·ã€‚

- å‰è¨€ï¼š

  ä¹‹å‰çš„ä¾‹å­ä¸­æˆ‘ä»¬ä¸€ç›´ä½¿ç”¨ `std::future`ï¼Œä½† `std::future` æœ‰ä¸€ä¸ªå±€é™ï¼š**future æ˜¯ä¸€æ¬¡æ€§çš„**ï¼Œå®ƒçš„ç»“æœåªèƒ½è¢«ä¸€ä¸ªçº¿ç¨‹è·å–ã€‚`get()` æˆå‘˜å‡½æ•°åªèƒ½è°ƒç”¨ä¸€æ¬¡ï¼Œå½“ç»“æœè¢«æŸä¸ªçº¿ç¨‹è·å–åï¼Œ`std::future` å°±æ— æ³•å†ç”¨äºå…¶ä»–çº¿ç¨‹ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  std::string fetch_data() {
      std::this_thread::sleep_for(std::chrono::seconds(1)); // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
      return "ä»ç½‘ç»œè·å–çš„æ•°æ®ï¼";
  }
  
  void thread_functio(std::future<int>& fut){
      std::cout << "çº¿ç¨‹1ï¼šç­‰å¾…æ•°æ®ä¸­..." << std::endl;
      fut.wait();
      std::cout << "çº¿ç¨‹1ï¼šæ”¶åˆ°æ•°æ®ï¼š" << fut.get() << std::endl;
  }
  
  int main() {
      std::future<std::string> future_data = std::async(std::launch::async, fetch_data);
  
      // // è½¬ç§»å…±äº«çŠ¶æ€ï¼ŒåŸæ¥çš„ future è¢«æ¸…ç©º  valid() == false
      std::shared_future<std::string> shared_future_data = future_data.share();
  
      // ç¬¬ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…ç»“æœå¹¶è®¿é—®æ•°æ®
      std::thread thread1(thread_functio, ref(shared_future_data));
  
      // ç¬¬äºŒä¸ªçº¿ç¨‹ç­‰å¾…ç»“æœå¹¶è®¿é—®æ•°æ®
      std::thread thread2(thread_functio, ref(shared_future_data));
  
      thread1.join();
      thread2.join();
  }
  ```

  è§£é‡Šï¼š

  - å¦‚æœä½¿ç”¨`future<>`ï¼Œç”±äº`future`æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œåªèƒ½è¢«è°ƒç”¨ä¸€æ¬¡ `get()` æˆå‘˜å‡½æ•°ï¼Œä»¥ä¸Šåœ¨ä¸¤ä¸ªçº¿ç¨‹ä¸­ï¼Œä¸€å®šä¼šè°ƒç”¨ä¸¤æ¬¡ï¼Œæ‰€ä»¥æœ‰é—®é¢˜ã€‚

  - `std::future` æ˜¯åªèƒ½ç§»åŠ¨çš„ï¼Œå…¶æ‰€æœ‰æƒå¯ä»¥åœ¨ä¸åŒçš„å¯¹è±¡ä¸­äº’ç›¸ä¼ é€’ï¼Œä½†åªæœ‰ä¸€ä¸ªå¯¹è±¡å¯ä»¥è·å¾—ç‰¹å®šçš„åŒæ­¥ç»“æœã€‚

    `std::shared_future` æ˜¯å¯å¤åˆ¶çš„ï¼Œå¤šä¸ªå¯¹è±¡å¯ä»¥æŒ‡ä»£åŒä¸€ä¸ªå…±äº«çŠ¶æ€ã€‚

  - `std::future` ä¸ `std::shared_future` çš„åŒºåˆ«å°±å¦‚åŒ `std::unique_ptr`ã€`std::shared_ptr` ä¸€æ ·ã€‚

  - åœ¨å¤šä¸ªçº¿ç¨‹ä¸­å¯¹**åŒä¸€ä¸ª \**`std::shared_future` å¯¹è±¡è¿›è¡Œæ“ä½œæ—¶ï¼ˆå¦‚æœæ²¡æœ‰è¿›è¡ŒåŒæ­¥ä¿æŠ¤ï¼‰å­˜åœ¨æ¡ä»¶ç«äº‰ã€‚è€Œä»å¤šä¸ªçº¿ç¨‹è®¿é—®åŒä¸€å…±äº«çŠ¶æ€ï¼Œè‹¥æ¯ä¸ªçº¿ç¨‹éƒ½æ˜¯é€šè¿‡å…¶è‡ªèº«çš„ `shared_future` å¯¹è±¡\**å‰¯æœ¬**è¿›è¡Œè®¿é—®ï¼Œåˆ™æ˜¯å®‰å…¨çš„ã€‚ï¼ˆå…·ä½“è§£é‡Šçœ‹æºç è§£æï¼Ÿï¼Ÿï¼Ÿï¼‰

  - ç”±äºæ­¤ä»£ç ä¸­ï¼Œ`shared_future<>`æŒ‰å¼•ç”¨ä¼ é€’ï¼Œä¸åŒçº¿ç¨‹è®¿é—®çš„æ˜¯åŒä¸€ä¸ª`shared_future` å¯¹è±¡å‰¯æœ¬ä¸”æ²¡æœ‰è¿›è¡ŒåŒæ­¥ä¿æŠ¤ï¼Œæ‰€ä»¥å­˜åœ¨æ¡ä»¶ç«äº‰ï¼Œè§£å†³åŠæ³•å¾ˆç®€å•ï¼Œå°†å¼•ç”¨ä¼ é€’æ”¹ä¸ºå€¼ä¼ é€’å³å¯ã€‚

  - `shared_future<>`å’Œ`future<>`å…¶å®æ²¡å•¥åŒºåˆ«ï¼Œä»–ä»¬éƒ½æ˜¯`_State_manager<>`çš„å­ç±»ï¼Œåªæ˜¯ä»–ä»¬ä¹‹é—´çš„æ„é€ å‡½æ•°ï¼Œ`get()`å‡½æ•°ä¹‹é—´æœ‰åŒºåˆ«ï¼Œä»–ä»¬ä¹‹é—´æœ€é‡è¦çš„åŒºåˆ«ï¼ˆä¹Ÿå°±æ˜¯å…±äº«å’Œç‹¬æœ‰çš„ç‰¹æ€§ï¼‰ï¼Œä½“ç°åœ¨ä»–ä»¬é€šè¿‡æ„é€ ä¼šè°ƒç”¨åŸºç±»çš„åŸºç±»ï¼ˆ`_Associated_state<>`ï¼‰ä¸­ä¸åŒçš„å‡½æ•°ï¼ˆæ¯”å¦‚å…±äº«å¯ä»¥é¢å¤–è°ƒç”¨åŸå­åŠ ï¼ŒåŸå­å‡ï¼‰ã€‚

- è¡¥å……ï¼š

  `std::promise` ä¹ŸåŒï¼Œå®ƒçš„ `get_future()` æˆå‘˜å‡½æ•°ä¸€æ ·å¯ä»¥ç”¨æ¥æ„é€  `std::shared_future`ï¼Œè™½ç„¶å®ƒçš„è¿”å›ç±»å‹æ˜¯ `std::future`ï¼Œä¸è¿‡ä¸å½±å“ï¼Œè¿™æ˜¯å› ä¸º `std::shared_future` æœ‰ä¸€ä¸ª `std::future<T>&&` å‚æ•°çš„[æ„é€ å‡½æ•°](https://zh.cppreference.com/w/cpp/thread/shared_future/shared_future)ï¼Œè½¬ç§» `std::future` çš„æ‰€æœ‰æƒã€‚

  ```c++
  std::promise<std::string> p;
  std::shared_future<std::string> sf{ p.get_future() }; // éšå¼è½¬ç§»æ‰€æœ‰æƒ
  ```

## é™æ—¶ç­‰å¾…

é˜»å¡è°ƒç”¨ä¼šå°†çº¿ç¨‹æŒ‚èµ·ä¸€æ®µï¼ˆä¸ç¡®å®šçš„ï¼‰æ—¶é—´ï¼Œç›´åˆ°å¯¹åº”çš„äº‹ä»¶å‘ç”Ÿã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™æ ·çš„æ–¹å¼å¾ˆå¥½ï¼Œä½†æ˜¯åœ¨ä¸€äº›æƒ…å†µä¸‹ï¼Œéœ€è¦é™å®šçº¿ç¨‹ç­‰å¾…çš„æ—¶é—´ï¼Œå› ä¸ºæ— é™æœŸåœ°ç­‰å¾…äº‹ä»¶å‘ç”Ÿå¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½ä¸‹é™æˆ–èµ„æºæµªè´¹ã€‚ä¸€ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯åœ¨å¾ˆå¤šç½‘ç»œåº“ä¸­çš„ `connect` å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è°ƒç”¨æ˜¯é˜»å¡çš„ï¼Œä½†æ˜¯ä¹Ÿæ˜¯é™æ—¶çš„ï¼Œä¸€å®šæ—¶é—´å†…æ²¡æœ‰è¿æ¥åˆ°æœåŠ¡å™¨å°±ä¸ä¼šç»§ç»­é˜»å¡äº†ï¼Œä¼šè¿›è¡Œå…¶å®ƒå¤„ç†ï¼Œæ¯”å¦‚æŠ›å‡ºå¼‚å¸¸ã€‚

ä»‹ç»ä¸¤ç§æŒ‡å®šè¶…æ—¶çš„æ–¹å¼ï¼Œä¸€ç§æ˜¯â€œ**æ—¶é—´æ®µ**â€ï¼Œå¦ä¸€ç§æ˜¯â€œ**æ—¶é—´ç‚¹**â€ï¼Œå…¶å®å°±æ˜¯å…ˆå‰è®²çš„ [`std::this::thread::sleep_for`](https://zh.cppreference.com/w/cpp/thread/sleep_for) ä¸ [`std::this_thread::sleep_until`](https://zh.cppreference.com/w/cpp/thread/sleep_until) çš„åŒºåˆ«ã€‚å‰è€…æ˜¯éœ€è¦æŒ‡å®šç­‰å¾…ä¸€æ®µæ—¶é—´ï¼ˆæ¯”å¦‚ 10 æ¯«ç§’ï¼‰ã€‚è€Œåè€…æ˜¯æŒ‡å®šç­‰å¾…åˆ°ä¸€ä¸ªå…·ä½“çš„æ—¶é—´ç‚¹ï¼ˆæ¯”å¦‚åˆ° 2024-05-07T12:01:10.123ï¼‰ã€‚å¤šæ•°å‡½æ•°éƒ½å¯¹ä¸¤ç§è¶…æ—¶æ–¹å¼è¿›è¡Œå¤„ç†ã€‚**å¤„ç†æŒç»­æ—¶é—´çš„å‡½æ•°ä»¥ `_for` ä½œä¸ºåç¼€ï¼Œå¤„ç†ç»å¯¹æ—¶é—´çš„å‡½æ•°ä»¥ `_until` ä½œä¸ºåç¼€**ã€‚

æ¡ä»¶å˜é‡ `std::condition_variable` çš„ç­‰å¾…å‡½æ•°ï¼Œä¹Ÿæœ‰ä¸¤ä¸ªè¶…æ—¶çš„ç‰ˆæœ¬ [`wait_for`](https://zh.cppreference.com/w/cpp/thread/condition_variable/wait_for) å’Œ [`wait_until`](https://zh.cppreference.com/w/cpp/thread/condition_variable/wait_until) ã€‚å®ƒä»¬å’Œæˆ‘ä»¬å…ˆå‰è®²çš„ `wait` æˆå‘˜å‡½æ•°ä¸€æ ·æœ‰ä¸¤ä¸ªé‡è½½ï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦ä¼ é€’ä¸€ä¸ª[*è°“è¯*](https://zh.cppreference.com/w/cpp/named_req/Predicate)ã€‚å®ƒä»¬ç›¸æ¯”äº `wait` å¤šäº†ä¸€ä¸ªè§£é™¤é˜»å¡çš„å¯èƒ½ï¼Œå³ï¼š**è¶…è¿‡æŒ‡å®šçš„æ—¶é•¿æˆ–æŠµè¾¾æŒ‡å®šçš„æ—¶é—´ç‚¹**ã€‚

åœ¨è®²è¿°å®ƒçš„ä½¿ç”¨ç»†èŠ‚ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜æ˜¯è¦æ¥å…ˆèŠä¸€ä¸‹ C++ ä¸­çš„[**æ—¶é—´åº“**](https://zh.cppreference.com/w/cpp/chrono#std::chrono_.E5.BA.93)ï¼ˆchronoï¼‰ï¼ŒæŒ‡å®šæ—¶é—´çš„æ–¹å¼ï¼Œå®ƒè¾ƒä¸ºéº»çƒ¦ã€‚æˆ‘ä»¬åˆ†ï¼š***æ—¶é’Ÿ**ï¼ˆclockï¼‰*ã€***æ—¶é—´æ®µ**ï¼ˆdurationï¼‰*ã€***æ—¶é—´ç‚¹**ï¼ˆtime pointï¼‰*ä¸‰ä¸ªé˜¶æ®µç¨å¾®ä»‹ç»ä¸€ä¸‹ã€‚

### æ—¶é’Ÿ

åœ¨ C++ æ ‡å‡†åº“ä¸­ï¼Œæ—¶é’Ÿè¢«è§†ä¸ºæ—¶é—´ä¿¡æ¯çš„æ¥æºã€‚C++ å®šä¹‰äº†å¾ˆå¤šç§æ—¶é—´ç±»å‹ï¼Œæ¯ç§æ—¶é’Ÿç±»å‹éƒ½æä¾›äº†å››ç§ä¸åŒçš„ä¿¡æ¯ï¼š

- å½“å‰æ—¶é—´ï¼š

  å½“å‰æ—¶é—´å¯ä»¥é€šè¿‡é™æ€æˆå‘˜å‡½æ•° `now` è·å–ï¼Œä¾‹å¦‚ï¼Œ[`std::chrono::system_clock::now()`](https://zh.cppreference.com/w/cpp/chrono/system_clock/now) ä¼šè¿”å›ç³»ç»Ÿçš„å½“å‰æ—¶é—´ã€‚ç‰¹å®šçš„æ—¶é—´ç‚¹åˆ™å¯ä»¥é€šè¿‡ [`time_point`](https://zh.cppreference.com/w/cpp/chrono/time_point) æ¥æŒ‡å®šã€‚`system_clock::now()` çš„è¿”å›ç±»å‹å°±æ˜¯ `time_point`ã€‚

- æ—¶é—´ç±»å‹ï¼š

  ```c++
  _EXPORT_STD using nanoseconds  = duration<long long, nano>;
  _EXPORT_STD using microseconds = duration<long long, micro>;
  _EXPORT_STD using milliseconds = duration<long long, milli>;
  _EXPORT_STD using seconds      = duration<long long>;
  _EXPORT_STD using minutes      = duration<int, ratio<60>>;//ï¼ˆ60ç§’ä¸€ä¸ªèŠ‚æ‹ï¼‰
  _EXPORT_STD using hours        = duration<int, ratio<3600>>;
  ```

- æ—¶é’ŸèŠ‚æ‹ï¼š

  æ—¶é’ŸèŠ‚æ‹è¢«æŒ‡å®šä¸º 1/xï¼ˆx åœ¨ä¸åŒç¡¬ä»¶ä¸Šæœ‰ä¸åŒçš„å€¼ï¼‰ç§’ï¼Œè¿™æ˜¯ç”±æ—¶é—´å‘¨æœŸæ‰€å†³å®šã€‚å‡è®¾ä¸€ä¸ªæ—¶é’Ÿä¸€ç§’æœ‰ 25 ä¸ªèŠ‚æ‹ï¼Œå› æ­¤ä¸€ä¸ªå‘¨æœŸä¸º `std::ratio<1,25>` ã€‚å½“ä¸€ä¸ªæ—¶é’Ÿçš„æ—¶é’ŸèŠ‚æ‹æ¯ 2.5 ç§’ä¸€æ¬¡ï¼Œå‘¨æœŸå°±å¯ä»¥è¡¨ç¤ºä¸º `std::ratio<5,2>`ï¼ˆ5ç§’ä¸¤ä¸ªèŠ‚æ‹ï¼‰ã€‚

  ç±»æ¨¡æ¿ [**`std::chrono::duration`**](https://zh.cppreference.com/w/cpp/chrono/duration) è¡¨ç¤ºæ—¶é—´é—´éš”ã€‚

  ```c++
  template<class Rep, class Period = std::ratio<1>>
  class duration;
  ```

  > [`std::ratio`](https://zh.cppreference.com/w/cpp/numeric/ratio/ratio) æ˜¯ä¸€ä¸ªåˆ†æ•°ç±»æ¨¡æ¿ï¼Œå®ƒæœ‰ä¸¤ä¸ªéç±»å‹æ¨¡æ¿å‚æ•°ï¼Œä¹Ÿå°±æ˜¯åˆ†å­ä¸åˆ†æ¯ï¼Œåˆ†æ¯æœ‰é»˜è®¤å®å‚ 1ï¼Œæ‰€ä»¥ `std::ratio<1>` ç­‰ä»·äº `std::ratio<1,1>`ï¼ˆæˆ‘ä»¬å¯ä»¥ç®€å•å°†`ratio<1>`å½“æˆ1ç§’ï¼‰ã€‚

  å¦‚ä½ æ‰€è§ï¼Œå®ƒé»˜è®¤çš„æ—¶é’ŸèŠ‚æ‹æ˜¯ 1ï¼ˆä¹Ÿå°±æ˜¯ä¸€ç§’ä¸€ä¸ªèŠ‚æ‹ï¼‰ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„ç±»ï¼Œæ ‡å‡†åº“é€šè¿‡å®ƒå®šä¹‰äº†å¾ˆå¤šçš„æ—¶é—´ç±»å‹ï¼Œæ¯”å¦‚ **`std::chrono::minutes`** æ˜¯åˆ†é’Ÿç±»å‹ï¼Œé‚£ä¹ˆå®ƒçš„ `Period` å°±æ˜¯ `std::ratio<60>` ï¼Œå› ä¸ºä¸€åˆ†é’Ÿç­‰äº 60 ç§’ã€‚

  ```c++
  using minutes      = duration<int, ratio<60>>;
  ```

- ç¨³å®šæ—¶é’Ÿï¼š

  ç¨³å®šæ—¶é’Ÿï¼ˆSteady Clockï¼‰æ˜¯æŒ‡æä¾›ç¨³å®šã€æŒç»­é€’å¢çš„æ—¶é—´æµé€ä¿¡æ¯çš„æ—¶é’Ÿã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯ä¸å—ç³»ç»Ÿæ—¶é—´è°ƒæ•´æˆ–å˜åŒ–çš„å½±å“ï¼Œå³ä½¿åœ¨ç³»ç»Ÿä¼‘çœ æˆ–æ—¶é’Ÿè°ƒæ•´çš„æƒ…å†µä¸‹ï¼Œå®ƒä¹Ÿèƒ½ä¿æŒç¨³å®šã€‚åœ¨ C++ æ ‡å‡†åº“ä¸­ï¼Œ[`std::chrono::steady_clock`](https://zh.cppreference.com/w/cpp/chrono/steady_clock) å°±æ˜¯ä¸€ä¸ªç¨³å®šæ—¶é’Ÿã€‚å®ƒé€šå¸¸ç”¨äºæµ‹é‡æ—¶é—´é—´éš”å’Œæ€§èƒ½è®¡æ—¶ç­‰éœ€è¦é«˜ç²¾åº¦å’Œç¨³å®šæ€§çš„åœºæ™¯ã€‚å¯ä»¥é€šè¿‡ `is_steady` é™æ€å¸¸é‡åˆ¤æ–­å½“å‰æ—¶é’Ÿæ˜¯å¦æ˜¯ç¨³å®šæ—¶é’Ÿã€‚

  ç¨³å®šæ—¶é’Ÿçš„ä¸»è¦ä¼˜ç‚¹åœ¨äºï¼Œå®ƒå¯ä»¥æä¾›ç›¸å¯¹äºèµ·å§‹æ—¶é—´çš„ç¨³å®šçš„é€’å¢æ—¶é—´ï¼Œå› æ­¤é€‚ç”¨äºéœ€è¦ä¿æŒæ—¶é—´é¡ºåºå’Œä¸å—ç³»ç»Ÿæ—¶é—´å˜åŒ–å½±å“çš„åº”ç”¨åœºæ™¯ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œåƒ [`std::chrono::system_clock`](https://zh.cppreference.com/w/cpp/chrono/system_clock) è¿™æ ·çš„ç³»ç»Ÿæ—¶é’Ÿå¯èƒ½ä¼šå—åˆ°ç³»ç»Ÿæ—¶é—´è°ƒæ•´æˆ–å˜åŒ–çš„å½±å“ï¼Œå› æ­¤åœ¨æŸäº›æƒ…å†µä¸‹å¯èƒ½ä¸é€‚åˆå¯¹æ—¶é—´é—´éš”è¿›è¡Œç²¾ç¡®æµ‹é‡ã€‚

- è¡¥å……ï¼š

  ä¸ç®¡ä½¿ç”¨å“ªç§æ—¶é’Ÿè·å–æ—¶é—´ï¼ŒC++ éƒ½æä¾›äº†å‡½æ•°ï¼Œå¯ä»¥å°†æ—¶é—´ç‚¹è½¬æ¢ä¸º [**time_t**](https://zh.cppreference.com/w/cpp/chrono/c/time_t) ç±»å‹çš„å€¼ï¼š

  ```c++
  auto now = std::chrono::system_clock::now();
  time_t now_time = std::chrono::system_clock::to_time_t(now);
  std::cout << "Current time:\t" << std::put_time(std::localtime(&now_time), "%H:%M:%S\n");
  
  auto now2 = std::chrono::steady_clock::now();
  now_time = std::chrono::system_clock::to_time_t(now);
  std::cout << "Current time:\t" << std::put_time(std::localtime(&now_time), "%H:%M:%S\n");
  ```

  C++ çš„æ—¶é—´åº“æå…¶ç¹æ‚ï¼Œä¸»è¦åœ¨äºç±»å‹ä¹‹å¤šï¼Œä»¥åŠå®ç°ä¹‹å¤æ‚ã€‚æ ¹æ®æˆ‘ä»¬çš„æè¿°ï¼Œäº†è§£åŸºæœ¬æ„æˆã€æ¦‚å¿µã€ä½¿ç”¨ï¼Œå³å¯ï¼ˆä½†æ˜¯`duation<>`å’Œ`ratio<>`è¿˜æ˜¯å¾ˆé‡è¦çš„ï¼‰ã€‚

### æ—¶é—´æ®µ

> - é€šå¸¸ä½¿ç”¨`duration<>`å¤„ç†æ—¶é—´æ®µ
> - å¦‚æœä½¿ç”¨`chrono`åº“ä¸­çš„æ—¶é—´ç±»å‹ï¼Œéœ€è¦æ³¨æ„**æ•°æ®æˆªæ–­**çš„é—®é¢˜ï¼ˆå› ä¸ºåº“ä¸­çš„æ—¶é—´ç±»å‹éƒ½æ˜¯æ•´å½¢ï¼‰ã€‚
> - æ—¶é—´æ®µä¸€èˆ¬æ­é…ç€`wait_for()`æ¥ä½¿ç”¨

- ç®€ä»‹ï¼š

  æ—¶é—´éƒ¨åˆ†æœ€ç®€å•çš„å°±æ˜¯æ—¶é—´æ®µï¼Œä¸»è¦çš„å†…å®¹å°±æ˜¯æˆ‘ä»¬ä¸Šé¢è®²çš„ç±»æ¨¡æ¿ `std::chrono::duration<class _Rep, class _Period>` ï¼Œå®ƒç”¨äºå¯¹æ—¶é—´æ®µè¿›è¡Œå¤„ç†ã€‚

  å®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»å‹è¡¨ç¤ºï¼Œç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯å…ˆå‰æåˆ°çš„â€œèŠ‚æ‹â€ï¼Œéœ€è¦ä¼ é€’ä¸€ä¸ª `std::ratio` ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªæ—¶é’Ÿæ‰€ç”¨çš„ç§’æ•°ã€‚

  æ ‡å‡†åº“åœ¨ `std::chrono` å‘½åç©ºé—´å†…ä¸ºæ—¶é—´æ®µæä¾›äº†ä¸€ç³»åˆ—çš„ç±»å‹ï¼Œå®ƒä»¬éƒ½æ˜¯é€šè¿‡ `std::chrono::duration` å®šä¹‰çš„[åˆ«å](https://github.com/microsoft/STL/blob/daeb0a6/stl/inc/__msvc_chrono.hpp#L508-L519)ï¼š

  ```c++
  using nanoseconds  = duration<long long, nano>;
  using microseconds = duration<long long, micro>;
  using milliseconds = duration<long long, milli>;
  using seconds      = duration<long long>;
  using minutes      = duration<int, ratio<60>>;
  using hours        = duration<int, ratio<3600>>;
  // CXX20
  using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
  using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
  using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
  using months = duration<int, ratio_divide<years::period, ratio<12>>>;
  ```

  å¦‚æœæ²¡æœ‰æŒ‡æ˜ `duration` çš„ç¬¬äºŒä¸ªéç±»å‹æ¨¡æ¿å‚æ•°ï¼Œé‚£ä¹ˆä»£è¡¨é»˜è®¤ `std::ratio<1>`ï¼Œæ¯”å¦‚ `seconds` ä¹Ÿå°±æ˜¯ä¸€ç§’ã€‚

  å¦‚ä¸Šï¼Œæ˜¯ MSVC STL å®šä¹‰çš„ï¼Œçœ‹ä¼¼æœ‰ä¸€äº›æ²¡æœ‰ä½¿ç”¨ `ratio` ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œå…¶å®ä¹Ÿè¿˜æ˜¯åˆ«åç½¢äº†ï¼Œ[è§](https://github.com/microsoft/STL/blob/daeb0a6/stl/inc/ratio#L262-L277)ï¼š

  ```c++
  using milli = ratio<1, 1000>; // åƒåˆ†ä¹‹ä¸€ç§’ï¼Œä¹Ÿå°±æ˜¯ä¸€æ¯«ç§’äº†
  ```

- C++14ä¸­çš„æ—¶é—´å­—é¢é‡

  ```c++
  using namespace std::chrono_literals;
  
  auto one_nanosecond = 1ns;
  auto one_microsecond = 1us;
  auto one_millisecond = 1ms;
  auto one_second = 1s;
  auto one_minute = 1min;
  auto one_hour = 1h;
  ```

  è§£é‡Šï¼š

  - æ—¶é—´å­—é¢é‡çš„å‡½æ•°**è‡ªå¸¦æ— ç¬¦å·æ•´å‹å’Œæµ®ç‚¹çš„ä¸¤ç§ç±»å‹é‡è½½**ï¼Œå¦‚ä¸‹ï¼š

    ```c++
    constexpr _CHRONO milliseconds operator""ms(unsigned long long _Val) noexcept
    {
        return _CHRONO milliseconds(_Val);
    }
    constexpr _CHRONO duration<double, milli> operator""ms(long double _Val) noexcept
    {
        return _CHRONO duration<double, milli>(_Val);
    }
    ```

- **ä½¿ç”¨`chrono::duration_cast<>`æ—¶çš„æ•°æ®æˆªæ–­**

  å½“ä¸è¦æ±‚æˆªæ–­å€¼çš„æƒ…å†µä¸‹ï¼ˆæ—¶è½¬æ¢ä¸ºç§’æ—¶æ²¡é—®é¢˜çš„ï¼Œä½†åè¿‡æ¥ä¸è¡Œï¼‰æ—¶é—´æ®µæœ‰éšå¼è½¬æ¢ï¼Œæ˜¾å¼è½¬æ¢å¯ä»¥ç”± [`std::chrono::duration_cast<>`](https://zh.cppreference.com/w/cpp/chrono/duration/duration_cast) æ¥å®Œæˆã€‚

  ```c++
  std::chrono::milliseconds ms{ 3999 };
  std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(ms);
  std::cout << s.count() << '\n';
  ```

  è§£é‡Šï¼š

  - è¿™é‡Œçš„ç»“æœæ˜¯**æˆªæ–­**çš„ï¼Œè€Œä¸ä¼šè¿›è¡Œæ‰€è°“çš„å››èˆäº”å…¥ï¼Œ`3999` æ¯«ç§’ï¼Œä¹Ÿå°±æ˜¯ `3.999` ç§’æœ€ç»ˆçš„å€¼æ˜¯ `3`ã€‚
  - è¿™æ˜¯å› ä¸ºseconds æ˜¯ `duration<long long>` è¿™æ„å‘³ç€å®ƒæ— æ³•æ¥å—æµ®ç‚¹æ•°ã€‚

  è§£å†³åŠæ³•ï¼š

  ä½¿ç”¨ `duration<double>` å³å¯ï¼š

  ```c++
  std::chrono::duration<double> s = std::chrono::duration_cast<std::chrono::duration<double>>(ms);
  ```

  æˆ–è€…ä½¿ç”¨éšå¼è½¬æ¢ï¼š

  ```c++
  std::chrono::duration<double, ratio<1>> s = ms;
  ```

- æ—¶é—´æ®µçš„å››åˆ™è¿ç®—ï¼Œ`count()`

  æ—¶é—´åº“æ”¯æŒå››åˆ™è¿ç®—ï¼Œå¯ä»¥å¯¹ä¸¤ä¸ªæ—¶é—´æ®µè¿›è¡ŒåŠ å‡ä¹˜é™¤ã€‚æ—¶é—´æ®µå¯¹è±¡å¯ä»¥é€šè¿‡ [`count()`](https://zh.cppreference.com/w/cpp/chrono/duration/count) æˆå‘˜å‡½æ•°è·å¾—è®¡æ¬¡æ•°ã€‚ä¾‹å¦‚ `std::chrono::milliseconds{123}.count()` çš„ç»“æœå°±æ˜¯ 123ã€‚

- æ—¶é—´æ®µçš„åº”ç”¨ï¼š

  åŸºäºæ—¶é—´æ®µçš„ç­‰å¾…éƒ½æ˜¯ç”± `std::chrono::duration<>` æ¥å®Œæˆã€‚ä¾‹å¦‚ï¼šç­‰å¾…ä¸€ä¸ª future å¯¹è±¡åœ¨ 35 æ¯«ç§’å†…å˜ä¸ºå°±ç»ªçŠ¶æ€ï¼š

  ```c++
  std::future<int> future = std::async([] {return 6; });
  if (future.wait_for(35ms) == std::future_status::ready)
      std::cout << future.get() << '\n';
  ```

  [`wait_for`](https://zh.cppreference.com/w/cpp/thread/future/wait_for)ï¼š ç­‰*å¾…ç»“æœï¼Œå¦‚æœåœ¨æŒ‡å®šçš„è¶…æ—¶é—´éš”åä»ç„¶æ— æ³•å¾—åˆ°ç»“æœï¼Œåˆ™è¿”å›*ã€‚å®ƒçš„è¿”å›ç±»å‹æ˜¯ä¸€ä¸ªæšä¸¾ç±» [`std::future_status`](https://zh.cppreference.com/w/cpp/thread/future_status) ï¼Œä¸‰ä¸ªæšä¸¾é¡¹åˆ†åˆ«è¡¨ç¤ºä¸‰ç§ future çŠ¶æ€ã€‚

  | `deferred` | å…±äº«çŠ¶æ€æŒæœ‰çš„å‡½æ•°æ­£åœ¨å»¶è¿Ÿè¿è¡Œï¼Œç»“æœå°†ä»…åœ¨æ˜ç¡®è¯·æ±‚æ—¶è®¡ç®— |
  | ---------- | -------------------------------------------------------- |
  | `ready`    | **å…±äº«çŠ¶æ€å°±ç»ª**                                         |
  | `timeout`  | **å…±äº«çŠ¶æ€åœ¨ç»è¿‡æŒ‡å®šçš„ç­‰å¾…æ—¶é—´å†…ä»æœªå°±ç»ª**               |

  `timeout` è¶…æ—¶ï¼Œä¹Ÿå¾ˆå¥½ç†è§£ï¼Œé‚£æˆ‘ä»¬å°±æä¸€ä¸‹ `deferred` ï¼š

  ```c++
  auto future = std::async(std::launch::deferred, []{});
  if (future.wait_for(35ms) == std::future_status::deferred)
      std::cout << "future_status::deferred " << "æ­£åœ¨å»¶è¿Ÿæ‰§è¡Œ\n";
  future.wait(); // åœ¨ wait() æˆ– get() è°ƒç”¨æ—¶æ‰§è¡Œï¼Œä¸åˆ›å»ºçº¿ç¨‹
  ```

### æ—¶é—´ç‚¹

> - ä½¿ç”¨æ—¶é—´ç‚¹/æ—¶é—´æ®µæ—¶ï¼Œwindowsä¸‹é»˜è®¤ç²¾åº¦ä¸º 15.6 æ¯«ç§’ï¼Œå¦‚æœæƒ³è¦çœŸæ­£1msçš„ç²¾åº¦ï¼Œéœ€è¦ä½¿ç”¨**`winmm.lib`**

- å‰è¨€ï¼š

  æ—¶é—´ç‚¹å¯ç”¨ [`std::chrono::time_point<>`](https://zh.cppreference.com/w/cpp/chrono/time_point) æ¥è¡¨ç¤ºï¼Œç¬¬ä¸€ä¸ªæ¨¡æ¿å‚æ•°ç”¨æ¥æŒ‡å®šä½¿ç”¨çš„æ—¶é’Ÿï¼Œç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°ç”¨æ¥è¡¨ç¤ºæ—¶é—´å•ä½ï¼ˆ`std::chrono::duration<>`ï¼‰ã€‚æ—¶é—´ç‚¹é¡¾åæ€ä¹‰å°±æ˜¯æ—¶é—´ä¸­çš„ä¸€ä¸ªç‚¹ï¼Œåœ¨ C++ ä¸­ç”¨äºè¡¨è¾¾å½“å‰æ—¶é—´ï¼Œå…ˆå‰æåˆ°çš„é™æ€æˆå‘˜å‡½æ•° `now()` è·å–å½“å‰æ—¶é—´ï¼Œå®ƒä»¬çš„è¿”å›ç±»å‹éƒ½æ˜¯ `std::chrono::time_point`ã€‚

  ```c++
  template<
      class Clock,
      class Duration = typename Clock::duration
  > class time_point;
  ```

  å¦‚ä½ æ‰€è§ï¼Œå®ƒçš„ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°æ˜¯**æ—¶é—´æ®µ**ï¼Œå°±æ˜¯æ—¶é—´çš„é—´éš”ï¼Œå…¶å®ä¹Ÿå°±å¯ä»¥ç†è§£ä¸ºè¡¨ç¤ºæ—¶é—´ç‚¹çš„**ç²¾åº¦**ï¼Œé»˜è®¤æ˜¯æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°æ—¶é’Ÿå¾—åˆ°çš„ï¼Œæ‰€ä»¥å‡è®¾æœ‰ç±»å‹ï¼š

  ```c++
  std::chrono::time_point<std::chrono::system_clock>
  ```

  é‚£å®ƒç­‰ä»·äºï¼š

  ```c++
  std::chrono::time_point<std::chrono::system_clock, std::chrono::system_clock::duration>
  ```

  ä¹Ÿå°±æ˜¯è¯´ç¬¬äºŒä¸ªå‚æ•°çš„å®é™…ç±»å‹æ˜¯ï¼š

  ```c++
  std::chrono::duration<long long, std::ratio<1, 10000000>> //  // 100 nanoseconds
  ```

  ä¹Ÿå°±æ˜¯è¯´ `std::chrono::time_point<std::chrono::system_clock>` çš„ç²¾åº¦æ˜¯ 100 çº³ç§’ã€‚

  > æ³¨æ„ï¼Œè¿™é‡Œçš„ç²¾åº¦å¹¶éæ˜¯å®é™…çš„æ—¶é—´ç²¾åº¦ã€‚æ—¶é—´å’Œç¡¬ä»¶ç³»ç»Ÿç­‰å…³ç³»æå¤§ï¼Œä»¥ windows ä¸ºä¾‹ï¼š
  >
  > Windows å†…æ ¸ä¸­çš„æ—¶é—´é—´éš”è®¡æ—¶å™¨é»˜è®¤æ¯éš” **15.6** æ¯«ç§’è§¦å‘ä¸€æ¬¡ä¸­æ–­ã€‚å› æ­¤ï¼Œå¦‚æœä½ ä½¿ç”¨åŸºäºç³»ç»Ÿæ—¶é’Ÿçš„è®¡æ—¶æ–¹æ³•ï¼Œé»˜è®¤æƒ…å†µä¸‹ç²¾åº¦çº¦ä¸º 15.6 æ¯«ç§’ã€‚ä¸å¯èƒ½è¾¾åˆ°çº³ç§’çº§åˆ«ã€‚
  >
  > ç”±äºè¿™ä¸ªç³»ç»Ÿæ—¶é’Ÿçš„é™åˆ¶ï¼Œé‚£äº›åŸºäºç³»ç»Ÿæ—¶é’Ÿçš„ APIï¼ˆä¾‹å¦‚ `Sleep()`ã€`WaitForSingleObject()` ç­‰ï¼‰çš„æœ€å°ç¡çœ æ—¶é—´é»˜è®¤å°±æ˜¯ 15.6 æ¯«ç§’å·¦å³ã€‚
  >
  > å¦‚ï¼š
  >
  > ```c++
  > std::this_thread::sleep_for(std::chrono::milliseconds(1));
  > ```

- windowsä¸‹çš„ç²¾åº¦ç¼ºé™·

  ä½¿ç”¨ç³»ç»Ÿ API è°ƒæ•´ç³»ç»Ÿæ—¶é’Ÿçš„ç²¾åº¦ï¼Œéœ€è¦é“¾æ¥ windows å¤šåª’ä½“åº“ **`winmm.lib`** ï¼Œç„¶åä½¿ç”¨ APIï¼š

  ```c++
  #include <windows.h>
  #pragma comment(lib, "winmm.lib")
  
  using namespace std;
  
  int main() {
  	timeBeginPeriod(1);	// è®¾ç½®æ—¶é’Ÿç²¾åº¦ä¸º 1 æ¯«ç§’
  
  	auto start = std::chrono::high_resolution_clock::now();
  	this_thread::sleep_for(1ms);
  	auto end = std::chrono::high_resolution_clock::now();
  	std::chrono::duration<double, ratio<1, 1000>> duration = end - start;
  	std::cout << "æ‰€è€—æ—¶é—´ä¸ºï¼š" << duration.count() << "ms" << std::endl;
  
  	timeEndPeriod(1);	// æ¢å¤é»˜è®¤ç²¾åº¦
  }
  ```

  è§£é‡Šï¼š

  - `timeBeginPeriod()`å’Œ`timeEndPeriod()`å¿…é¡»æˆå¯¹ä½¿ç”¨
  - åœ¨è¢«åŒ…å›´çš„èŒƒå›´å†…ï¼Œç²¾åº¦è¢«è®¾ä¸º1msï¼Œä¸è¿‡è¿™ä¹Ÿæ„å‘³ç€ç°åœ¨ç³»ç»Ÿæ¯éš”1mså°±è¦æ£€æŸ¥éœ€è¦å¤„ç†çš„ä»»åŠ¡ï¼Œå¼€é”€æˆå‡ ä½•å¢é•¿

- æ—¶é—´ç‚¹çš„å››åˆ™è¿ç®—ï¼š

  åŒæ ·çš„ï¼Œæ—¶é—´ç‚¹ä¹Ÿæ”¯æŒåŠ å‡ä»¥åŠæ¯”è¾ƒæ“ä½œã€‚

  ```c++
  std::chrono::steady_clock::now() + std::chrono::nanoseconds(500); // 500 çº³ç§’ä¹‹åçš„æ—¶é—´
  ```

  å¯ä»¥å‡å»ä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œç»“æœæ˜¯ä¸¤ä¸ªæ—¶é—´ç‚¹çš„æ—¶é—´å·®ã€‚è¿™å¯¹äºä»£ç å—çš„è®¡æ—¶æ˜¯å¾ˆæœ‰ç”¨çš„ï¼Œå¦‚ï¼š

  ```c++
  auto start = std::chrono::steady_clock::now();
  std::this_thread::sleep_for(std::chrono::seconds(1));
  auto end = std::chrono::steady_clock::now();
  
  auto result = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
  std::cout << result.count() << '\n';
  ```

  > [è¿è¡Œ](https://godbolt.org/z/ExdnzKoYj)æµ‹è¯•ã€‚

  æˆ‘ä»¬è¿›è¡Œäº†ä¸€ä¸ªæ˜¾å¼çš„è½¬æ¢ï¼Œæœ€ç»ˆè¾“å‡ºçš„æ˜¯ä»¥æ¯«ç§’ä½œä¸ºå•ä½ï¼Œæœ‰å¯èƒ½ä¸ä¼šæ˜¯ 1000ï¼Œæ²¡æœ‰è¿™ä¹ˆç²¾ç¡®ã€‚

- ç­‰å¾…æ¡ä»¶å˜é‡æ»¡è¶³æ¡ä»¶â€”â€”å¸¦è¶…æ—¶åŠŸèƒ½ï¼ˆfutureä¹Ÿæœ‰ç±»ä¼¼çš„åŠŸèƒ½ï¼‰

  ```c++
  std::condition_variable cv;
  bool done{};
  std::mutex m;
  
  bool wait_loop() {
      const auto timeout = std::chrono::steady_clock::now() + 500ms;
      std::unique_lock<std::mutex> lk{ m };
      while (!done) {
          // çº¿ç¨‹åœ¨wait_untilä¸­ä¸æ–­å¾ªç¯æ¯”è¾ƒå½“å‰æ—¶é—´æ˜¯å¦è¶…æ—¶ä»¥åŠè¯¥çº¿ç¨‹æ˜¯å¦è¢«å”¤é†’ï¼ˆåŒ…æ‹¬è™šå‡å”¤é†’ï¼‰
          // è¶…æ—¶è¿”å›timeoutï¼Œå”¤é†’ï¼ˆåŒ…æ‹¬è™šå‡å”¤é†’ï¼‰è¿”å›no_timeout
          if (cv.wait_until(lk, timeout) == std::cv_status::timeout){
              std::cout << "è¶…æ—¶ 500ms\n";
          }
      }
      cout << done << endl;
      return true;
  }
  
  int main() {
      thread t{wait_loop};
      cv.notify_one();
      this_thread::sleep_for(800ms);
      done = true;
  
      t.join();
  }
  ```

  è§£é‡Šï¼š

  - `wait_until()`è¶…æ—¶è¿”å›timeoutï¼Œå”¤é†’ï¼ˆåŒ…æ‹¬è™šå‡å”¤é†’ï¼‰è¿”å›no_timeout

  - è¿™é‡Œçš„é€»è¾‘å’Œæ¡ä»¶å˜é‡ä¸­çš„`wait()`å¾ˆç›¸ä¼¼ï¼Œéƒ½æ˜¯è°ƒç”¨æ—¶ä¼šè§£é”ï¼Œè¿›å…¥é˜»å¡ï¼Œè¢«å”¤é†’æ—¶ï¼ˆåŒ…æ‹¬è™šå‡å”¤é†’ï¼‰ä¼šä¸Šé”ï¼Œå¹¶è¿”å›ä¸€ä¸ªæˆåŠŸçŠ¶æ€ï¼Œæ‰€ä»¥ä¸ºäº†é¿å…è™šå‡å”¤é†’çš„å½±å“ï¼Œå¤–å›´éœ€è¦åŠ ä¸€ä¸ª`while`å¾ªç¯ã€‚åªä¸è¿‡`wait_until()`å¤šäº†ä¸ªè®¡æ—¶åŠŸèƒ½ã€‚

## å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ

[å°±æ˜¯ä¸ªqtè€Œå·²ï¼Œå¯ä»¥çœ‹çœ‹é‡Œé¢çš„`QMetaObject::invokeMethod`æ–¹æ³•](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œ)

## C++20ä¿¡å·é‡

[ï¼ï¼ï¼çœ‹å®Œæœ¬èŠ‚åçœ‹è¿™é‡Œï¼šC++20ä¿¡å·é‡](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#c-20-ä¿¡å·é‡)

> - ä¿¡å·é‡å’Œæ¡ä»¶å˜é‡å·®ä¸å¤šï¼Œéƒ½å¯ä»¥æ§åˆ¶çº¿ç¨‹çš„æ‰§è¡Œé¡ºåº

- å®šä¹‰ï¼š

  ä¿¡å·é‡æ˜¯ä¸€ä¸ªéå¸¸**è½»é‡ç®€å•**çš„åŒæ­¥è®¾æ–½ï¼Œå®ƒç»´æŠ¤ä¸€ä¸ªè®¡æ•°ï¼Œè¿™ä¸ªè®¡æ•°ä¸èƒ½å°äº `0`ã€‚ä¿¡å·é‡æä¾›ä¸¤ç§åŸºæœ¬æ“ä½œï¼š**é‡Šæ”¾**ï¼ˆå¢åŠ è®¡æ•°ï¼‰å’Œ**ç­‰å¾…**ï¼ˆå‡å°‘è®¡æ•°ï¼‰ã€‚å¦‚æœå½“å‰ä¿¡å·é‡çš„è®¡æ•°å€¼ä¸º `0`ï¼Œé‚£ä¹ˆæ‰§è¡Œâ€œ***ç­‰å¾…***â€æ“ä½œçš„çº¿ç¨‹å°†ä¼š**ä¸€ç›´é˜»å¡**ï¼Œç›´åˆ°è®¡æ•°å¤§äº `0`ï¼Œä¹Ÿå°±æ˜¯å…¶å®ƒçº¿ç¨‹æ‰§è¡Œäº†â€œ***é‡Šæ”¾***â€æ“ä½œã€‚

  C++ æä¾›äº†ä¸¤ä¸ªä¿¡å·é‡ç±»å‹ï¼š`std::counting_semaphore` ä¸ `std::binary_semaphore`ï¼Œå®šä¹‰åœ¨ [``](https://zh.cppreference.com/w/cpp/header/semaphore) ä¸­ã€‚

  `binary_semaphore`[[3\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#footnote3) åªæ˜¯ `counting_semaphore` çš„ä¸€ä¸ªç‰¹åŒ–åˆ«åï¼š

  ```c++
  using binary_semaphore = counting_semaphore<1>;
  ```

- ç®€å•ç¤ºä¾‹ï¼š

  ```c++
  binary_semaphore semaphore{0};
  
  void task() {
      cout << "çº¿ç¨‹è¿›å…¥å‡½æ•°..." << endl;
      semaphore.acquire(); // å‡å°‘è®¡æ•°ï¼Œæ­¤æ—¶ä¿¡å·é‡è®¡æ•°ä¸º0ï¼Œé˜»å¡åœ¨æ­¤å¤„
      cout << "çº¿ç¨‹è¢«å”¤é†’ï¼Œè§£é™¤é˜»å¡" << endl;
  }
  
  int main() {
      thread t{task};
      this_thread::sleep_for(5s);
      semaphore.release();
      t.join();
  }
  ```

## C++20é—©ä¸å±éšœ

é—© (latch) ä¸å±éšœ (barrier) æ˜¯çº¿ç¨‹åè°ƒæœºåˆ¶ï¼Œå…è®¸ä»»ä½•æ•°é‡çš„çº¿ç¨‹é˜»å¡**ç›´è‡³æœŸå¾…æ•°é‡çš„çº¿ç¨‹åˆ°è¾¾**ã€‚é—©ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œè€Œå±éšœåˆ™å¯ä»¥ã€‚

- **`std::latch`ï¼šå•æ¬¡ä½¿ç”¨çš„çº¿ç¨‹å±éšœ**
- **`std::barrier`ï¼šå¯å¤ç”¨çš„çº¿ç¨‹å±éšœ**

å®ƒä»¬å®šä¹‰åœ¨æ ‡å¤´ **`<latch>`** ä¸ **`<barrier>`**ã€‚

ä¸ä¿¡å·é‡ç±»ä¼¼ï¼Œå±éšœä¹Ÿæ˜¯ä¸€ç§å¤è€è€Œå¹¿æ³›åº”ç”¨çš„åŒæ­¥æœºåˆ¶ã€‚è®¸å¤šç³»ç»Ÿ API æä¾›äº†å¯¹å±éšœæœºåˆ¶çš„æ”¯æŒï¼Œä¾‹å¦‚ POSIX å’Œ Win32ã€‚æ­¤å¤–ï¼Œ[OpenMP](https://learn.microsoft.com/zh-cn/cpp/parallel/openmp/2-directives?view=msvc-170#263-barrier-directive) ä¹Ÿæä¾›äº†å±éšœæœºåˆ¶æ¥æ”¯æŒå¤šçº¿ç¨‹ç¼–ç¨‹ã€‚

### `std::latch`

- å®šä¹‰ï¼š

  â€œ*é—©*â€ ï¼Œä¸­æ–‡è¯­å¢ƒä¸€èˆ¬è¯´â€œ*é—¨é—©*â€ æ˜¯æŒ‡é—¨èƒŒåç”¨æ¥å…³é—¨çš„æ£å­ã€‚ä¸è¿‡ä¸ç”¨åœ¨æ„ï¼Œåœ¨ C++ ä¸­çš„æ„æ€å°±æ˜¯å…ˆå‰è¯´çš„ï¼š***å•æ¬¡ä½¿ç”¨çš„çº¿ç¨‹å±éšœ***ã€‚

  `latch` ç±»ç»´æŠ¤ç€ä¸€ä¸ª [`std::ptrdiff_t`](https://zh.cppreference.com/w/cpp/types/ptrdiff_t) ç±»å‹çš„è®¡æ•°[[5\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#footnote5)ï¼Œä¸”åªèƒ½**å‡å°‘**è®¡æ•°ï¼Œ**æ— æ³•å¢åŠ è®¡æ•°**ã€‚åœ¨åˆ›å»ºå¯¹è±¡çš„æ—¶å€™åˆå§‹åŒ–è®¡æ•°å™¨çš„å€¼ã€‚çº¿ç¨‹å¯ä»¥é˜»å¡ï¼Œç›´åˆ° latch å¯¹è±¡çš„è®¡æ•°å‡å°‘åˆ°é›¶ã€‚ç”±äºæ— æ³•å¢åŠ è®¡æ•°ï¼Œè¿™ä½¿å¾— `latch` æˆä¸ºä¸€ç§**å•æ¬¡ä½¿ç”¨çš„å±éšœ**ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  std::latch work_start{ 3 };
  
  void work(){
      std::cout << "ç­‰å¾…å…¶å®ƒçº¿ç¨‹æ‰§è¡Œ\n";
      work_start.wait(); // ç­‰å¾…è®¡æ•°ä¸º 0
      std::cout << "ä»»åŠ¡å¼€å§‹æ‰§è¡Œ\n";
  }
  
  int main(){
      std::jthread thread{ work };
      std::this_thread::sleep_for(3s);
      std::cout << "ä¼‘çœ ç»“æŸ\n";
      work_start.count_down();  // é»˜è®¤å€¼æ˜¯ 1 å‡å°‘è®¡æ•° 1
      work_start.count_down(2); // ä¼ é€’å‚æ•° 2 å‡å°‘è®¡æ•° 2
  }
  // ç­‰å¾…å…¶å®ƒçº¿ç¨‹æ‰§è¡Œ
  // ä¼‘çœ ç»“æŸ
  // ä»»åŠ¡å¼€å§‹æ‰§è¡Œ
  ```

  è§£é‡Šï¼š

  - åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œé€šè¿‡è°ƒç”¨ `wait` å‡½æ•°é˜»å¡å­çº¿ç¨‹ï¼Œç›´åˆ°ä¸»çº¿ç¨‹è°ƒç”¨ `count_down` å‡½æ•°åŸå­åœ°å°†è®¡æ•°å‡è‡³ `0`ï¼Œä»è€Œè§£é™¤é˜»å¡ã€‚è¿™ä¸ªä¾‹å­æ¸…æ¥šåœ°å±•ç¤ºäº† `latch` çš„ä½¿ç”¨ï¼Œå…¶é€»è¾‘æ¯”ä¿¡å·é‡æ›´ç®€å•ã€‚

- åº”ç”¨ï¼š

  - ç”±äº `latch` çš„è®¡æ•°ä¸å¯å¢åŠ ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ¥åˆ’åˆ†ä»»åŠ¡æ‰§è¡Œçš„å·¥ä½œåŒºé—´ã€‚

    ```c++
    std::latch latch{ 10 };
    
    void f(int id) {
        //todo.. è„‘è¡¥ä»»åŠ¡
        std::this_thread::sleep_for(1s);
        std::cout << std::format("çº¿ç¨‹ {} æ‰§è¡Œå®Œä»»åŠ¡ï¼Œå¼€å§‹ç­‰å¾…å…¶å®ƒçº¿ç¨‹æ‰§è¡Œåˆ°æ­¤å¤„\n", id);
        latch.arrive_and_wait();
        std::cout << std::format("çº¿ç¨‹ {} å½»åº•é€€å‡ºå‡½æ•°\n", id);
    }
    
    int main() {
        std::vector<std::jthread> threads;
        for (int i = 0; i < 10; ++i) {
            threads.emplace_back(f,i);
        }
    }
    ```

    è§£é‡Šï¼š

    - [`arrive_and_wait`](https://zh.cppreference.com/w/cpp/thread/latch/arrive_and_wait) å‡½æ•°ç­‰ä»·äºï¼š`count_down(n); wait();`ã€‚ä¹Ÿå°±æ˜¯å‡å°‘è®¡æ•° + ç­‰å¾…ã€‚è¿™æ„å‘³ç€

      å¿…é¡»ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œåˆ° `latch.arrive_and_wait();` å°† latch çš„è®¡æ•°å‡å°‘è‡³ `0` æ‰èƒ½ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚è¿™ä¸ªç¤ºä¾‹éå¸¸ç›´è§‚åœ°å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `latch` æ¥åˆ’åˆ†ä»»åŠ¡æ‰§è¡Œçš„å·¥ä½œåŒºé—´ã€‚

    - ç”±äº `latch` çš„åŠŸèƒ½å—é™ï¼Œé€šå¸¸ç”¨äºç®€å•ç›´æ¥çš„éœ€æ±‚ï¼Œä¸å°‘æƒ…å†µå¾ˆå¤šåŒæ­¥è®¾æ–½éƒ½èƒ½å®Œæˆä½ çš„éœ€æ±‚ï¼Œåœ¨è¿™ä¸ªæ—¶å€™è¯·è€ƒè™‘**ä½¿ç”¨å°½å¯èƒ½åŠŸèƒ½æœ€å°‘çš„é‚£ä¸€ä¸ª**ã€‚

### `std::barrier`

[çœ‹çœ‹è¿™é‡Œå°±å¥½äº†](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/04åŒæ­¥æ“ä½œ.html#std-barrier)

> `barrier`å’Œ`latch`å¾ˆåƒï¼Œåªæ˜¯è¯´ï¼Œ`barrier`åœ¨è®¡æ•°æ¸…0çš„æ—¶å€™ï¼Œä¼šå°†è®¡æ•°é‡ç½®ã€‚

## æ€»ç»“-å‹˜è¯¯åˆå§‹åŒ–é¡ºåº



[åˆå§‹åŒ–é¡ºåºé—®é¢˜ï¼Œå€¼å¾—ä¸€çœ‹](https://github.com/Mq-b/ModernCpp-ConcurrentProgramming-Tutorial/issues/27)

# å†…å­˜æ¨¡å‹ä¸åŸå­æ“ä½œ

- å†…å­˜æ¨¡å‹å®šä¹‰äº†å¤šçº¿ç¨‹ç¨‹åºä¸­ï¼Œè¯»å†™æ“ä½œå¦‚ä½•åœ¨ä¸åŒçº¿ç¨‹ä¹‹é—´å¯è§ï¼Œä»¥åŠè¿™äº›æ“ä½œåœ¨ä½•ç§é¡ºåºä¸‹æ‰§è¡Œã€‚å†…å­˜æ¨¡å‹ç¡®ä¿ç¨‹åºçš„è¡Œä¸ºåœ¨å¹¶å‘ç¯å¢ƒä¸‹æ˜¯å¯é¢„æµ‹çš„ã€‚
- åŸå­æ“ä½œå³**ä¸å¯åˆ†å‰²çš„æ“ä½œ**ã€‚ç³»ç»Ÿçš„æ‰€æœ‰çº¿ç¨‹ï¼Œä¸å¯èƒ½è§‚å¯Ÿåˆ°åŸå­æ“ä½œå®Œæˆäº†ä¸€åŠã€‚

æœ€åŸºç¡€çš„æ¦‚å¿µå°±æ˜¯å¦‚æ­¤ï¼Œè¿™é‡Œä¸å†è¿‡å¤šèµ˜è¿°ï¼Œåç»­è¿˜ä¼šè¯¦ç»†å±•å¼€å†…å­˜æ¨¡å‹çš„é—®é¢˜ã€‚

## åŸå­æ“ä½œ

> - æ³¨æ„ï¼Œç°ä»£cpuå¾ˆå¤æ‚ï¼Œç»å¯¹ä¸è¦ä»ä»€ä¹ˆæ±‡ç¼–çš„è§’åº¦å»åˆ¤æ–­æ˜¯å¦æ˜¯åŸå­æ“ä½œï¼Œæ¯”å¦‚ä¸‹é¢çš„è¿™ä¸ª`++a`ï¼Œæ±‡ç¼–æŒ‡ä»¤çœ‹ç€å¥½åƒæ²¡é—®é¢˜ï¼Œä½†å…¶å®å¤šçº¿ç¨‹ä¸‹å°±æ˜¯æœ‰æ•°æ®ç«äº‰ï¼Œå°¤å…¶æ˜¯åœ¨releaseæ¨¡å¼ä¸‹ã€‚

```c++
int a = 0;
void f(){
    ++a;
}
```

æ˜¾ç„¶ï¼Œ`++a` æ˜¯éåŸå­æ“ä½œï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨å¤šçº¿ç¨‹ä¸­å¯èƒ½ä¼šè¢«å¦ä¸€ä¸ªçº¿ç¨‹è§‚å¯Ÿåˆ°åªå®Œæˆä¸€åŠã€‚

1. çº¿ç¨‹ A å’Œçº¿ç¨‹ B åŒæ—¶å¼€å§‹ä¿®æ”¹å˜é‡ `a` çš„å€¼ã€‚
2. çº¿ç¨‹ A å¯¹ `a` æ‰§è¡Œé€’å¢æ“ä½œï¼Œä½†è¿˜æœªå®Œæˆã€‚
3. åœ¨çº¿ç¨‹ A å®Œæˆé€’å¢æ“ä½œä¹‹å‰ï¼Œçº¿ç¨‹ B ä¹Ÿæ‰§è¡Œäº†é€’å¢æ“ä½œã€‚
4. çº¿ç¨‹ C è¯»å– `a` çš„å€¼ã€‚

çº¿ç¨‹ C åˆ°åº•è¯»å–åˆ°å¤šå°‘ä¸ç¡®å®šï¼Œa çš„å€¼æ˜¯å¤šå°‘ä¹Ÿä¸ç¡®å®šã€‚æ˜¾ç„¶ï¼Œè¿™æ„æˆäº†æ•°æ®ç«äº‰ï¼Œå‡ºç°äº†[æœªå®šä¹‰è¡Œä¸º](https://zh.cppreference.com/w/cpp/language/ub)ã€‚

åœ¨ä¹‹å‰çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬è®²è¿°äº†ä½¿ç”¨å¾ˆå¤šåŒæ­¥è®¾æ–½ï¼Œå¦‚äº’æ–¥é‡ï¼Œæ¥ä¿æŠ¤å…±äº«èµ„æºã€‚

```c++
std::mutex m;
void f() {
    std::lock_guard<std::mutex> lc{ m };
    ++a;
}
```

é€šè¿‡äº’æ–¥é‡çš„ä¿æŠ¤ï¼Œå³ä½¿ `++a` æœ¬èº«ä¸æ˜¯åŸå­æ“ä½œï¼Œ**é€»è¾‘ä¸Šä¹Ÿå¯è§†ä¸ºåŸå­æ“ä½œ**ã€‚äº’æ–¥é‡ç¡®ä¿äº†å¯¹å…±äº«èµ„æºçš„è¯»å†™æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé¿å…äº†æ•°æ®ç«äº‰é—®é¢˜ã€‚

ä¸è¿‡è¿™æ˜¾ç„¶ä¸æ˜¯æˆ‘ä»¬çš„é‡ç‚¹ã€‚æˆ‘ä»¬æƒ³è¦çš„æ˜¯ä¸€ç§**åŸå­ç±»å‹**ï¼Œå®ƒçš„æ‰€æœ‰æ“ä½œéƒ½ç›´æ¥æ˜¯**åŸå­**çš„ï¼Œä¸éœ€è¦é¢å¤–çš„åŒæ­¥è®¾æ–½è¿›è¡Œä¿æŠ¤ã€‚C++11 å¼•å…¥äº†åŸå­ç±»å‹ [`std::atomic`](https://zh.cppreference.com/w/cpp/atomic/atomic)ï¼Œåœ¨ä¸‹èŠ‚æˆ‘ä»¬ä¼šè¯¦ç»†è®²è§£ã€‚

- ++aä¸­çš„æ•°æ®ç«äº‰

  ```c++
  int n = 0;
  
  void read() {
      while (1) {
          this_thread::sleep_for(500ms);
          cout << n << endl;
      }
  }
  
  void write() {
      while (1) {
          ++n;
      }
  }
  
  int main() {
      thread t1{read};
      thread t2(write);
      t1.join();
      t2.join();
  }
  ```

  è§£é‡Šï¼š

  - è¯¥ä»£ç åœ¨debugæ¨¡å¼ä¸‹æ— é—®é¢˜ï¼Œä½†åœ¨releaseæ¨¡å¼ä¸‹åªä¼šè¾“å‡º0

  - **å› ä¸ºå¯¹açš„è¯»å†™æ“ä½œå±äºæ•°æ®ç«äº‰ï¼Œè€Œæ•°æ®ç«äº‰æ˜¯æœªå®šä¹‰è¡Œä¸ºï¼›**

    **è€Œç¼–è¯‘å™¨åœ¨releaseæ¨¡å¼ä¸‹è¿›è¡Œä¼˜åŒ–æ—¶ï¼Œä¼šå‡è®¾ç¨‹åºæ²¡æœ‰æœªå®šä¹‰è¡Œä¸ºï¼›**

    æ‰€ä»¥`read()`å‡½æ•°å¯ä»¥è¢«çœ‹åšä¼˜åŒ–ä¸ºï¼š

    ```c++
    void read() {
        while (1) {
            this_thread::sleep_for(500ms);
            int a = n;
            cout << a << endl;
        }
    }
    ```

    è§£é‡Šï¼š

    - ä¹Ÿå°±æ˜¯è¯´ç¼–è¯‘å™¨ä¼šå°†aæ”¾åœ¨cacheæˆ–å¯„å­˜å™¨ä¸­è¿›è¡Œå¤‡ä»½ï¼Œè§£å†³åŠæ³•æ˜¯ä½¿ç”¨ä¸‹èŠ‚æ‰€å­¦çš„åŸå­ç±»å‹

    - ä½ å¯èƒ½ä¼šæƒ³ä½¿ç”¨`volatile`å…³é”®å­—ï¼Œçœ‹ä¼¼åœ¨releaseæ¨¡å¼ä¸‹ç¡®å®å¯ä»¥ï¼Œä½†ä¸è¦è¿™ä¹ˆä½¿ç”¨ï¼ï¼ï¼ï¼

      **å› ä¸ºvolatileçš„è¡Œä¸ºæ˜¯ä¸ç¡®å®šçš„ï¼**

### åŸå­ç±»å‹-ubä¼˜åŒ–ä¸æ— é”

> - å¤šçº¿ç¨‹ä¸‹è¯»å†™åŸå­ç±»å‹çš„æ•°æ®æ˜¯ç»å¯¹çº¿ç¨‹å®‰å…¨çš„
> - å½“åŸå­ç±»å‹çš„æ“ä½œä½¿ç”¨åŸå­æŒ‡ä»¤å®ç°æ—¶ï¼Œä¼šå¸¦æ¥æ›´é«˜çš„æ€§èƒ½ã€‚ä½†æ˜¯å¦‚æœå®ƒçš„å†…éƒ¨ä½¿ç”¨äº’æ–¥é‡å®ç°ï¼Œé‚£ä¹ˆä¸å¯èƒ½æœ‰æ€§èƒ½çš„æå‡ã€‚

- å‰è¨€ï¼š

  æ ‡å‡†åŸå­ç±»å‹å®šä¹‰åœ¨å¤´æ–‡ä»¶ [`<atomic>`](https://zh.cppreference.com/w/cpp/header/atomic) ä¸­ã€‚è¿™äº›ç±»å‹çš„æ“ä½œéƒ½æ˜¯åŸå­çš„ï¼Œè¯­è¨€å®šä¹‰ä¸­åªæœ‰è¿™äº›ç±»å‹çš„æ“ä½œæ˜¯åŸå­çš„ï¼Œè™½ç„¶ä¹Ÿå¯ä»¥ç”¨äº’æ–¥é‡æ¥æ¨¡æ‹ŸåŸå­æ“ä½œï¼ˆè§ä¸Šæ–‡ï¼‰ã€‚

  æ ‡å‡†åŸå­ç±»å‹çš„å®ç°é€šå¸¸åŒ…æ‹¬ä¸€ä¸ª `is_lock_free()` æˆå‘˜å‡½æ•°ï¼Œå…è®¸ç”¨æˆ·æŸ¥è¯¢ç‰¹å®šåŸå­ç±»å‹çš„æ“ä½œæ˜¯å¦æ˜¯é€šè¿‡ç›´æ¥çš„åŸå­æŒ‡ä»¤å®ç°ï¼ˆè¿”å› trueï¼‰ï¼Œè¿˜æ˜¯é€šè¿‡é”æ¥å®ç°ï¼ˆè¿”å› falseï¼‰ã€‚

  **å¦‚æœä¸€ä¸ªçº¿ç¨‹å†™å…¥åŸå­å¯¹è±¡ï¼ŒåŒæ—¶å¦ä¸€çº¿ç¨‹ä»å®ƒè¯»å–ï¼Œé‚£ä¹ˆè¡Œä¸ºæœ‰è‰¯å¥½å®šä¹‰**ï¼ˆæ•°æ®ç«äº‰çš„ç»†èŠ‚è§[å†…å­˜æ¨¡å‹](https://zh.cppreference.com/w/cpp/language/memory_model)ï¼‰ã€‚

- æ³¨æ„ï¼š

  åŸå­æ“ä½œå¯ä»¥åœ¨ä¸€äº›æ—¶å€™ä»£æ›¿äº’æ–¥é‡ï¼Œæ¥è¿›è¡ŒåŒæ­¥æ“ä½œï¼Œä¹Ÿèƒ½å¸¦æ¥æ›´é«˜çš„æ€§èƒ½ã€‚ä½†æ˜¯å¦‚æœå®ƒçš„å†…éƒ¨ä½¿ç”¨äº’æ–¥é‡å®ç°ï¼Œé‚£ä¹ˆä¸å¯èƒ½æœ‰æ€§èƒ½çš„æå‡ã€‚

- åˆ¤æ–­åŸå­æ“ä½œæ˜¯å¦æ— é”

  - `is_lock_free()` ï¼ˆC++11èµ·ï¼‰

    **åŸå­ç±»å‹çš„æˆå‘˜å‡½æ•°**ï¼Œç”¨äºæŸ¥è¯¢ç‰¹å®šåŸå­ç±»å‹çš„æ“ä½œæ˜¯å¦æ˜¯é€šè¿‡ç›´æ¥çš„åŸå­æŒ‡ä»¤å®ç°ï¼ˆè¿”å› trueï¼‰ï¼Œè¿˜æ˜¯é€šè¿‡é”æ¥å®ç°ï¼ˆè¿”å› falseï¼‰ã€‚

    ```c++
    // ä½¿ç”¨ç¤ºä¾‹
    int main() {
        atomic<int> n = 1;
        if (n.is_lock_free())			// è¿è¡ŒæœŸåˆ¤æ–­
            cout << "åŸå­æŒ‡ä»¤å®ç°" << endl;
        else
            cout << "äº’æ–¥é‡å®ç°" << endl;
    }
    ```

  - `is_always_lock_free`ï¼ˆC++17èµ·ï¼‰

    **é™æ€ç¼–è¯‘å™¨å¸¸é‡**ï¼Œå¦‚æœå½“å‰ç¯å¢ƒä¸Šçš„åŸå­ç±»å‹ X æ˜¯æ— é”ç±»å‹ï¼Œé‚£ä¹ˆ `X::is_always_lock_free` å°†è¿”å› `true` 

    ```c++
    // ä½¿ç”¨ç¤ºä¾‹
    int main() {
        atomic<int> n = 1;
        if constexpr (atomic<int>::is_always_lock_free)	//ç¼–è¯‘æœŸåˆ¤æ–­
            cout << "åŸå­æŒ‡ä»¤å®ç°" << endl;
        else
            cout << "äº’æ–¥é‡å®ç°" << endl;
    }
    ```

    æºç å®ç°ï¼ˆå»ºè®®è‡ªå·±å»çœ‹çœ‹ï¼‰ï¼š

    ```c++
    template <size_t _TypeSize>
    constexpr bool _Is_always_lock_free = _TypeSize <= 8 && (_TypeSize & (_TypeSize - 1)) == 0;
    
    static constexpr bool is_always_lock_free = _Is_always_lock_free<sizeof(_Ty)>;
    ```

  - [`ATOMIC_xxx_LOCK_FREE`](https://zh.cppreference.com/w/cpp/atomic/atomic_is_lock_free)ï¼ˆC++11èµ·ï¼‰

    **é¢„ç¼–è¯‘æœŸå®å®šä¹‰**ï¼Œç”¨äºåœ¨ç¼–è¯‘æ—¶å¯¹å„ç§æ•´æ•°åŸå­ç±»å‹æ˜¯å¦æ— é”è¿›è¡Œåˆ¤æ–­ã€‚

    ```c++
    #define ATOMIC_BOOL_LOCK_FREE 2
    #define ATOMIC_CHAR_LOCK_FREE 2
    #define ATOMIC_CHAR16_T_LOCK_FREE 2
    #define ATOMIC_CHAR32_T_LOCK_FREE 2
    #define ATOMIC_WCHAR_T_LOCK_FREE  2
    #define ATOMIC_SHORT_LOCK_FREE    2
    #define ATOMIC_INT_LOCK_FREE      2
    #define ATOMIC_LONG_LOCK_FREE     2
    #define ATOMIC_LLONG_LOCK_FREE    2
    #define ATOMIC_POINTER_LOCK_FREE  2
    ```

    è§£é‡Šï¼š

    - **åŒä¸€ä¸ªå®ååœ¨ä¸åŒå¹³å°å®šä¹‰çš„å€¼ä¸ä¸€å®šç›¸åŒ**ï¼Œå…·ä½“å¦‚ä¸‹ï¼š
      - å¯¹äºä¸€å®š**æœ‰é”**çš„å†…å»ºåŸå­ç±»å‹æ˜¯ 0ï¼›
      - å¯¹äº**æœ‰æ—¶æ— é”**çš„å†…å»ºåŸå­ç±»å‹æ˜¯ 1ï¼›
      - å¯¹äºä¸€å®š**æ— é”**çš„å†…å»ºåŸå­ç±»å‹æ˜¯ 2ã€‚

    ```c++
    // ä½¿ç”¨ç¤ºä¾‹
    int main() {
        atomic<int> n = 1;
    #if ATOMIC_INT_LOCK_FREE == 2
        cout << "ä¸€å®šæœ‰é”" << endl;
    #elif ATOMIC_INT_LOCK_FREE == 1
        cout << "å¯èƒ½æœ‰é”ï¼Œå¯èƒ½æ— é”" << endl;
    #elif ATOMIC_INT_LOCK_FREE == 0
        cout << "ä¸€å®šæ— é”" << endl;
    #endif
    }
    ```

- æ€»ç»“ï¼š

  åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¦‚æœä¸€ä¸ªç±»å‹çš„åŸå­æ“ä½œæ€»æ˜¯æ— é”çš„ï¼Œæˆ‘ä»¬å¯ä»¥æ›´æ”¾å¿ƒåœ°åœ¨æ€§èƒ½å…³é”®çš„ä»£ç è·¯å¾„ä¸­ä½¿ç”¨å®ƒã€‚ä¾‹å¦‚ï¼Œåœ¨é«˜é¢‘äº¤æ˜“ç³»ç»Ÿã€å®æ—¶ç³»ç»Ÿæˆ–è€…å…¶å®ƒéœ€è¦é«˜å¹¶å‘æ€§èƒ½çš„åœºæ™¯ä¸­ï¼Œæ— é”çš„åŸå­æ“ä½œå¯ä»¥æ˜¾è‘—å‡å°‘é”çš„å¼€é”€å’Œç«äº‰ï¼Œæé«˜ç³»ç»Ÿçš„ååé‡å’Œå“åº”æ—¶é—´ã€‚

  å¦ä¸€æ–¹é¢ï¼Œå¦‚æœå‘ç°æŸäº›åŸå­ç±»å‹åœ¨ç›®æ ‡å¹³å°ä¸Šæ˜¯æœ‰é”çš„ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä»¥ä¸‹ä¼˜åŒ–ç­–ç•¥ï¼š

  1. **ä½¿ç”¨ä¸åŒçš„æ•°æ®ç»“æ„**ï¼šæœ‰æ—¶å¯ä»¥é€šè¿‡æ”¹å˜æ•°æ®ç»“æ„æ¥é¿å…å¯¹åŸå­æ“ä½œçš„ä¾èµ–ã€‚
  2. **å‡å°‘åŸå­æ“ä½œçš„é¢‘ç‡**ï¼šé€šè¿‡æ‰¹å¤„ç†ç­‰æŠ€æœ¯ï¼Œå‡å°‘å¯¹åŸå­æ“ä½œçš„è°ƒç”¨æ¬¡æ•°ã€‚
  3. **ä½¿ç”¨æ›´é«˜æ•ˆçš„åŒæ­¥æœºåˆ¶**ï¼šåœ¨ä¸€äº›æƒ…å†µä¸‹ï¼Œå…¶å®ƒåŒæ­¥æœºåˆ¶ï¼ˆå¦‚è¯»å†™é”ï¼‰å¯èƒ½æ¯”åŸå­æ“ä½œæ›´é«˜æ•ˆã€‚

  å½“ç„¶ï¼Œå…¶å®å¾ˆå¤šæ—¶å€™æ ¹æœ¬æ²¡è¿™ç§æ€§èƒ½çš„æ‹…å¿§ï¼Œæˆ‘ä»¬å¾ˆå¤šæ—¶å€™ä½¿ç”¨åŸå­å¯¹è±¡åªæ˜¯ä¸ºäº†ç®€å•æ–¹ä¾¿ï¼Œæ¯”å¦‚ `std::atomic<bool>` è¡¨ç¤ºçŠ¶æ€ã€`std::atomic<int>` è¿›è¡Œè®¡æ•°ç­‰ã€‚å³ä½¿å®ƒä»¬æ˜¯ç”¨äº†é”ï¼Œé‚£ä¹Ÿæ˜¯å°è£…å¥½äº†çš„ï¼Œèµ·ç ç”¨ç€æ–¹ä¾¿ï¼Œè€Œä¸éœ€è¦åœ¨ä»£ç ä¸­å¼•å…¥é¢å¤–çš„äº’æ–¥é‡æ¥ä¿æŠ¤ï¼Œæ›´åŠ ç®€æ´ã€‚è¿™ä¹Ÿæ˜¯å¾ˆæ­£å¸¸çš„éœ€æ±‚ï¼Œå„ä½ä¸ä½†è¦è€ƒè™‘ç¨‹åºçš„æ€§èƒ½ï¼ŒåŒæ—¶ä¹Ÿè¦è€ƒè™‘ä»£ç çš„ç®€æ´æ€§ã€æ˜“ç”¨æ€§ã€‚å³ä½¿ä½¿ç”¨åŸå­ç±»å‹æ— æ³•å¸¦æ¥æ•ˆç‡çš„æå‡ï¼Œé‚£ä¹Ÿæ²¡æœ‰è´Ÿæå‡ã€‚

### åŸå­ç±»å‹-åˆ«åã€ä½¿ç”¨ã€è‡ªå®šä¹‰

> - atomicçš„åˆå§‹åŒ–ä¸æ˜¯åŸå­æ“ä½œ

> - åŸå­ç±»å‹ä¸å¯å¤åˆ¶ï¼Œç§»åŠ¨ï¼Œèµ‹å€¼ï¼Œæ‰€ä»¥å¦‚æœæœ‰ä¸€ä¸ªç±»åŒ…å«äº†åŸå­ç±»å‹åšæˆå‘˜ï¼Œåˆ™è¯¥ç±»ä¹Ÿä¸å¯å¤åˆ¶ï¼Œç§»åŠ¨ï¼Œèµ‹å€¼ï¼ˆå…¶ä»–ç±»ä¼¼çš„ç±»å‹åŒç†ï¼‰
>
>   ```c++
>   struct X{
>   	atomic_int n;  
>   };
>   int main(){
>       X x1;
>       X x2{x1};		// ERROR
>       X x3{move(x1)};	// ERROR
>       X x4 = x1;		// ERROR
>   }
>   ```
>
> - ä»»ä½• [std::atomic](https://zh.cppreference.com/w/cpp/atomic/atomic) ç±»å‹ï¼Œ**åˆå§‹åŒ–ä¸æ˜¯åŸå­æ“ä½œ**ã€‚

- å‰è¨€ï¼š

  é€šå¸¸ `std::atomic` å¯¹è±¡ä¸å¯è¿›è¡Œå¤åˆ¶ã€ç§»åŠ¨ã€èµ‹å€¼ï¼Œå› ä¸ºå®ƒä»¬çš„[å¤åˆ¶æ„é€ ](https://zh.cppreference.com/w/cpp/atomic/atomic/atomic)ä¸[å¤åˆ¶èµ‹å€¼è¿ç®—ç¬¦](https://zh.cppreference.com/w/cpp/atomic/atomic/operator%3D)è¢«å®šä¹‰ä¸º[å¼ƒç½®](https://zh.cppreference.com/w/cpp/language/function#.E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0)çš„ã€‚ä¸è¿‡å¯ä»¥**éšå¼è½¬æ¢**æˆå¯¹åº”çš„å†…ç½®ç±»å‹ï¼Œå› ä¸ºå®ƒæœ‰[è½¬æ¢å‡½æ•°](https://zh.cppreference.com/w/cpp/atomic/atomic/operator_T)ã€‚

  ```c++
  atomic(const atomic&) = delete;
  atomic& operator=(const atomic&) = delete;
  operator T() const noexcept;
  ```

- ç‰¹åŒ–çš„åŸå­ç±»å‹æ¨¡æ¿çš„ä½¿ç”¨

  å¯ä»¥ä½¿ç”¨ `load()`ã€`store()`ã€`exchange()`ã€`compare_exchange_weak()` å’Œ `compare_exchange_strong()` ç­‰æˆå‘˜å‡½æ•°å¯¹ `std::atomic` è¿›è¡Œæ“ä½œã€‚å¦‚æœæ˜¯[æ•´æ•°ç±»å‹](https://zh.cppreference.com/w/cpp/atomic/atomic#.E7.89.B9.E5.8C.96.E6.88.90.E5.91.98.E5.87.BD.E6.95.B0)çš„ç‰¹åŒ–ï¼Œè¿˜æ”¯æŒ `++`ã€`--`ã€`+=`ã€`-=`ã€`&=`ã€`|=`ã€`^=` ã€`fetch_add`ã€`fetch_sub` ç­‰æ“ä½œæ–¹å¼ã€‚åœ¨åé¢è¯¦ç»†çš„å±•å¼€ä½¿ç”¨ã€‚

- ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹ä½œä¸ºåŸå­ç±»å‹æ¨¡æ¿çš„å‚æ•°

  `std::atomic` ç±»æ¨¡æ¿ä¸ä»…åªèƒ½ä½¿ç”¨æ ‡å‡†åº“ä¸ºæˆ‘ä»¬å®šä¹‰çš„ç‰¹åŒ–ç±»å‹ï¼Œæˆ‘ä»¬ä¹Ÿå®Œå…¨å¯ä»¥è‡ªå®šä¹‰ç±»å‹åˆ›å»ºå¯¹åº”çš„åŸå­å¯¹è±¡ã€‚ä¸è¿‡å› ä¸ºæ˜¯é€šç”¨æ¨¡æ¿ï¼Œæ“ä½œä»…é™ `load()`ã€`store()`ã€`exchange()`ã€`compare_exchange_weak()` ã€ `compare_exchange_strong()`ï¼Œä»¥åŠä¸€ä¸ªè½¬æ¢å‡½æ•°ã€‚

  - è¦æ±‚ï¼š

    æ¨¡æ¿ `std::atomic` å¯ç”¨ä»»ä½•æ»¡è¶³[*å¯å¤åˆ¶æ„é€  (CopyConstructible)*](https://zh.cppreference.com/w/cpp/named_req/CopyConstructible)åŠ[*å¯å¤åˆ¶èµ‹å€¼ (CopyAssignable)*](https://zh.cppreference.com/w/cpp/named_req/CopyAssignable)çš„[*å¯å¹³å‡¡å¤åˆ¶ (TriviallyCopyable)*](https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable)ç±»å‹ `T` å®ä¾‹åŒ–ï¼ˆ**ä¸ä¸€å®šè¦å¹³å‡¡ç±»å‹**ï¼Œæ»¡è¶³ä¸Šè¿°è¦æ±‚å³å¯ä½œä¸ºåŸå­ç±»å‹æ¨¡æ¿å‚æ•°ï¼‰ã€‚

    ```c++
    // è¯¥ç±»ä¸æ˜¯å¹³å‡¡ç±»å‹ï¼Œä½†ä¾ç„¶å¯ä»¥ä½œä¸ºåŸå­ç±»å‹æ¨¡æ¿çš„å‚æ•°
    struct trivial_type {
        int x{};
        float y{};
    
        trivial_type() {}
    
        trivial_type(int a, float b) : x{ a }, y{ b } {}
    
        trivial_type(const trivial_type& other) = default;
    
        trivial_type& operator=(const trivial_type& other) = default;
    
        ~trivial_type() = default;
    };
    // å†™æˆè¿™æ ·è¯¥ç±»å°±å˜æˆäº†å¹³å‡¡ç±»å‹ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥
    struct trivial_type {
        int x;
        float y;
    };
    ```

  - éªŒè¯ï¼š

    éªŒè¯è‡ªå·±çš„ç±»å‹æ˜¯å¦æ»¡è¶³ `std::atomic` è¦æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨[é™æ€æ–­è¨€](https://zh.cppreference.com/w/cpp/language/static_assert)ï¼š

    ```c++
    static_assert(std::is_trivially_copyable<trivial_type>::value, "");
    static_assert(std::is_copy_constructible<trivial_type>::value, "");
    static_assert(std::is_move_constructible<trivial_type>::value, "");
    static_assert(std::is_copy_assignable<trivial_type>::value, "");
    static_assert(std::is_move_assignable<trivial_type>::value, "");
    ```

    ç¨‹åºèƒ½é€šè¿‡ç¼–è¯‘å³ä»£è¡¨æ»¡è¶³è¦æ±‚ã€‚å¦‚æœä¸æ»¡è¶³è¦æ±‚ï¼Œé™æ€æ–­è¨€æ±‚å€¼ä¸­ç¬¬ä¸€ä¸ªè¡¨è¾¾å¼æ±‚å€¼ä¸º falseï¼Œåˆ™ç¼–è¯‘é”™è¯¯ã€‚

  - ç¤ºä¾‹ï¼š

    ```c++
    // åˆ›å»ºä¸€ä¸ª std::atomic<trivial_type> å¯¹è±¡
    std::atomic<trivial_type> atomic_my_type { trivial_type{ 10, 20.5f } };
    
    // ä½¿ç”¨ store å’Œ load æ“ä½œæ¥è®¾ç½®å’Œè·å–å€¼
    trivial_type new_value{ 30, 40.5f };
    atomic_my_type.store(new_value);
    
    trivial_type loadedValue = atomic_my_type.load();
    std::cout << "x: " << loadedValue.x << ", y: " << loadedValue.y << std::endl;
    
    // ä½¿ç”¨ exchange æ“ä½œ
    trivial_type exchanged_value = atomic_my_type.exchange(trivial_type{ 50, 60.5f });
    std::cout << "äº¤æ¢å‰çš„ x: " << exchanged_value.x
              << ", äº¤æ¢å‰çš„ y: " << exchanged_value.y << std::endl;
    std::cout << "äº¤æ¢åçš„ x: " << atomic_my_type.load().x
              << ", äº¤æ¢åçš„ y: " << atomic_my_type.load().y << std::endl;
    ```

    è§£é‡Šï¼š

    - å…¶ä¸­`exchange()`çš„è¿”å›å€¼æ˜¯åŸå­å˜é‡åœ¨è°ƒç”¨å‰çš„å€¼ã€‚

- åŸå­ç±»å‹çš„å†…å­˜åºå‚æ•°

  åŸå­ç±»å‹çš„æ¯ä¸ªæ“ä½œå‡½æ•°ï¼Œéƒ½æœ‰ä¸€ä¸ªå†…å­˜åºå‚æ•°ï¼Œè¿™ä¸ªå‚æ•°å¯ä»¥ç”¨æ¥æŒ‡å®šæ‰§è¡Œé¡ºåºï¼Œåœ¨åé¢çš„å†…å®¹ä¼šè¯¦ç»†è®²è¿°ï¼Œç°åœ¨åªéœ€è¦çŸ¥é“æ“ä½œåˆ†ä¸ºä¸‰ç±»ï¼š

  1. **Store æ“ä½œï¼ˆå­˜å‚¨æ“ä½œï¼‰**ï¼šå¯é€‰çš„å†…å­˜åºåŒ…æ‹¬ `memory_order_relaxed`ã€`memory_order_release`ã€`memory_order_seq_cst`ã€‚
  2. **Load æ“ä½œï¼ˆåŠ è½½æ“ä½œï¼‰**ï¼šå¯é€‰çš„å†…å­˜åºåŒ…æ‹¬ `memory_order_relaxed`ã€`memory_order_consume`ã€`memory_order_acquire`ã€`memory_order_seq_cst`ã€‚
  3. **Read-modify-writeï¼ˆè¯»-æ”¹-å†™ï¼‰æ“ä½œ**ï¼šå¯é€‰çš„å†…å­˜åºåŒ…æ‹¬ `memory_order_relaxed`ã€`memory_order_consume`ã€`memory_order_acquire`ã€`memory_order_release`ã€`memory_order_acq_rel`ã€`memory_order_seq_cst`ã€‚

  > æœ¬èŠ‚ä¸»è¦å¹¿æ³›ä»‹ç» `std::atomic`ï¼Œè€Œæœªå±•å¼€å…·ä½“ä½¿ç”¨ã€‚åœ¨åç»­ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°è®¨è®ºä¸€äº›ç‰ˆæœ¬ï¼Œå¦‚ `std::atomic<bool>`ï¼Œå¹¶ä»‹ç»å…¶æˆå‘˜å‡½æ•°å’Œä½¿ç”¨æ–¹æ³•ã€‚
  >
  > æœ€åå¼ºè°ƒä¸€ä¸‹ï¼šä»»ä½• [std::atomic](https://zh.cppreference.com/w/cpp/atomic/atomic) ç±»å‹ï¼Œ**åˆå§‹åŒ–ä¸æ˜¯åŸå­æ“ä½œ**ã€‚

## å®ç°çº¿ç¨‹æ± 

[é‡ç‚¹çœ‹æœ¬ç« çš„å®ç°çº¿ç¨‹æ± éƒ¨åˆ†](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/è¯¦ç»†åˆ†æ/04çº¿ç¨‹æ± .html)

```c++
int main() {
    ThreadPool pool{ 4 }; // åˆ›å»ºä¸€ä¸ªæœ‰ 4 ä¸ªçº¿ç¨‹çš„çº¿ç¨‹æ± 
    std::vector<std::future<int>> futures; // future é›†åˆï¼Œè·å–è¿”å›å€¼

    for (int i = 0; i < 10; ++i) {
        futures.emplace_back(pool.submit(print_task, i));
    }

    for (int i = 0; i < 10; ++i) {
        futures.emplace_back(pool.submit(print_task2, i));
    }

    //int sum = 0;
    //for (auto& future : futures) {
    //    sum += future.get(); // get() æˆå‘˜å‡½æ•° é˜»å¡åˆ°ä»»åŠ¡æ‰§è¡Œå®Œæ¯•ï¼Œè·å–è¿”å›å€¼
    //}
    //std::cout << "sum: " << sum << '\n';
} // ææ„è‡ªåŠ¨ stop()
```

æ³¨æ„ï¼š

- å¦‚æœæœ€åä¸ç”¨`future.get()`é˜»å¡ç­‰å¾…çº¿ç¨‹æ± æ‰§è¡Œå®Œæ¯•ï¼Œé‚£ä¹ˆæœ€åçº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡ä¸€å®šæ— æ³•å…¨éƒ¨æ‰§è¡Œå®Œï¼Œè¿™æ˜¯å› ä¸ºï¼šåœ¨`pool`ææ„æ—¶ä¼šè°ƒç”¨`stop()`å‡½æ•°ï¼Œè€Œåœ¨`stop()`ä¸­ï¼Œåœ¨è®¾ç½®`stop_`çš„æ ‡å¿—ä½ä¹‹åï¼Œ`start()`ä¸­çš„æ‰€æœ‰çº¿ç¨‹ä¼šç«‹åˆ»é€€å‡ºwhileå¾ªç¯ï¼Œå¹¶æ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—ï¼Œè¿™ç‚¹å’Œasioä¸­çš„çº¿ç¨‹æ± å¾ˆç±»ä¼¼ã€‚

## std::atomic_flag

[ç®€å•çœ‹çœ‹è¿™é‡Œå°±å¥½äº†](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/05å†…å­˜æ¨¡å‹ä¸åŸå­æ“ä½œ.html#std-atomic-flag)

> - è¯¥ç±»å¯ä»¥ç”¨äºå½“è‡ªæ—‹é”ï¼Œä½†ä»»ä½•æ—¶å€™éƒ½ä¸æ¨èä½¿ç”¨è‡ªæ—‹é”
> - æ˜¾ç„¶ï¼Œ
> - ä¸ä»…ä»…æ˜¯atomic_flagï¼Œæ‰€æœ‰çš„åŸå­ç±»å‹éƒ½ä¸èƒ½å¤åˆ¶ä¸èƒ½ç§»åŠ¨ï¼ˆæ¯”é‚£äº›å¼‚æ­¥è®¾æ–½è¿˜å¤¸å¼ å“¦ï¼‰

## std::atomic\<bool>

> - æœ¬èŠ‚æ“ä½œä¸ä»…ä»…å¯¹äºboolï¼Œå¯¹äºå…¶ä»–ç±»å‹ä¸€æ ·é€‚ç”¨
> - æ³¨æ„`operator=`çš„è¿”å›å€¼æ˜¯`_Ty`è€Œé`atomic<_Ty>&`
> - è¿›è¡Œè¯»-æ”¹-å†™æ“ä½œæ—¶ï¼Œæ¯”è¾ƒä¸å¤åˆ¶éƒ½æ˜¯**é€ä½**çš„ï¼Œæ‰€ä»¥æ‰€æœ‰ä¼ å…¥`atomic<>`çš„ç±»å‹ï¼Œéƒ½è¦ä¿è¯æ˜¯å¯è¢«é€ä½å¤åˆ¶çš„ã€‚
> - `compare_exchange_weak()`éœ€è¦åœ¨å¾ªç¯ä¸­è¿›è¡Œï¼Œ`compare_exchange_strong()`ä¸éœ€è¦

- æ¦‚å¿µï¼š

  `std::atomic<bool>` æ˜¯æœ€åŸºæœ¬çš„**æ•´æ•°åŸå­ç±»å‹** ï¼Œå®ƒç›¸è¾ƒäº `std::atomic_flag` æä¾›äº†æ›´åŠ å®Œå–„çš„å¸ƒå°”æ ‡å¿—ã€‚è™½ç„¶åŒæ ·ä¸å¯å¤åˆ¶ä¸å¯ç§»åŠ¨ï¼Œä½†å¯ä»¥ä½¿ç”¨éåŸå­çš„ bool ç±»å‹è¿›è¡Œæ„é€ ï¼Œåˆå§‹åŒ–ä¸º true æˆ– falseï¼Œå¹¶ä¸”èƒ½ä»éåŸå­çš„ bool å¯¹è±¡èµ‹å€¼ç»™ `std::atomic<bool>`ï¼š

  ```c++
  std::atomic<bool> b{ true };
  b = false;
  ```

- `operator=()`çš„è¿”å›å€¼

  ä¸å…¶ä»–ç±»å‹ä¸åŒï¼Œ`atomic<_Ty>::operator=()`è¿”å›çš„æ˜¯`_Ty`è€Œé`atomic<_Ty>&`

  ```c++
  int main(){
      atomic<bool> ab1 = true;
      //atomic<bool>& ab2 = (ab1 = false);  // ERROR
      bool b3 = (ab1 = false);
  }
  ```

  å› ä¸ºå¦‚æœ`operator=()`è¿”å›å€¼ç±»å‹ä¸º`atomic<_Ty>&`çš„è¯ï¼Œé‚£ä¹ˆåˆ™è¡¨æ˜`atomic<bool> ab2 = (ab1 = false);`åˆæ³•ï¼Œè¿™æ˜¾ç„¶ä¸å¯¹ï¼Œå› ä¸º`atomic<_Ty>`æ˜¯ä¸å¯å¤åˆ¶çš„ã€‚

- ç®€å•è¯»ï¼Œå†™ï¼Œè¯»-æ”¹-å†™`atomic<bool>`çš„å€¼

  è·å– `std::atomic<bool>` çš„å€¼æœ‰ä¸¤ç§æ–¹å¼ï¼Œ**è°ƒç”¨ `load()` å‡½æ•°**ï¼Œæˆ–è€…**éšå¼è½¬æ¢**ã€‚

  **`store` æ˜¯ä¸€ä¸ªå­˜å‚¨æ“ä½œã€`load` æ˜¯ä¸€ä¸ª*åŠ è½½æ“ä½œ*ã€`exchange` æ˜¯ä¸€ä¸ªâ€œ*è¯»-æ”¹-å†™*â€æ“ä½œ**ï¼š

  ```c++
  std::atomic<bool> b;
  
  /********è¯»********/
  bool x1 = b.load();
  bool x2 = b;	// å†…éƒ¨è°ƒç”¨b.load()
  
  /********å†™********/
  b.store(true);
  bool y1 = b;	// å†…éƒ¨è°ƒç”¨b.store()
  
  /********è¯»-æ”¹-å†™********/
  bool z1 = b.exchange(false);	// è¯»å‡ºbä¸­å­˜å‚¨çš„æ•°æ®ï¼Œå¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼Œå†å†™å›å­˜å‚¨å™¨ä¸­
  ```

  è§£é‡Šï¼š

  - å­˜å‚¨å™¨åˆ†ç±»ï¼š

    <img src="assets/b83681ae15ba18ce741af5d7c270e8b9.png" alt="img" style="zoom: 50%;" />

    å…¶ä¸­ä¸»å­˜å°±æ˜¯å†…å­˜

  - è¯»-æ”¹-å†™æ“ä½œ

    **å…ˆè¯»å‡ºå­˜å‚¨å™¨ä¸­çš„æ•°æ®ï¼Œå¯¹å…¶è¿›è¡Œä¿®æ”¹åï¼Œå†å†™å…¥å­˜å‚¨å™¨**ï¼ˆæ˜¾ç„¶åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå­˜å‚¨å™¨æŒ‡çš„æ˜¯å†…å­˜ï¼‰ã€‚

- è¾ƒä¸ºå¤æ‚çš„è¯»-æ”¹-å†™æ“ä½œ

  [ï¼ï¼ï¼æ¨èçœ‹è¿™ä¸ª](https://zh.cppreference.com/w/cpp/atomic/atomic/compare_exchange)

  `std::atomic<bool>` æä¾›å¤šä¸ªâ€œ*è¯»-æ”¹-å†™*â€çš„æ“ä½œï¼Œexchange åªæ˜¯å…¶ä¸­ä¹‹ä¸€ã€‚å®ƒè¿˜æä¾›äº†ä¸€ç§å­˜å‚¨æ–¹å¼ï¼š**å½“å‰å€¼ä¸é¢„æœŸå€¼ä¸€è‡´æ—¶ï¼Œå½“å‰å€¼æ›´æ–°ä¸ºæ–°å€¼ï¼Œå¹¶è¿”å›trueï¼›å¦åˆ™ï¼Œé¢„æœŸå€¼æ›´æ–°ä¸ºå½“å‰å€¼ï¼Œå¹¶è¿”å›falseã€‚**

  è¿™ç§æ“ä½œå«åšâ€œæ¯”è¾ƒ/äº¤æ¢â€ï¼Œå®ƒçš„å½¢å¼è¡¨ç°ä¸º [`compare_exchange_weak()`](https://zh.cppreference.com/w/cpp/atomic/atomic/compare_exchange) å’Œ `compare_exchang_strong()`

  - `compare_exchange_weak()`

    å°è¯•å°†åŸå­å¯¹è±¡çš„å½“å‰å€¼ä¸é¢„æœŸå€¼è¿›è¡Œæ¯”è¾ƒ[^1]ï¼Œï¼Œå¦‚æœç›¸ç­‰åˆ™å°†å…¶æ›´æ–°ä¸ºæ–°å€¼å¹¶è¿”å› `true`ï¼›å¦åˆ™ï¼Œå°†åŸå­å¯¹è±¡çš„å€¼åŠ è½½è¿› expectedï¼ˆè¿›è¡ŒåŠ è½½æ“ä½œï¼‰å¹¶è¿”å› `false`ã€‚æ­¤æ“ä½œå¯èƒ½ä¼šç”±äºæŸäº›ç¡¬ä»¶çš„ç‰¹æ€§è€Œå‡ºç°å‡å¤±è´¥[^2]ï¼Œ**éœ€è¦åœ¨å¾ªç¯ä¸­é‡è¯•**ã€‚

    ```c++
    // ç®€å•ä¾‹å­
    std::atomic<bool> flag{ false };
    bool expected = false;
    bool desired = true;
    while (!flag.compare_exchange_weak(expected, desired));// åªæœ‰å½“è¿”å›trueæ—¶ï¼Œæ‰ä¼šé€€å‡ºå¾ªç¯ï¼›æ‰€ä»¥è¯¥å¾ªç¯ä¼šä¸€ç›´é‡å¤ç›´åˆ°å½“å‰å€¼æ›´æ–°ä¸ºdesiredå¹¶è¿”å›true
    
    // å¤æ‚ä¾‹å­
    #include <atomic>
     
    template<typename T>
    struct node
    {
        T data;
        node* next;
        node(const T& data) : data(data), next(nullptr) {}
    };
     
    template<typename T>
    class stack
    {
        std::atomic<node<T>*> head;
    public:
        void push(const T& data)
        {
            node<T>* new_node = new node<T>(data);
     
            // å°† head çš„å½“å‰å€¼æ”¾åˆ° new_node->next ä¸­
            new_node->next = head.load(std::memory_order_relaxed);
     
            // ç°åœ¨ä»¤ new_node ä¸ºæ–°çš„ head ï¼Œä½†å¦‚æœ head ä¸å†æ˜¯
            // å­˜å‚¨äº new_node->next çš„å€¼ï¼ˆæŸäº›å…¶ä»–çº¿ç¨‹å¿…é¡»åœ¨åˆšæ‰æ’å…¥ç»“ç‚¹ï¼‰
            // é‚£ä¹ˆå°†æ–°çš„ head æ”¾åˆ° new_node->next ä¸­å¹¶å†å°è¯•
            while(!head.compare_exchange_weak(new_node->next, new_node,))
                ; // å¾ªç¯ä½“ä¸ºç©º
        }
    };
     
    int main()
    {
        stack<int> s;
        s.push(1);
        s.push(2);
        s.push(3);
    }
    ```

  - `compare_exchang_strong()`

    ç±»ä¼¼äº `compare_exchange_weak`ï¼Œ**ä½†ä¸ä¼šå‡ºç°å‡å¤±è´¥ï¼Œå› æ­¤ä¸éœ€è¦é‡è¯•**ã€‚ç”¨äºè¦ä¹ˆæ›´æ”¹åŸå­å¯¹è±¡çš„å€¼ï¼Œè¦ä¹ˆå°†å˜é‡ç”¨äºæ¯”è¾ƒã€‚

    ```c++
    std::atomic<int> ai;
     
    int tst_val = 4;
    int new_val = 5;
    bool exchanged= false;
     
    void valsout()
    {
        std::cout << "ai = " << ai
    	      << "  tst_val = " << tst_val
    	      << "  new_val = " << new_val
    	      << "  exchanged = " << std::boolalpha << exchanged
    	      << "\n";
    }
     
    int main()
    {
        ai= 3;
        valsout();
     
        // tst_val != ai   ==>  tst_val è¢«ä¿®æ”¹
        exchanged= ai.compare_exchange_strong(tst_val, new_val);
        valsout();
     
        // tst_val == ai   ==>  ai è¢«ä¿®æ”¹
        exchanged= ai.compare_exchange_strong(tst_val, new_val);
        valsout();
    }
    ```
    
  - æ€»ç»“
  
    åœ¨çœ‹å®Œä¸Šé¢ä¸¤ä¸ªå‡½æ•°çš„é€»è¾‘ä¹‹åï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å¯¹äºâ€œæœŸå¾…å€¼â€çš„è§£é‡Šï¼šæœŸå¾…å€¼æŒ‡çš„ä¸æ˜¯æœŸå¾…åŸå­å¯¹è±¡æœ€åå˜æˆè¯¥å€¼ï¼Œè€Œæ˜¯æœŸå¾…åœ¨è°ƒç”¨â€œæ¯”è¾ƒ/è½¬æ¢â€å‡½æ•°æ—¶ï¼Œåœ¨æˆ‘é¢„æƒ³ä¸­çš„ï¼ŒåŸå­å¯¹è±¡é‡Œå®é™…å­˜å‚¨çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´è¯¥å‡½æ•°å¯ä»¥çœ‹æˆä¸¤æ­¥ï¼šcompareï¼Œexchangeï¼›åªæœ‰å½“åŸå­å¯¹è±¡ä¸­å®é™…å­˜å‚¨çš„å€¼ä¸æˆ‘é¢„æƒ³ä¸­çš„å€¼ç›¸ç­‰æ—¶ï¼Œæˆ‘æ‰è¿›è¡Œexchangeæ“ä½œï¼Œå¦åˆ™å‘Šè¯‰æˆ‘åŸå­å¯¹è±¡ä¸­å®é™…å­˜å‚¨çš„å€¼ã€‚

## std::atomic<T*>

> - `atomic<T*>`**åªèƒ½ä¿è¯å¯¹æŒ‡é’ˆæœ¬èº«çš„æ“ä½œæ˜¯åŸå­æ“ä½œ**ï¼Œæ— æ³•ä¿è¯å¯¹æŒ‡é’ˆæŒ‡å‘çš„å€¼çš„æ“ä½œæ˜¯åŸå­æ“ä½œã€‚

- å‰è¨€ï¼š

  `std::atomic<T*>` æ˜¯ä¸€ä¸ªåŸå­æŒ‡é’ˆç±»å‹ï¼Œ`T` æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„å¯¹è±¡ç±»å‹ã€‚æ“ä½œæ˜¯é’ˆå¯¹ `T` ç±»å‹çš„æŒ‡é’ˆè¿›è¡Œçš„ã€‚è™½ç„¶ `std::atomic<T*>` ä¸èƒ½è¢«æ‹·è´å’Œç§»åŠ¨ï¼Œä½†å®ƒå¯ä»¥é€šè¿‡ç¬¦åˆç±»å‹çš„æŒ‡é’ˆè¿›è¡Œæ„é€ å’Œèµ‹å€¼ã€‚

- é€šç”¨çš„æˆå‘˜å‡½æ•°ï¼š

  `std::atomic<T*>` æ‹¥æœ‰ä»¥ä¸‹æˆå‘˜å‡½æ•°ï¼š

  - `load()`ï¼šä»¥åŸå­æ–¹å¼è¯»å–æŒ‡é’ˆå€¼ã€‚
  - `store()`ï¼šä»¥åŸå­æ–¹å¼å­˜å‚¨æŒ‡é’ˆå€¼ã€‚
  - `exchange()`ï¼šä»¥åŸå­æ–¹å¼äº¤æ¢æŒ‡é’ˆå€¼ã€‚
  - `compare_exchange_weak()` å’Œ `compare_exchange_strong()`ï¼šä»¥åŸå­æ–¹å¼æ¯”è¾ƒå¹¶äº¤æ¢æŒ‡é’ˆå€¼ã€‚

  **æ˜¾ç„¶è¿™äº›å‡½æ•°æ¥å—å¹¶è¿”å›çš„ç±»å‹éƒ½æ˜¯ T*ï¼Œå³æŒ‡é’ˆç±»å‹**ã€‚

- ç‹¬æœ‰çš„æˆå‘˜å‡½æ•°

  æ­¤å¤–ï¼Œ`std::atomic<T*>` è¿˜æä¾›äº†ä»¥ä¸‹æ“ä½œï¼š

  - `fetch_add`ï¼šä»¥åŸå­æ–¹å¼å¢åŠ æŒ‡é’ˆçš„å€¼ã€‚ï¼ˆ`p.fetch_add(1)` ä¼šå°†æŒ‡é’ˆ `p` å‘å‰ç§»åŠ¨ä¸€ä¸ªå…ƒç´ ï¼Œå¹¶**è¿”å›æ“ä½œå‰çš„æŒ‡é’ˆå€¼**ï¼‰

  - `fetch_sub`ï¼šä»¥åŸå­æ–¹å¼å‡å°‘æŒ‡é’ˆçš„å€¼ã€‚**è¿”å›æ“ä½œå‰çš„æŒ‡é’ˆå€¼**ã€‚

  - `operator+=` å’Œ `operator-=`ï¼šä»¥åŸå­æ–¹å¼å¢åŠ æˆ–å‡å°‘æŒ‡é’ˆçš„å€¼ã€‚è¿”å›æ“ä½œå‰çš„æŒ‡é’ˆå€¼ï¼ˆå’Œå‰ä¸¤ä¸ªå‡½æ•°æ²¡åŒºåˆ«ï¼‰ã€‚

    ```c++
    _Ty operator+=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(_Diff) + _Diff;
    }
    ```

  è¿™äº›æ“ä½œç¡®ä¿åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹è¿›è¡Œå®‰å…¨çš„æŒ‡é’ˆæ“ä½œï¼Œé¿å…æ•°æ®ç«äº‰å’Œå¹¶å‘é—®é¢˜ã€‚

- ç¤ºä¾‹ï¼š

  ```c++
  struct Foo {};
  
  Foo array[5]{};
  std::atomic<Foo*> p{ array };
  
  // p åŠ  2ï¼Œå¹¶è¿”å›åŸå§‹å€¼
  Foo* x = p.fetch_add(2);
  assert(x == array);
  assert(p.load() == &array[2]);
  
  // p å‡ 1ï¼Œå¹¶è¿”å›åŸå§‹å€¼
  x = (p -= 1);
  assert(x == &array[1]);
  assert(p.load() == &array[1]);
  
  // å‡½æ•°ä¹Ÿå…è®¸å†…å­˜åºä½œä¸ºç»™å®šå‡½æ•°çš„å‚æ•°
  p.fetch_add(3, std::memory_order_release);
  ```

## std::atomic\<std::shared_ptr>

> - `shared_ptr<>`æˆå‘˜ï¼š
>   - æŒ‡å‘åº•å±‚å…ƒç´ çš„æŒ‡é’ˆï¼ˆ[get()](https://zh.cppreference.com/w/cpp/memory/shared_ptr/get)) æ‰€è¿”å›çš„æŒ‡é’ˆï¼‰
>   - æŒ‡å‘*æ§åˆ¶å—*â€Šçš„æŒ‡é’ˆ
> - ä»çº¿ç¨‹å®‰å…¨çš„è§’åº¦è®²ï¼Œ`shared_ptr<>`éœ€è¦è€ƒè™‘ä¸‰æ–¹é¢çš„çº¿ç¨‹å®‰å…¨
>   - æ§åˆ¶å—çš„çº¿ç¨‹å®‰å…¨ï¼ˆæ ‡å‡†ä¿è¯ï¼‰
>   - åº•å±‚å…ƒç´ çš„çº¿ç¨‹å®‰å…¨ï¼ˆç”¨æˆ·ä¿è¯ï¼Œå¯ä»¥ä½¿ç”¨äº’æ–¥é”æˆ–è€…åŸå­ç±»å‹ï¼‰
>   - `shared_ptr<>`æœ¬èº«çš„çº¿ç¨‹å®‰å…¨ï¼Œä¹Ÿå°±æ˜¯è¯´`shared_ptr<>`å¯¹æˆå‘˜æŒ‡é’ˆçš„æ“ä½œä¼šé€ æˆæ•°æ®ç«äº‰ï¼ˆä¸åŒçº¿ç¨‹ä½¿ç”¨ä¸åŒå‰¯æœ¬ï¼ŒåŸå­ç±»å‹ï¼Œäº’æ–¥é”ä¿è¯ï¼‰

åœ¨å‰æ–‡ä¸­ï¼Œæˆ‘ä»¬å¤šæ¬¡æåˆ° `std::shared_ptr`ï¼š

> ç¬¬å››ç« ä¸­æåˆ°ï¼š*å¤šä¸ªçº¿ç¨‹èƒ½åœ¨ä¸åŒçš„ shared_ptr å¯¹è±¡ä¸Šè°ƒç”¨**æ‰€æœ‰æˆå‘˜å‡½æ•°**[[3\]](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/05å†…å­˜æ¨¡å‹ä¸åŸå­æ“ä½œ.html#footnote3)ï¼ˆåŒ…å«å¤åˆ¶æ„é€ å‡½æ•°ä¸å¤åˆ¶èµ‹å€¼ï¼‰è€Œä¸é™„åŠ åŒæ­¥ï¼Œå³ä½¿è¿™äº›å®ä¾‹æ˜¯åŒä¸€å¯¹è±¡çš„å‰¯æœ¬ä¸”å…±äº«æ‰€æœ‰æƒä¹Ÿæ˜¯å¦‚æ­¤ã€‚è‹¥å¤šä¸ªæ‰§è¡Œçº¿ç¨‹è®¿é—®**åŒä¸€ shared_ptr** å¯¹è±¡è€Œä¸åŒæ­¥ï¼Œä¸”ä»»ä¸€çº¿ç¨‹ä½¿ç”¨ shared_ptr çš„é const æˆå‘˜å‡½æ•°ï¼Œåˆ™å°†å‡ºç°æ•°æ®ç«äº‰ï¼›`std::atomic<shared_ptr>` èƒ½ç”¨äºé¿å…æ•°æ®ç«äº‰ã€‚[æ–‡æ¡£](https://zh.cppreference.com/w/cpp/memory/shared_ptr#:~:text=å¤šä¸ªçº¿ç¨‹èƒ½åœ¨ä¸åŒçš„ shared_ptr å¯¹è±¡ä¸Šè°ƒç”¨æ‰€æœ‰æˆå‘˜å‡½æ•°ï¼ˆåŒ…å«å¤åˆ¶æ„é€ å‡½æ•°ä¸å¤åˆ¶èµ‹å€¼ï¼‰è€Œä¸é™„åŠ åŒæ­¥ï¼Œå³ä½¿è¿™äº›å®ä¾‹æ˜¯åŒä¸€å¯¹è±¡çš„å‰¯æœ¬ä¸”å…±äº«æ‰€æœ‰æƒä¹Ÿæ˜¯å¦‚æ­¤ã€‚è‹¥å¤šä¸ªæ‰§è¡Œçº¿ç¨‹è®¿é—®åŒä¸€ shared_ptr å¯¹è±¡è€Œä¸åŒæ­¥ï¼Œä¸”ä»»ä¸€çº¿ç¨‹ä½¿ç”¨ shared_ptr çš„é const æˆå‘˜å‡½æ•°ï¼Œåˆ™å°†å‡ºç°æ•°æ®ç«äº‰ï¼›std%3A%3Aatomic èƒ½ç”¨äºé¿å…æ•°æ®ç«äº‰ã€‚)ã€‚*

ä¸€ä¸ªåœ¨äº’è”ç½‘ä¸Šéå¸¸çƒ­é—¨çš„å…«è‚¡é—®é¢˜æ˜¯ï¼š***`std::shared_ptr` æ˜¯ä¸æ˜¯çº¿ç¨‹å®‰å…¨ï¼Ÿ***

æ˜¾ç„¶ï¼Œå®ƒå¹¶ä¸æ˜¯å®Œå…¨çº¿ç¨‹å®‰å…¨çš„ï¼Œå°½ç®¡åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­æœ‰å¾ˆå¤§çš„ä¿è¯ï¼Œä½†è¿™è¿˜ä¸å¤Ÿã€‚åœ¨ C++20 ä¸­ï¼ŒåŸå­æ¨¡æ¿ `std::atomic` å¼•å…¥äº†ä¸€ä¸ªåç‰¹åŒ–ç‰ˆæœ¬ [`std::atomic`](https://zh.cppreference.com/w/cpp/memory/shared_ptr/atomic2) å…è®¸ç”¨æˆ·åŸå­åœ°æ“çºµ `shared_ptr` å¯¹è±¡ã€‚å› ä¸ºå®ƒæ˜¯ `std::atomic` çš„ç‰¹åŒ–ç‰ˆæœ¬ï¼Œå³ä½¿æˆ‘ä»¬è¿˜æ²¡æœ‰æ·±å…¥è®²è¿°å®ƒï¼Œä¹Ÿèƒ½çŸ¥é“å®ƒæ˜¯**åŸå­ç±»å‹**ï¼Œè¿™æ„å‘³ç€å®ƒçš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯**åŸå­æ“ä½œ**ã€‚

è‹¥å¤šä¸ªæ‰§è¡Œçº¿ç¨‹ä¸åŒæ­¥åœ°åŒæ—¶è®¿é—®**åŒä¸€** `std::shared_ptr` å¯¹è±¡ï¼Œä¸”ä»»ä½•è¿™äº›è®¿é—®ä½¿ç”¨äº† shared_ptr çš„**é const æˆå‘˜å‡½æ•°**ï¼Œåˆ™å°†**å‡ºç°æ•°æ®ç«äº‰**ï¼Œ**é™¤éé€šè¿‡ `std::atomic<std::shared_ptr>` çš„å®ä¾‹è¿›è¡Œæ‰€æœ‰è®¿é—®**ã€‚

```c++
class Data {
public:
    Data(int value = 0) : value_(value) {}
    int get_value() const { return value_; }
    void set_value(int new_value) { value_ = new_value; }
private:
    int value_;
};

auto data = std::make_shared<Data>();

void writer(){
    for (int i = 0; i < 10; ++i) {
        std::shared_ptr<Data> new_data = std::make_shared<Data>(i);
        data.swap(new_data); // è°ƒç”¨é const æˆå‘˜å‡½æ•°
        std::this_thread::sleep_for(100ms);
    }
}

void reader(){
    for (int i = 0; i < 10; ++i) {
        if (data) {
            std::cout << "è¯»å–çº¿ç¨‹å€¼: " << data->get_value() << std::endl;
        }
        else {
            std::cout << "æ²¡æœ‰è¯»å–åˆ°æ•°æ®" << std::endl;
        }
        std::this_thread::sleep_for(100ms);
    }
}

int main(){
    std::thread writer_thread{ writer };
    std::thread reader_thread{ reader };

    writer_thread.join();
    reader_thread.join();
}
```

> [è¿è¡Œ](https://godbolt.org/z/6zo7hK8h1)æµ‹è¯•ã€‚

ä»¥ä¸Šè¿™æ®µä»£ç æ˜¯å…¸å‹çš„**çº¿ç¨‹ä¸å®‰å…¨**ï¼Œå®ƒæ»¡è¶³ï¼š

1. å¤šä¸ªçº¿ç¨‹ä¸åŒæ­¥åœ°åŒæ—¶è®¿é—®**åŒä¸€** `std::shared_ptr` å¯¹è±¡
2. ä»»ä¸€çº¿ç¨‹ä½¿ç”¨ shared_ptr çš„**é const** æˆå‘˜å‡½æ•°

é‚£ä¹ˆ**ä¸ºä»€ä¹ˆå‘¢**ï¼Ÿä¸ºä»€ä¹ˆæ»¡è¶³è¿™äº›æ¦‚å¿µå°±æ˜¯çº¿ç¨‹ä¸å®‰å…¨å‘¢ï¼Ÿä¸ºäº†ç†è§£è¿™äº›æ¦‚å¿µï¼Œé¦–å…ˆéœ€è¦äº†è§£ shared_ptr çš„å†…éƒ¨å®ç°ï¼š

shared_ptr çš„é€šå¸¸å®ç°åªä¿æœ‰ä¸¤ä¸ªæŒ‡é’ˆ

- æŒ‡å‘åº•å±‚å…ƒç´ çš„æŒ‡é’ˆï¼ˆ[get()](https://zh.cppreference.com/w/cpp/memory/shared_ptr/get)) æ‰€è¿”å›çš„æŒ‡é’ˆï¼‰
- æŒ‡å‘*æ§åˆ¶å—*â€Šçš„æŒ‡é’ˆ

**æ§åˆ¶å—**æ˜¯ä¸€ä¸ªåŠ¨æ€åˆ†é…çš„å¯¹è±¡ï¼Œå…¶ä¸­åŒ…å«ï¼š

- æŒ‡å‘è¢«ç®¡ç†å¯¹è±¡çš„æŒ‡é’ˆæˆ–è¢«ç®¡ç†å¯¹è±¡æœ¬èº«
- åˆ é™¤å™¨ï¼ˆç±»å‹æ“¦é™¤ï¼‰
- åˆ†é…å™¨ï¼ˆç±»å‹æ“¦é™¤ï¼‰
- æŒæœ‰è¢«ç®¡ç†å¯¹è±¡çš„ `shared_ptr` çš„æ•°é‡
- æ¶‰åŠè¢«ç®¡ç†å¯¹è±¡çš„ `weak_ptr` çš„æ•°é‡

**æ§åˆ¶å—æ˜¯çº¿ç¨‹å®‰å…¨çš„**ï¼Œè¿™æ„å‘³ç€å¤šä¸ªçº¿ç¨‹å¯ä»¥å®‰å…¨åœ°æ“ä½œå¼•ç”¨è®¡æ•°å’Œè®¿é—®ç®¡ç†å¯¹è±¡ï¼Œå³ä½¿è¿™äº› `shared_ptr` å®ä¾‹æ˜¯åŒä¸€å¯¹è±¡çš„å‰¯æœ¬ä¸”å…±äº«æ‰€æœ‰æƒä¹Ÿæ˜¯å¦‚æ­¤ã€‚å› æ­¤ï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥å®‰å…¨åœ°åˆ›å»ºã€é”€æ¯å’Œå¤åˆ¶ `shared_ptr` å¯¹è±¡ï¼Œå› ä¸ºè¿™äº›æ“ä½œä»…å½±å“æ§åˆ¶å—ä¸­çš„å¼•ç”¨è®¡æ•°ã€‚

ç„¶è€Œï¼Œ`shared_ptr` å¯¹è±¡å®ä¾‹æœ¬èº«å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚`shared_ptr` å¯¹è±¡å®ä¾‹åŒ…å«ä¸€ä¸ªæŒ‡å‘æ§åˆ¶å—çš„æŒ‡é’ˆå’Œä¸€ä¸ªæŒ‡å‘åº•å±‚å…ƒç´ çš„æŒ‡é’ˆã€‚è¿™ä¸¤ä¸ªæŒ‡é’ˆçš„æ“ä½œåœ¨å¤šä¸ªçº¿ç¨‹ä¸­å¹¶æ²¡æœ‰åŒæ­¥æœºåˆ¶ã€‚å› æ­¤ï¼Œå¦‚æœå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€ä¸ª `shared_ptr` å¯¹è±¡å®ä¾‹å¹¶è°ƒç”¨é `const` æˆå‘˜å‡½æ•°ï¼ˆå¦‚ `reset` æˆ– `operator=`ï¼‰ï¼Œè¿™äº›æ“ä½œä¼šå¯¼è‡´å¯¹è¿™äº›æŒ‡é’ˆçš„å¹¶å‘ä¿®æ”¹ï¼Œè¿›è€Œå¼•å‘æ•°æ®ç«äº‰ã€‚

å¦‚æœä¸æ˜¯åŒä¸€ shared_ptr å¯¹è±¡ï¼Œæ¯ä¸ªçº¿ç¨‹è¯»å†™çš„æŒ‡é’ˆä¹Ÿä¸æ˜¯åŒä¸€ä¸ªï¼Œæ§åˆ¶å—åˆæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé‚£ä¹ˆè‡ªç„¶ä¸å­˜åœ¨æ•°æ®ç«äº‰ï¼Œå¯ä»¥å®‰å…¨çš„è°ƒç”¨æ‰€æœ‰æˆå‘˜å‡½æ•°ã€‚

------

ä½¿ç”¨ `std::atomic<shared_ptr>` ä¿®æ”¹ï¼š

```c++
std::atomic<std::shared_ptr<Data>> data = std::make_shared<Data>();

void writer() {
    for (int i = 0; i < 10; ++i) {
        std::shared_ptr<Data> new_data = std::make_shared<Data>(i);
        data.store(new_data); // åŸå­åœ°æ›¿æ¢æ‰€ä¿æœ‰çš„å€¼
        std::this_thread::sleep_for(10ms);
    }
}

void reader() {
    for (int i = 0; i < 10; ++i) {
        if (auto sp = data.load()) {
            std::cout << "è¯»å–çº¿ç¨‹å€¼: " << sp->get_value() << std::endl;
        }
        else {
            std::cout << "æ²¡æœ‰è¯»å–åˆ°æ•°æ®" << std::endl;
        }
        std::this_thread::sleep_for(10ms);
    }
}
```

å¾ˆæ˜¾ç„¶ï¼Œè¿™æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œ`store` æ˜¯åŸå­æ“ä½œï¼Œè€Œ `sp->get_value()` åªæ˜¯ä¸ªè¯»å–æ“ä½œã€‚

æˆ‘çŸ¥é“ï¼Œä½ è‚¯å®šä¼šæƒ³ç€ï¼š*èƒ½ä¸èƒ½è°ƒç”¨ `load()` æˆå‘˜å‡½æ•°åŸå­åœ°è¿”å›åº•å±‚çš„ `std::shared_ptr` å†è°ƒç”¨ `swap` æˆå‘˜å‡½æ•°ï¼Ÿ*

å¯ä»¥ï¼Œä½†æ˜¯æ²¡æœ‰æ„ä¹‰ï¼Œå› ä¸º **`load()` æˆå‘˜å‡½æ•°è¿”å›çš„æ˜¯åº•å±‚ `std::shared_ptr` çš„å‰¯æœ¬**ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªä¸´æ—¶å¯¹è±¡ã€‚å¯¹è¿™ä¸ªä¸´æ—¶å¯¹è±¡è°ƒç”¨ `swap` å¹¶ä¸ä¼šæ”¹å˜ `data`ï¼Œä¹Ÿå°±æ˜¯åŸå­å¯¹è±¡ä¸­çš„å€¼ï¼Œå› æ­¤è¿™ç§æ“ä½œæ²¡æœ‰å®é™…æ„ä¹‰ï¼Œå°½ç®¡è¿™ä¸ä¼šå¼•å‘æ•°æ®ç«äº‰ï¼ˆå› ä¸ºæ˜¯å‰¯æœ¬ï¼‰ã€‚

ç”±äºæˆ‘ä»¬æ²¡æœ‰å¯¹è¯»å†™æ“ä½œè¿›è¡ŒåŒæ­¥ï¼Œåªæ˜¯ç¡®ä¿äº†æ“ä½œçš„çº¿ç¨‹å®‰å…¨ï¼Œæ‰€ä»¥å¤šæ¬¡è¿è¡Œæ—¶å¯èƒ½ä¼šçœ‹åˆ°ä¸€äº›æ— åºçš„æ‰“å°ï¼Œè¿™æ˜¯æ­£å¸¸çš„ã€‚

ä¸è¿‡äº‹å®ä¸Š `std::atomic<std::shared_ptr>` çš„åŠŸèƒ½ç›¸å½“æœ‰é™ï¼Œå•çœ‹å®ƒæä¾›çš„ä¿®æ”¹æ¥å£ï¼ˆ`=`ã€`store`ã€`load`ã€`exchang`ï¼‰å°±èƒ½æ˜ç™½ã€‚å¦‚æœè¦æ“ä½œå…¶ä¿æŠ¤çš„å…±äº«æŒ‡é’ˆæŒ‡å‘çš„èµ„æºè¿˜æ˜¯å¾— `load()` è·å–åº•å±‚å…±äº«æŒ‡é’ˆçš„å‰¯æœ¬ã€‚æ­¤æ—¶å†è¿›è¡Œæ“ä½œæ—¶å°±å¾—è€ƒè™‘ `std::shared_ptr` æœ¬èº«åœ¨å¤šçº¿ç¨‹çš„æ”¯æŒäº†ã€‚

------

åœ¨ä½¿ç”¨ `std::atomic<std::shared_ptr>` çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¦æ³¨æ„ç¬¬ä¸‰ç« ä¸­å…³äºå…±äº«æ•°æ®çš„ä¸€å¥è¯ï¼š

> **åˆ‡å‹¿å°†å—ä¿æŠ¤æ•°æ®çš„æŒ‡é’ˆæˆ–å¼•ç”¨ä¼ é€’åˆ°äº’æ–¥é‡ä½œç”¨åŸŸä¹‹å¤–**ï¼Œä¸ç„¶ä¿æŠ¤å°†**å½¢åŒè™šè®¾**ã€‚

åŸå­ç±»å‹ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ï¼Œä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```c++
std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>(10);
*ptr.load() = 100;
```

1. è°ƒç”¨ `load()` æˆå‘˜å‡½æ•°ï¼ŒåŸå­åœ°è¿”å›åº•å±‚å…±äº«æŒ‡é’ˆçš„**å‰¯æœ¬** `std::shared_ptr`
2. è§£å¼•ç”¨ï¼Œç­‰ä»· `*get()`ï¼Œè¿”å›äº† `int&`
3. ç›´æ¥ä¿®æ”¹è¿™ä¸ªå¼•ç”¨æ‰€æŒ‡å‘çš„èµ„æºã€‚

åœ¨ç¬¬ä¸€æ­¥æ—¶ï¼Œå·²ç»è„±ç¦»äº† `std::atomic` çš„ä¿æŠ¤ï¼Œç¬¬äºŒæ­¥å°±è·å–äº†è¢«ä¿æŠ¤çš„æ•°æ®çš„å¼•ç”¨ï¼Œç¬¬ä¸‰æ­¥è¿›è¡Œäº†ä¿®æ”¹ï¼Œè¿™å¯¼è‡´äº†æ•°æ®ç«äº‰ã€‚å½“ç„¶äº†ï¼Œè¿™ç§åšæ³•éå¸¸çš„æ„šè ¢ï¼Œåªæ˜¯ä¸ºäº†è¡¨ç¤ºï¼Œæ‰€è°“çš„çº¿ç¨‹å®‰å…¨ï¼Œä¹Ÿæ˜¯è¦é **å¼€å‘è€…çš„æ­£ç¡®ä½¿ç”¨**ã€‚

æ­£ç¡®çš„ç”¨æ³•å¦‚ä¸‹ï¼š

```c++
std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>(10);
std::atomic_ref<int> ref{ *ptr.load() };
ref = 100; // åŸå­åœ°èµ‹ 100 ç»™è¢«å¼•ç”¨çš„å¯¹è±¡
```

é€šè¿‡ä½¿ç”¨ [`std::atomic_ref`](https://zh.cppreference.com/w/cpp/atomic/atomic_ref) æˆ‘ä»¬å¾—ä»¥ç¡®ä¿åœ¨ä¿®æ”¹å…±äº«èµ„æºæ—¶ä¿æŒæ“ä½œçš„åŸå­æ€§ï¼Œä»è€Œé¿å…äº†æ•°æ®ç«äº‰ã€‚

------

æœ€åå†æ¥ç¨å¾®èŠä¸€èŠæä¾›çš„ `wait`ã€`notify_one` ã€`notify_all` æˆå‘˜å‡½æ•°ã€‚è¿™å¹¶éæ˜¯ `std::atomic<shared_ptr>` ä¸“å±ï¼ŒC++20 ä»¥åä»»ä½• atomic çš„ç‰¹åŒ–éƒ½æ‹¥æœ‰è¿™äº›æˆå‘˜å‡½æ•°ï¼Œä½¿ç”¨èµ·æ¥ä¹Ÿéƒ½ååˆ†çš„ç®€å•ï¼Œæˆ‘ä»¬è¿™é‡Œç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­ä¸ºä½ å±•ç¤ºä¸€ä¸‹ï¼š

```c++
std::atomic<std::shared_ptr<int>> ptr = std::make_shared<int>();

void wait_for_wake_up(){
    std::osyncstream{ std::cout }
        << "çº¿ç¨‹ "
        << std::this_thread::get_id()
        << " é˜»å¡ï¼Œç­‰å¾…æ›´æ–°å”¤é†’\n";

    // ç­‰å¾… ptr å˜ä¸ºå…¶å®ƒå€¼
    ptr.wait(ptr.load());

    std::osyncstream{ std::cout }
        << "çº¿ç¨‹ "
        << std::this_thread::get_id()
        << " å·²è¢«å”¤é†’\n";
}

void wake_up(){
    std::this_thread::sleep_for(5s);

    // æ›´æ–°å€¼å¹¶å”¤é†’
    ptr.store(std::make_shared<int>(10));
    ptr.notify_one();
}
```

### å†…å­˜åº

[ï¼Ÿï¼Ÿï¼Ÿè°ˆè°ˆ C++ ä¸­çš„å†…å­˜é¡ºåº (Memory Order) - Luyu Huang's Blog](https://luyuhuang.tech/2022/06/25/cpp-memory-order.html#æ€»ç»“)

















# é¡¹ç›®è¦æ±‚ï¼Ÿï¼Ÿï¼Ÿ

å­¦å®Œæ¨¡æ¿ç¼–ç¨‹åï¼Œé’ˆå¯¹äº‘ä¼šè®®é¡¹ç›®ä¸­çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå®Œæˆä»¥ä¸‹éœ€æ±‚ï¼š

1. å°†åŸæœ‰çš„çº¿ç¨‹åˆ›å»ºæ–¹å¼æ”¹ä¸ºï¼šã€ŠC++å¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹p27çš„å½¢å¼ï¼Œ[#joining_thread](#å®ç°joining_thread)
1. æ‰¾ä¸€ä¸ªèƒ½æ›´æ–°ä¸ºå•ä¾‹çš„ç±»ï¼Œå•ä¾‹å®ç°çœ‹[#è¿™é‡Œ](#çº¿ç¨‹å®‰å…¨çš„å•ä¾‹æ¨¡å¼)
1. æ¶ˆæ¯é˜Ÿåˆ—æ”¹ä¸º[#æ­¤å½¢å¼](#çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—)ï¼›åŒæ—¶ç»™æ¨¡æ¿ä¸ŠSFINAEï¼Œåªå…è®¸ç‰¹å®šç±»å‹ä»¬ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—ï¼›å¹¶ä½¿ç”¨CRTPå‡å°‘å†—ä½™ä»£ç ï¼›å¹¶å°†queueæ”¹ä¸ºå¾ªç¯é˜Ÿåˆ—ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ”¹æˆæ— é”é˜Ÿåˆ—ï¼Œä½¿ç”¨`shared_ptr<>`åŒ…è£…æ•°æ®ï¼ˆC++å¹¶å‘ç¼–ç¨‹å®æˆ˜161ï¼‰
1. çº¿ç¨‹æ± æ”¹æˆ[#æ­¤å½¢å¼](#çº¿ç¨‹æ± )ï¼ŒåŒæ—¶å‚è€ƒasioä¸­çš„çº¿ç¨‹åº“ä»¥åŠ[GitHub - anda522/ThreadPool](https://github.com/anda522/ThreadPool?tab=readme-ov-file)å’Œ[è®¾è®¡ä¸å®ç°æ”¯æŒä¼˜å…ˆçº§ä»»åŠ¡çš„C++çº¿ç¨‹æ± ](https://zhuanlan.zhihu.com/p/681425628)ä¸­æ¶‰åŠåˆ°çš„ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ŒåŠ ä¸€ä¸ªçº¿ç¨‹æ± çš„`join()`ï¼Œä¿è¯èƒ½æ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡ï¼›åŒæ—¶æ­é…ä¸Šæ–°çš„å•ä¾‹æ¨¡å¼ï¼›åŒæ—¶å‚è€ƒ`std::future<>`ï¼Œè¡¥å……ä¸€ä¸ª`static_assert<>`è¿›è¡Œæ£€æµ‹ï¼›åŒæ—¶è‡ªå·±æµ‹è¯•ï¼Œå¦‚æœå‡½æ•°å‚æ•°ä¼ é€’æ—¶ï¼Œä¼šè°ƒç”¨å‡ æ¬¡æ„é€ å‡½æ•°ï¼ˆå…³é—­nrvoï¼‰ï¼›åŒæ—¶è¿›è¡Œå¼‚å¸¸å¤„ç†ï¼›åŒæ—¶è¿›è¡Œæ¨¡æ¿å‚æ•°æ£€æµ‹ï¼›åŒæ—¶æ›´æ¢æ‰`shared_ptr`ã€‚
1. åˆå§‹åŒ–é¡ºåºå½“ä½œé¡¹ç›®é—®é¢˜ï¼š[æ€»ç»“-å‹˜è¯¯åˆå§‹åŒ–é¡ºåº](#æ€»ç»“-å‹˜è¯¯åˆå§‹åŒ–é¡ºåº)



[^1]: æ³¨ï¼š æ¯”è¾ƒå’Œå¤åˆ¶æ˜¯**é€ä½**çš„ï¼ˆç±»ä¼¼ [std::memcmp](https://zh.cppreference.com/w/cpp/string/byte/memcmp) å’Œ [std::memcpy](https://zh.cppreference.com/w/cpp/string/byte/memcpy)ï¼‰ï¼›ä¸ä½¿ç”¨æ„é€ å‡½æ•°ã€èµ‹å€¼è¿ç®—ç¬¦æˆ–æ¯”è¾ƒè¿ç®—ç¬¦ã€‚
[^2]: å³ä½¿ expected ä¸åŸå­å¯¹è±¡çš„å€¼ç›¸ç­‰ï¼Œè¡¨ç°å¦‚åŒ `*this != expected` [â†©ï¸](https://mq-b.github.io/ModernCpp-ConcurrentProgramming-Tutorial/md/05å†…å­˜æ¨¡å‹ä¸åŸå­æ“ä½œ.html#footnote-ref2)
