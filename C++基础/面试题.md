## 快速排序

[#看这里](../C++八股文/C++学习难点.md#快速排序（O(NlogN))

## 设计模式

[#看这里](../C++八股文/C++学习难点.md#设计模式)

单例（使用crtp模板实现），工厂，观察者（使用lambda函数注册回调实现）

对于工厂模式而言，我们工作中通常是使用类似 `parent_ptr = getInstance(order)` 的形式，其中`getInstance(order)`中的实现大致是通过传入的order中的部分flag来区分不同类型的委托，从而创建不同交易类别的子类

## 调试方法/崩溃处理

1. 测试环境：

   对于输出异常，需要结合日志观察数据的变化，对于崩溃，需要结合生成的coredump文件定位最后崩溃的位置，结合业务确定崩溃原因（在公司中没有打开过coredump文件，只能通过日志和打断点来推测）

2. 生产环境

   先看生产环境的日志，获取崩溃的模块号和模块入参，然后尝试在测试环境中复现

## STL底层实现

[#看这里](../C++八股文/C++学习难点.md#STL的底层实现)

### vector

[面试题：C++vector的动态扩容，为何是1.5倍或者是2倍_vector扩容-CSDN博客](https://blog.csdn.net/qq_44918090/article/details/120583540)

### string

### 哈希表

哈希表是一种基于哈希函数的映射数据结构，用于高效地存储和查找数据。其核心思想是通过将数据的键（key）映射到数组中的一个索引位置，从而实现快速存取。在哈希表的实现中，有几个关键要素需要注意：

- 数据结构

  哈希表内部是一个数组，每个数组槽（slot）对应一个存储位置。哈希表通过**哈希函数**将数据的键（key）映射到数组的索引位置，因此数据会存储在哈希表的特定位置。

- 哈希函数

  哈希表的核心是**哈希函数**，它将任意大小的键（key）映射到一个固定大小的数组索引。哈希函数需要具备以下特性：

  - **高效性**：计算哈希值时应该尽量快。

  - **均匀性**：哈希函数应尽量均匀地将键值分布到整个哈希表中，减少哈希冲突。

  - **确定性**：对于相同的输入，哈希函数应总是返回相同的输出。

  一个简单的哈希函数通常是：`hash(key) % table_size`，其中 `key` 是输入的键，`table_size` 是哈希表的大小。哈希表的大小通常是一个质数，以减少冲突。

- 哈希冲突解决

  哈希冲突是指两个不同的键经过哈希函数映射到相同的索引位置。在哈希表中，通常有两种常见的解决方式：

  - **链地址法（Chaining）**：

    - 每个数组槽存储一个链表或桶，所有映射到同一槽的元素（一个kv对）都会被添加到这个链表中。

    - 如果两个键的哈希值相同（即发生冲突），它们会被存放在同一个链表中，链表会顺序存储这些元素。

  - **开放地址法（Open Addressing）**：

    - 当发生冲突时，通过探查策略（如线性探查、二次探查、双哈希法等）寻找下一个空槽来存储冲突的元素。
    - 不使用额外的数据结构（如链表），而是在哈希表的数组中直接寻找空槽。

- 负载因子与扩容

  - **插入（Insert）**：
    - 通过哈希函数计算插入键的索引位置。如果该位置没有冲突，就直接插入。如果发生冲突，则根据冲突解决策略（链地址法或开放地址法）处理。

  - **查找（Search）**：
    - 通过哈希函数计算键的索引位置。如果该位置存储的是目标键，则返回其对应的值。如果发生冲突（链地址法），则遍历链表查找**目标键**。

  - **删除（Delete）**：
    - 查找目标键并删除。如果使用链地址法，直接从链表中删除该元素。如果使用开放地址法，则需要标记该位置为已删除。

  - **遍历（Traverse）**：
    - 遍历哈希表时，依次访问每个槽的内容，检查槽是否为空。如果该槽存储有数据（链表或其他数据结构），则遍历该槽的内容，访问其中的每个元素。
    - 对于链地址法，遍历每个槽的链表，对于开放地址法，则检查每个槽的元素。如果槽为空或已删除，跳过该槽。
    - 对于链地址法，我们可以使用一个数组来记录有数据的槽，这样可以不需要检查每个槽是否为空了

### 红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉查找树（Binary Search Tree，BST），用于保证数据结构在进行插入和删除操作时保持平衡，从而确保查找操作的时间复杂度为 O(log n)。它是一个典型的平衡二叉查找树，并且在多种算法和数据结构中被广泛使用，特别是在实现如 `std::map` 和 `std::set` 这样的容器时。

- 性质

  红黑树具有以下五个性质，这些性质确保了树的平衡性：

  1. **每个节点要么是红色的，要么是黑色的**。
  2. **根节点是黑色的**。
  3. **所有叶子节点（NIL节点或空节点）都是黑色的**。
  4. **红色节点不能连续出现**。即，如果一个节点是红色的，那么它的子节点必须是黑色的（即不能有两个连续的红色节点）。
  5. **从任意节点到其所有后代的叶子节点的路径上，必须包含相同数目的黑色节点**。这被称为“黑色高度”。

  显然根据以上性质：任意节点到其最长叶子节点路径不会超过最短路径的2倍

  ![img](./assets/v2-39965fba3e7e0ceea2deba09a0446348_1440w.webp)

- 结构

  红黑树的每个节点除了包含键值对和指向左右子节点的指针外，还包含一个表示节点颜色的标志。树的结构通过这些颜色规则保持了平衡，保证了树的最坏情况查找时间不会超过 O(log n)。

- 插入

  插入元素时，首先按普通的二叉查找树规则将新节点插入，然后根据红黑树的规则来调整树的结构，使其仍然符合红黑树的性质。插入操作的步骤如下：

  1. **插入新节点**：将新节点插入到树中，初始时将该节点标记为红色。

  2. **修复不平衡**：插入后的树可能会破坏红黑树的性质（如红色节点连在一起），这时需要进行调整。调整过程通常涉及**旋转**和**颜色翻转**：
     - **旋转**：旋转操作分为左旋和右旋，通过旋转可以改变树的结构，使其重新平衡。
       - 左旋：将节点的右子节点变成新的根节点，而原来的节点变成左子节点
       - 右旋：将节点的左子节点变成新的根节点，而原来的节点变成右子节点。
     - **颜色翻转**：可能需要调整父节点、叔叔节点和祖父节点的颜色，以确保红黑树的性质不被破坏。

  插入操作后，树的高度依然保持在 O(log n) 的范围内，因此查找操作依然是 O(log n)。

- 删除

  删除操作比插入稍微复杂一些，但它同样遵循红黑树的平衡规则。删除元素时，按照普通的二叉查找树规则找到待删除节点并删除，然后需要修复树的不平衡性。修复操作包括旋转和颜色调整，确保红黑树的性质不被破坏。

  - 如果删除的是红色节点，问题较小，通常直接删除即可。
  - 如果删除的是黑色节点，可能会破坏**黑色高度**，需要通过一系列的旋转和重新着色操作来恢复平衡。

- 查找

  查找操作与普通的二叉查找树相同。根据红黑树的特性，查找操作的时间复杂度为 O(log n)，这得益于树的平衡性。

### AVL树

[史上最详细的AVL树（含代码实现）-CSDN博客](https://blog.csdn.net/qq_56999918/article/details/122759059)

[红黑树和AVL树（平衡二叉树）区别_avl 红黑树区别-CSDN博客](https://blog.csdn.net/u010899985/article/details/80981053)

AVL树是带有平衡条件的二叉查找树，一般是用**平衡因子**差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，AVL树是**严格的平衡二叉树**，平衡条件必须满足（所有节点的左右子树高度差的绝对值不超过1）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道**AVL树适合用于插入与删除次数比较少，但查找多的情况，红黑树则相反**

## select

`select` 是 I/O 多路复用模型。在单线程里等待多个套接字的就绪事件并一次性返回就绪集合。

```c++
// 仅展示主干逻辑；套接字创建/读写细节用函数名占位。
int make_listenfd(unsigned short);     // socket/bind/listen
int accept_one(int);                   // accept
int echo_once(int);                    // 读->写回；<=0 表示应关闭
void close_fd(int);                    // close

int main() {
    int listenfd = make_listenfd(8888);

    // allset表示需要监听的fd集合，rset是每次传给select的fd集合
    fd_set allset, rset;
    FD_ZERO(&allset);									// #1
    FD_SET(listenfd, &allset);							// #2
    int maxfd = listenfd;								// 确定监听范围

    // 事件循环
    for (;;) {
        rset = allset;
        int cnt = select(maxfd + 1, &rset, nullptr, nullptr, nullptr);   // #3
        
        // 检查listenfd是否有可读消息，如果有，表示有新的客户端连接
        if (FD_ISSET(listenfd, &rset)) {				// #4
            int clientfd = accept_one(listenfd);
            if (clientfd >= 0) {
                FD_SET(clientfd, &allset);				// #5
                maxfd = max(clientfd, maxfd);
            }
            if (--cnt == 0) 
                continue;
        }
        
        // 检查所有clientfd是否有可读消息
        for (int fd = 0; fd <= maxfd && cnt > 0; ++fd) {
            if (!FD_ISSET(fd, &rset) || fd == listenfd) // #6
                continue;
            --cnt;
            // 读0/错：关闭并移除
            if (echo_once(fd) <= 0) {
                close_fd(fd);
                FD_CLR(fd, &allset);					// #7
                /* 为极简，未更新 maxfd；需要时可使用std::set<>进行管理 */
            }
        }
    }
}
```

解释：

- ```c++
  // 将fd_set变量的所有位初始化为0。
  void FD_ZERO(fd_set* fdset);
  ```

- ```c++
  // 在参数fdset指向的变量中注册文件描述符fd的信息（要求 0 ≤ fd < FD_SETSIZE）
  // 注册后需要及时更新maxfd
  void FD_SET(int fd, fd_set* fdset);
  ```

  `FD_SETSIZE` 定义了 *select* 函数可以监视的文件描述符的最大数量。默认情况下，`FD_SETSIZE` 被设置为 1024

- ```c++
  int select(int nfds, fd_set* readset, fd_set* writeset, fd_set* exceptset, struct timeval* timeout);
  /**
   * @brief 同步等待多个文件描述符的就绪事件（读/写/异常）
   * @param nfds       扫描上界，必须为“当前被监控的最大fd + 1”；仅扫描区间 [0, nfds)
   * @param readfds    读就绪集合；nullptr 不监控读
   * @param writefds   写就绪集合；nullptr 不监控写
   * @param exceptfds  异常集合（如带外数据）；nullptr 不监控异常
   * @param timeout    超时；nullptr 无限阻塞；{0,0} 立即返回；其余为最长等待
   * @return >0 本轮就绪fd数量；0 超时；-1 出错（查 errno，可为 EINTR）
   * @note  select 会就地清零未就绪位，故每轮调用前需先做 rset = allset；
   *        fd 必须 < FD_SETSIZE；关闭fd后需 FD_CLR；增删fd后要维护 maxfd。
   */
  ```

- ```c++
  // 若参数fdset指向的变量中包含文件描述符fd的信息，则返回非0，否则返回0
  int FD_ISSET(int fd, const fd_set* fdset);
  ```

- ```c++
  // 从参数fdset指向的变量中清除文件描述符fd的信息。
  void FD_CLR(int fd, fd_set* fdset);
  ```

## epoll

`epoll` 是 `select` 的一种高效替代方案，同样属于 I/O 多路复用模型。它通过在内核中维护一个“兴趣列表”，并只返回活动连接的方式，解决了 `select` 模型需要重复传递、线性扫描文件描述符集合的低效问题。

```c++
// 仅展示主干逻辑；套接字创建/读写细节用函数名占位。
int make_listenfd(unsigned short);      // socket/bind/listen
int accept_one(int);                    // accept
int echo_once(int);                     // 读->写回；<=0 表示应关闭
void close_fd(int);                     // close

int main() {
    int listenfd = make_listenfd(8888);

    // #1 创建 epoll 实例
    int epollfd = epoll_create1(0);

    // #2 将 listenfd 添加到 epoll 的兴趣列表
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = listenfd;
    epoll_ctl(epollfd, EPOLL_CTL_ADD, listenfd, &ev);

    // 用于接收就绪事件的数组
    struct epoll_event events[1024];

    // 事件循环
    for (;;) {
        // #3 等待就绪事件
        int cnt = epoll_wait(epollfd, events, 1024, -1);

        for (int i = 0; i < cnt; ++i) {
            int sockfd = events[i].data.fd;

            // #4 如果是 listenfd 就绪，表示有新的客户端连接
            if (sockfd == listenfd) {
                int clientfd = accept_one(listenfd);
                if (clientfd >= 0) {
                    ev.events = EPOLLIN;
                    ev.data.fd = clientfd;
                    // #5 将新的 clientfd 添加到兴趣列表
                    epoll_ctl(epollfd, EPOLL_CTL_ADD, clientfd, &ev);
                }
            } else { // #6 否则是已连接的 clientfd 就绪
                // 读0/错：关闭并移除
                if (echo_once(sockfd) <= 0) {
                    close_fd(sockfd);
                    // #7 从兴趣列表中移除
                    epoll_ctl(epollfd, EPOLL_CTL_DEL, sockfd, nullptr);
                }
            }
        }
    }
}
```

解释：

- ```c++
  // 创建一个新的 epoll 实例，并返回指向它的文件描述符。
  // 在 Linux 2.6.8 之后，flags 参数被忽略，但必须为 0。
  // epoll_create1(0) 的行为与 epoll_create(size) 相同（size 被忽略）。
  int epoll_create1(int flags);
  ```

- ```c++
  // 控制 epoll 实例的行为。
  int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
  /**
   * @brief 对 epoll 实例（由 epfd 标识）的兴趣列表进行增、删、改操作。
   * @param epfd      epoll_create1 返回的文件描述符。
   * @param op        要执行的操作，可以是：
   * 		EPOLL_CTL_ADD：向兴趣列表添加 fd。
   * 		EPOLL_CTL_MOD：修改 fd 上注册的事件。
   * 		EPOLL_CTL_DEL：从兴趣列表删除 fd。
   * @param fd        目标文件描述符。
   * @param event     指向 epoll_event 结构体的指针，描述了要监听的事件和用户数据。
   * @return 0 成功；-1 出错（查 errno）。
   *
   * @note  epoll_event 结构体中的 events 字段是位掩码，常用值有：
   * 		EPOLLIN:  关联的文件可用于读操作。
   * 		EPOLLOUT: 关联的文件可用于写操作。
   * 		EPOLLET:  将该 fd 设置为边缘触发（Edge Triggered）模式。
   */
  ```

- ```c++
  // 等待 epoll 实例上的 I/O 事件。
  int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
  /**
   * @brief 同步等待 epoll 实例中兴趣列表里的文件描述符就绪。
   * @param epfd      epoll_create1 返回的文件描述符。
   * @param events    一个数组，用于存储内核返回的、已就绪的事件。
   * @param maxevents 指定 events 数组的大小，必须 > 0。
   * @param timeout   超时（毫秒）；-1 无限阻塞；0 立即返回。
   * @return >0 本轮就绪的 fd 数量；0 超时；-1 出错（查 errno，可为 EINTR）。
   *
   * @note  与 select 不同，epoll_wait 返回后无需遍历所有被监控的 fd，
   * 只需处理 events 数组中前 `cnt` 个元素即可。兴趣列表在内核中维护，
   * 调用返回后无需像 select 一样重置。
   */
  ```

### 条件触发与边缘触发

- 条件触发 (Level-Triggered, LT)
  - **工作模式**: `epoll` 的默认模式。
  - **触发条件**: 只要文件描述符处于就绪状态（例如，其内核接收缓冲区非空），`epoll_wait` 就会返回该描述符。
  - **行为**: 如果本次 `epoll_wait` 返回后，你没有将缓冲区的数据完全处理完，那么下一次调用 `epoll_wait` 时，只要缓冲区中仍有数据，它会**再次**返回该文件描述符。
  - **编程要求**: 逻辑简单，事件不易丢失。
- 边缘触发 (Edge-Triggered, ET)
  - **工作模式**: 通过 `EPOLLET` 标志设置。
  - **触发条件**: 仅当文件描述符的状态发生**变化**时（例如，缓冲区接收到新数据时），`epoll_wait` 才会返回该描述符。
  - **行为**: `epoll_wait` 通常只通知一次。如果在收到通知后没有处理完所有数据，`epoll_wait` **不会**再次返回该描述符，直到下一次状态变化（例如，收到新的网络数据）发生。
  - **编程要求**:
    1. 必须将文件描述符设置为**非阻塞 (Non-blocking)**。
    2. 收到事件通知后，必须在一个循环中持续进行 `read` 或 `write` 操作，直到函数返回 `EAGAIN` 或 `EWOULDBLOCK`，以确保将缓冲区数据处理完毕。
  - 注意：
    1. 在ET模式下，如果没有一次性读完所有数据，那么剩余的数据只有在下一次接收到新数据时才能“搭便车”一起处理
    2. ET模式下必须使用非阻塞IO：
       - **如果使用阻塞 IO**: 当你在循环中最后一次调用 `read()` 时，缓冲区已经空了。此时，`read()` 调用会**阻塞**（挂起线程），等待新数据的到来。这就使得你的单线程事件循环被卡死在这个文件描述符上，无法再去处理其他就绪的描述符，I/O 多路复用也就失去了意义。
       - **如果使用非阻塞 IO**: 当你在循环中最后一次调用 `read()` 且缓冲区已空时，`read()` 调用会**立即返回**一个特定的错误码（`EAGAIN` 或 `EWOULDBLOCK`）。程序可以通过判断这个错误码，得知“数据已全部读完”，从而安全地退出循环，继续处理下一个事件。

## socket编程

[#看这里](../C++八股文/C++学习难点.md#计算机网络)

negal算法：[(69 封私信 / 83 条消息) TCP Nagle 算法：网络优化的双刃剑 - 知乎](https://zhuanlan.zhihu.com/p/683650018)

旨在解决 TCP/IP 网络中的小分组问题。在广域网（WAN）中，频繁发送小数据包可能会导致网络拥塞，因为每个小数据包都需要单独的确认（ACK），这增加了网络的负载。Nagle 算法通过合并小数据包来减少这种拥塞。

**优势：**

减少网络拥塞：通过合并小数据包，减少了网络中的数据包数量，降低了拥塞的可能性。

提高网络效率：在低速网络中，Nagle 算法可以显著提高传输效率。

**劣势：**

增加延迟：在交互式应用中，Nagle 算法可能导致显著的延迟，因为它等待 ACK 或合并数据包。

不适用于实时应用：对于需要快速响应的应用（如在线游戏、实时视频流），Nagle 算法可能会影响用户体验。

# 计算机网络

## OSI七层模型

物理层：底层数据传输，如网线；网卡标准。
数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。
网络层：定义IP编址，定义路由功能；如不同设备的数据转发。
传输层：端到端传输数据的基本功能；如 TCP、UDP。
会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。
表示层：数据格式标识，基本压缩加密功能。
应用层：各种应用软件，包括 Web 应用

## TCP长连接和短链接的区别

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接， 任务结束就中断连接。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。

## TCP粘包/拆包

由于TCP是流式传输的协议，所以对一段数据无法准确判断该段数据的开头和结尾，所以会造成TCP粘包，拆包也是同样的原因

在我的那个开源项目中，我是通过给消息设定开头和结尾来解决TCP粘包和拆包问题的

## URL到显示界面的过程

1. 浏览器接收到⽤户请求，先检查浏览器缓存⾥是否有缓存该资源，如果有直接返回；如果没有进⼊下⼀ 步⽹络请求。
2. ⽹络请求前，进⾏ **DNS解析** ，以获取请求域名的 IP地址 。如果请求协议是 HTTPS ，那么还需要 建⽴TLS连接 。DNS解析时会按本地浏览器缓存->本地 Host ⽂件->路由器缓存-> DNS 服务器-> 根 DNS 服务器的顺序查询域名对应 IP ，直到找到为⽌。
3. **浏览器与服务器IP建⽴TCP连接**。连接建⽴后，浏览器端会构建请求⾏、请求头等信息，并把和该域名 相关的    Cookie 等数据附加到请求头中，向服务器构建请求信息。
4. 服务器接收到请求信息，根据请求⽣成响应数据。
5. 浏览器解析响应头。若响应头状态码为    301、302 ，会重定向到新地址；若响应数据类型是字节流类 型，⼀般会将请求提交给下载管理器；若是HTML类型，会进⼊下⼀部渲染流程。
6. 浏览器解析HTML ⽂件，创建DOM 树，解析    CSS 进⾏样式计算，然后将CSS和DOM合并，构建渲 染树；最后布局和绘制渲染树，完成⻚⾯展示。

## 端口有效范围

0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）
UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从 1024到65535

## TCP头部信息

源端口号，目的端口号：比较简单，不在赘述

序列号：用于 TCP   通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据 通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)。

确认序列号：确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次 已 成功收到数据字节序号加1， 只有当标志位中的  ACK   标 志 为  1   时该确认序列号的字段才有效。 主要用来解决不丢包的问题。

TCPflags：SYN，ACK，FIN，这个会在tcp三次握手/四次挥手时涉及到

滑动窗口大小：用于流量控制

## 三次握手/四次挥手

![image-20240226223624609](./assets/image-20240226223624609.png)

![image-20240226223634374](./assets/image-20240226223634374.png)

## 四次挥手释放连接时，等待2MSL的意义

> MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络 上存在的最长时间，超过这个时间报文将被丢弃。

**为了保证客户端发送的最后一个ACK报文段能够到达服务器。**因为这个ACK有可能丢失，从而导致处在 LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再 重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连 接状态。

## TCP可靠传输实现

序列号，确认序列号，校验和，停止等待，滑动窗口，超时重传，拥塞控制（慢开始，拥塞避免，快重传，快恢复）

## 拥塞控制

> 在某段时间内，如果<font color=red>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。</font>这种情况叫拥塞(congestion)
>
> 资源指的是计算机网络中的链路容量（带宽），交换节点中的缓存和处理机等。

cwnd，swnd，ssthresh定义：

![53d7b99d3c96c5b56054332d1c3ae7eb](./assets/53d7b99d3c96c5b56054332d1c3ae7eb.png)

- 慢开始(slow-start)：cwnd初始值为1，在未发生超时重传，未达到ssthresh时执行的时慢开始算法，此时发送方每接收一轮接收方的ACK报文时（即一个RTT)，cwnd翻倍。注意慢开始指的是一开始向网络注入的报文段少，不是拥塞窗口cwnd增长速度慢
- 拥塞避免(congestion avoidance)：当cwnd=ssthresh时，采用拥塞避免算法，此时每接收一轮接收方的ACK报文，cwnd+1。注意该算法并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络不容易出现拥塞。
- 快重传(fast retransmit)：

![3972602640771459d1e3cf71aecc1de1](./assets/3972602640771459d1e3cf71aecc1de1.png)

- 快恢复(fast recovery)：

![image-20240303112812688](./assets/image-20240303112812688.png)

![ec0dd11864b063dc6f7f99dd66c9df97_720](./assets/ec0dd11864b063dc6f7f99dd66c9df97_720.png)

## TCP对应的应用层协议

FTP：定义了文件传输协议，使用21端口.
Telnet：它是一种用于远程登陆的端口,23端口
SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。
POP3：它是和SMTP对应，POP3用于接收邮件。
HTTPS：443，还需要ssl证书
HTTP：80。

## UDP对应的应用层协议

DNS：用于域名解析服务，用的是53号端口
SNMP：简单网络管理协议，使用161号端口
TFTP(Trival File Transfer Protocal)：简单文件传输协议，69

# 操作系统

## IO多路复用

**IO多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态**，比如调用select和poll函数，传入多个文件描述符，**如果有一个文件描述符就绪，则返回，否则阻塞直到超时**。

[什么是IO多路复用？为什么需要IO多路复用？_串口io复用的作用-CSDN博客](https://blog.csdn.net/Sansipi/article/details/121890431)

## 进程，线程，协程

|          | 进程                                                         | 线程                                                 | 协程                                                         |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| 定义     | 资源调度的基本单位，最小单元                                 | 程序执行的基本单位，最小单元。                       | 用户态的轻量级线程，线程内部调度的基本单位                   |
| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新 调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄 存器和栈的内容          | 先将寄存器上下文和栈保存，等 切换回来的时候再进行恢复        |
| 切换者   | 操作系统                                                     | 操作系统                                             | 用户                                                         |
| 切换过程 | 用户态->内核态-> 用户态                                      | 用户态->内核态-> 用户态                              | 用户态(没有陷入内核)                                         |
| 调用栈   | 内核栈                                                       | 内核栈                                               | 用户栈                                                       |
| 拥有资源 | CPU资源、内存资源、文件资 源和句柄等                         | 程序计数器、寄存器、栈和状态字                       | 拥有自己的寄存器上下文和栈                                   |
| 并发性   | 不同进程之间切换实现并发， 各自占有CPU实现并行               | 一个进程内部的多个线程并发执行                       | 同一时间只能执行一个协程，而 其他协程处于休眠状态，适合对 任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核 栈和硬件上下文，CPU高速缓 存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存 器内容，因此开 销很小   | 同一时间只能执行一个协程，而 其他协程处于休眠状态，适合对 任务进行分时处理 |
| 通信方面 | 进程间通信需要借助操作系统                                   | 线程间可以直接读写进程数据段 (如全局变量)来进 行通信 | 共享内存、消息队列                                           |

## 一个进程可以创建多少线程

一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定。

## 线程之间共享的资源

[线程间到底共享了哪些进程资源 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/352707156#)

由于线程运行的本质就是函数运行，函数运行时信息是保存在栈帧中的，因此每个线程都有自己独立的、私有的栈区。除了栈帧以及线程上下文（程序计数器、栈指针以及函数运行使用的寄存器）以外，其他的都是线程之间共享的

## Linux下进程间通信方式

- 管道：

  - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具 有 亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。
  - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有 亲 缘关系的进程之间使用，管道是先进先出的通信方式。
- 共享内存
- 消息队列
- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。
- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。
- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制， 实现进程、线程的对临界区的同步及互斥访问。

## 进程的状态切换

![image-20240303125714954](./assets/image-20240303125714954.png)

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU  时间片用完之后就会转为就绪 状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时 间会从运行态转换为就绪态。

## 一个程序编译过程

**预处理**：主要处理源代码文件中的以“#”开头的预编译指令

**编译**：把预编译之后生成的文件，进行语法分析，生成相应的汇编文件。

**汇编**：将汇编代码转变成机器指令(机器码文件)。

**链接**：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。

## 死锁

**死锁必要条件**
互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。 
不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放 
请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。 
循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程 所请求。

**处理方法**

**破坏互斥条件**
这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

**破坏请求与保持条件**
一次性申请所有的资源。

**破坏不剥夺条件**
占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

**破坏循环等待条件**
靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
我们对线程 2 的代码修改成下面这样就不会产生死锁了。

银行家算法

## 进程通信方法

无名管道，有名管道，消息队列，共享内存，套接字

## 锁类型

读写锁，互斥锁，条件变量